diff -Naur vbcc/LICENSE /usr/glenda/advbcc/Advent-master/vbcc/LICENSE
--- vbcc/LICENSE	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/LICENSE	Tue Sep 22 04:18:49 2015
@@ -0,0 +1,63 @@
+Everything in the initial checkin of this directory, except for
+this LICENSE file itself, is (c) 2011 Volker Barthelmann.
+
+The initial checkin of this vbcc/ directory contains the original
+source code of Volker Barthelmann's VBCC compiler, as downloaded
+on 2012-05-02 from http://www.ibaug.de/vbcc/vbcc.tar.gz.
+
+According to http://compilers.de/vbcc.html, these sources were
+last updated on 2011-08-16; this corresponds to the modification
+date of machines/ppc/machine.c. The modification date of
+machines/z/* was 2006-05-06.
+
+Barthelmann's license text is included in the TEXI documentation
+in this directory (doc/vbcc.texi), and also available online
+at http://www.ibaug.de/vbcc/doc/vbcc.html, but here it is again:
+
+
+    vbcc is copyright in 1995-2011 by Volker Barthelmann.
+
+    This archive may be redistributed without modifications and used
+    for non-commercial purposes.
+
+    Distributing modified versions and commercial usage needs my written
+    consent.
+
+    This copyright applies to vc, vbcc and vsc.
+
+    This archive may contain other tools (e.g. assemblers or linkers)
+    which do not fall under this license. Please consult the corresponding
+    documentation of these tools.
+
+    vbcc contains the preprocessor ucpp by Thomas Pornin. Included is the
+    copyright notice of ucpp (note that this license does not apply to vbcc
+    or any other part of this distribution):
+
+/*
+ * (c) Thomas Pornin 1999, 2000
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. The name of the authors may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
diff -Naur vbcc/Makefile /usr/glenda/advbcc/Advent-master/vbcc/Makefile
--- vbcc/Makefile	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/Makefile	Tue Sep 22 04:19:43 2015
@@ -1,7 +1,8 @@
-
+TARGET=z
 # used to create vbcc, vc and ucpp
-CC = gcc -std=c9x -g -DHAVE_AOS4 #-DHAVE_ECPP -DHAVE_MISRA
-LDFLAGS = -lm
+CC = pcc
+#CC = gcc -std=c9x -g -DHAVE_AOS4 #-DHAVE_ECPP -DHAVE_MISRA
+#LDFLAGS = -lm
 
 # native version; used to create dtgen
 NCC = $(CC)
diff -Naur vbcc/Makefile.orig /usr/glenda/advbcc/Advent-master/vbcc/Makefile.orig
--- vbcc/Makefile.orig	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/Makefile.orig	Tue Sep 22 04:19:14 2015
@@ -0,0 +1,292 @@
+
+# used to create vbcc, vc and ucpp
+CC = gcc -std=c9x -g -Wno-format-security #-DHAVE_AOS4 -DHAVE_ECPP -DHAVE_MISRA
+LDFLAGS = -lm
+
+# native version; used to create dtgen
+NCC = $(CC)
+NLDFLAGS = $(LDFLAGS)
+
+all: bin/vc bin/vprof bin/vbcc$(TARGET) #bin/vcpp
+
+vbccs: bin/vbccs$(TARGET)
+
+bin/vc: frontend/vc.c
+	$(CC) frontend/vc.c -o bin/vc $(LDFLAGS)
+
+bin/vprof: vprof/vprof.c
+	$(CC) vprof/vprof.c -o bin/vprof $(LDFLAGS)
+
+doc/vbcc.pdf:
+	texi2dvi --pdf doc/vbcc.texi
+
+doc/vbcc.html:
+	(cd doc;texi2html -split=chapter -nosec_nav -frames vbcc.texi)
+	sed -e s/vbcc_13/vbcc_1/ <doc/vbcc_frame.html >doc/vbcc.html
+
+vcppobjs = vcpp/cpp.o vcpp/eval.o vcpp/getopt.o vcpp/hideset.o vcpp/include.o \
+	   vcpp/lex.o vcpp/macro.o vcpp/nlist.o vcpp/tokens.o vcpp/unix.o
+
+vbcc.tar.gz:
+	(cd ..;tar zcvf vbcc.tar.gz vbcc/Makefile vbcc/*.[ch] vbcc/datatypes/*.[ch] vbcc/doc/*.texi vbcc/frontend/vc.c vbcc/machines/*/machine.[ch] vbcc/machines/*/machine.dt vbcc/machines/*/schedule.[ch] vbcc/ucpp/*.[ch] vbcc/ucpp/README vbcc/vprof/vprof.c vbcc/vsc/vsc.[ch])
+
+bin/osekrm: osekrm.c
+	$(CC) osekrm.c -o bin/osekrm
+
+dist: bin/osekrm
+	mv supp.h t1
+	mv supp.c t2
+	mv main.c t3
+	mv machines/ppc/machine.c t4
+	mv declaration.c t5
+	mv flow.c t6
+	mv ic.c t7
+	mv parse_expr.c t8
+	mv statements.c t9
+	mv rd.c t10
+	mv type_expr.c t11
+	bin/osekrm <t1 >supp.h
+	bin/osekrm <t2 >supp.c
+	bin/osekrm <t3 >main.c
+	bin/osekrm <t4 >machines/ppc/machine.c
+	bin/osekrm <t5 >declaration.c
+	bin/osekrm <t6 >flow.c
+	bin/osekrm <t7 >ic.c
+	bin/osekrm <t8 >parse_expr.c
+	bin/osekrm <t9 >statements.c
+	bin/osekrm <t10 >rd.c
+	bin/osekrm <t11 >type_expr.c
+	make vbcc.tar.gz
+	mv t1 supp.h
+	mv t2 supp.c
+	mv t3 main.c
+	mv t4 machines/ppc/machine.c
+	mv t5 declaration.c
+	mv t6 flow.c
+	mv t7 ic.c
+	mv t8 parse_expr.c
+	mv t9 statements.c
+	mv t10 rd.c
+	mv t11 type_expr.c	
+
+bin/vcpp: $(vcppobjs)
+	$(CC) $(LDFLAGS) $(vcppobjs) -o bin/vcpp
+
+vcpp/cpp.o: vcpp/cpp.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/cpp.c -o vcpp/cpp.o
+
+vcpp/eval.o: vcpp/eval.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/eval.c -o vcpp/eval.o
+
+vcpp/getopt.o: vcpp/getopt.c
+	$(CC) -c -Ivcpp vcpp/getopt.c -o vcpp/getopt.o
+
+vcpp/hideset.o: vcpp/hideset.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/hideset.c -o vcpp/hideset.o
+
+vcpp/include.o: vcpp/include.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/include.c -o vcpp/include.o
+
+vcpp/lex.o: vcpp/lex.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/lex.c -o vcpp/lex.o
+
+vcpp/macro.o: vcpp/macro.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/macro.c -o vcpp/macro.o
+
+vcpp/nlist.o: vcpp/nlist.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/nlist.c -o vcpp/nlist.o
+
+vcpp/tokens.o: vcpp/tokens.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/tokens.c -o vcpp/tokens.o
+
+vcpp/unix.o: vcpp/unix.c vcpp/cpp.h
+	$(CC) -c -Ivcpp vcpp/unix.c -o vcpp/unix.o
+
+TRGDIR = machines/$(TARGET)
+
+bobjects = $(TRGDIR)/main.o $(TRGDIR)/vars.o $(TRGDIR)/declaration.o \
+	   $(TRGDIR)/parse_expr.o $(TRGDIR)/type_expr.o $(TRGDIR)/ic.o \
+	   $(TRGDIR)/machine.o $(TRGDIR)/statements.o \
+	   $(TRGDIR)/supp.o $(TRGDIR)/dt.o \
+           $(TRGDIR)/assert.o $(TRGDIR)/cpp.o $(TRGDIR)/hash.o \
+           $(TRGDIR)/lexer.o $(TRGDIR)/macro.o $(TRGDIR)/mem.o \
+           $(TRGDIR)/eval.o
+#           $(TRGDIR)/AdjList.o $(TRGDIR)/DUChain.o \
+#           $(TRGDIR)/ICodeInsertion.o $(TRGDIR)/NodeList.o \
+#           $(TRGDIR)/RAllocMain.o $(TRGDIR)/Web.o
+
+fobjects = $(TRGDIR)/opt.o $(TRGDIR)/av.o $(TRGDIR)/rd.o $(TRGDIR)/regs.o \
+	   $(TRGDIR)/flow.o $(TRGDIR)/cse.o $(TRGDIR)/cp.o $(TRGDIR)/loop.o \
+	   $(TRGDIR)/alias.o $(bobjects)
+
+sobjects = $(TRGDIR)/opts.o $(TRGDIR)/regss.o $(bobjects)
+
+tasm	 = $(TRGDIR)/supp.o $(TRGDIR)/tasm.o $(TRGDIR)/dt.o \
+	   $(TRGDIR)/opt.o $(TRGDIR)/av.o $(TRGDIR)/rd.o $(TRGDIR)/regs.o \
+	   $(TRGDIR)/flow.o $(TRGDIR)/cse.o $(TRGDIR)/cp.o $(TRGDIR)/loop.o \
+	   $(TRGDIR)/alias.o $(TRGDIR)/machine.o
+
+mbasic	 = $(TRGDIR)/supp.o $(TRGDIR)/mbasic.o $(TRGDIR)/dt.o \
+	   $(TRGDIR)/opt.o $(TRGDIR)/av.o $(TRGDIR)/rd.o $(TRGDIR)/regs.o \
+	   $(TRGDIR)/flow.o $(TRGDIR)/cse.o $(TRGDIR)/cp.o $(TRGDIR)/loop.o \
+	   $(TRGDIR)/alias.o $(TRGDIR)/machine.o
+
+minicomp	 = $(TRGDIR)/supp.o $(TRGDIR)/minicompg.tab.o $(TRGDIR)/minicomp.o $(TRGDIR)/dt.o \
+	   $(TRGDIR)/opt.o $(TRGDIR)/av.o $(TRGDIR)/rd.o $(TRGDIR)/regs.o \
+	   $(TRGDIR)/flow.o $(TRGDIR)/cse.o $(TRGDIR)/cp.o $(TRGDIR)/loop.o \
+	   $(TRGDIR)/alias.o $(TRGDIR)/machine.o
+
+vscobjects = $(TRGDIR)/vsc.o $(TRGDIR)/schedule.o
+
+bin/vbcc$(TARGET): $(fobjects)
+	$(CC) $(LDFLAGS) $(fobjects) -o bin/vbcc$(TARGET)
+
+bin/vbccs$(TARGET): $(sobjects)
+	$(CC) $(LDFLAGS) $(sobjects) -o bin/vbccs$(TARGET)
+
+bin/vsc$(TARGET): $(vscobjects)
+	$(CC) $(LDFLAGS) $(vscobjects) -o bin/vsc$(TARGET)
+
+bin/tasm$(TARGET): $(tasm)
+	$(CC) $(LDFLAGS) $(tasm) -o bin/tasm$(TARGET)
+
+bin/mbasic$(TARGET): $(mbasic)
+	$(CC) $(LDFLAGS) $(mbasic) -o bin/mbasic$(TARGET)
+
+bin/minicomp$(TARGET): $(minicomp)
+	$(CC) $(LDFLAGS) $(minicomp) -o bin/minicomp$(TARGET)
+
+bin/dtgen: datatypes/dtgen.c datatypes/datatypes.h datatypes/dtconv.h
+	$(NCC) datatypes/dtgen.c -o bin/dtgen -Idatatypes $(NLDFLAGS)
+
+$(TRGDIR)/dt.h: bin/dtgen $(TRGDIR)/machine.dt
+	bin/dtgen $(TRGDIR)/machine.dt $(TRGDIR)/dt.h $(TRGDIR)/dt.c
+
+$(TRGDIR)/dt.c: bin/dtgen $(TRGDIR)/machine.dt
+	bin/dtgen $(TRGDIR)/machine.dt $(TRGDIR)/dt.h $(TRGDIR)/dt.c
+
+$(TRGDIR)/dt.o: $(TRGDIR)/dt.h $(TRGDIR)/dt.c
+	$(CC) -c $(TRGDIR)/dt.c -o $(TRGDIR)/dt.o -I$(TRGDIR) -Idatatypes
+
+$(TRGDIR)/tasm.o: tasm.c supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c tasm.c -o $(TRGDIR)/tasm.o -I$(TRGDIR)
+
+$(TRGDIR)/mbasic.o: mbasic.c supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c mbasic.c -o $(TRGDIR)/mbasic.o -I$(TRGDIR)
+
+$(TRGDIR)/minicomp.o: minicomp.c minicomp.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c minicomp.c -o $(TRGDIR)/minicomp.o -I$(TRGDIR)
+
+$(TRGDIR)/minicompg.tab.o: minicompg.y minicomplexer.c minicomp.h supp.h
+	bison minicompg.y
+	$(CC) -c minicompg.tab.c -o $(TRGDIR)/minicompg.tab.o -I$(TRGDIR)
+
+$(TRGDIR)/supp.o: supp.c supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c supp.c -o $(TRGDIR)/supp.o -I$(TRGDIR)
+
+$(TRGDIR)/main.o: main.c vbc.h supp.h vbcc_cpp.h ucpp/cpp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c main.c -o $(TRGDIR)/main.o -I$(TRGDIR)
+
+$(TRGDIR)/vars.o: vars.c vbc.h supp.h $(TRGDIR)/machine.h errors.h $(TRGDIR)/dt.h
+	$(CC) -c vars.c -o $(TRGDIR)/vars.o -I$(TRGDIR)
+
+$(TRGDIR)/declaration.o: declaration.c vbc.h supp.h vbcc_cpp.h ucpp/cpp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c declaration.c -o $(TRGDIR)/declaration.o -I$(TRGDIR)
+
+$(TRGDIR)/parse_expr.o: parse_expr.c vbc.h supp.h vbcc_cpp.h ucpp/cpp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c parse_expr.c -o $(TRGDIR)/parse_expr.o -I$(TRGDIR)
+
+$(TRGDIR)/type_expr.o: type_expr.c vbc.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c type_expr.c -o $(TRGDIR)/type_expr.o -I$(TRGDIR)
+
+$(TRGDIR)/ic.o: ic.c vbc.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c ic.c -o $(TRGDIR)/ic.o -I$(TRGDIR)
+
+$(TRGDIR)/statements.o: statements.c vbc.h supp.h vbcc_cpp.h ucpp/cpp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c statements.c -o $(TRGDIR)/statements.o -I$(TRGDIR)
+
+$(TRGDIR)/opt.o: opt.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c opt.c -o $(TRGDIR)/opt.o -I$(TRGDIR)
+
+$(TRGDIR)/av.o: av.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c av.c -o $(TRGDIR)/av.o -I$(TRGDIR)
+
+$(TRGDIR)/rd.o: rd.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c rd.c -o $(TRGDIR)/rd.o -I$(TRGDIR)
+
+$(TRGDIR)/regs.o: regs.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c regs.c -o $(TRGDIR)/regs.o -I$(TRGDIR)
+
+$(TRGDIR)/flow.o: flow.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c flow.c -o $(TRGDIR)/flow.o -I$(TRGDIR)
+
+$(TRGDIR)/cse.o: cse.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c cse.c -o $(TRGDIR)/cse.o -I$(TRGDIR)
+
+$(TRGDIR)/cp.o: cp.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c cp.c -o $(TRGDIR)/cp.o -I$(TRGDIR)
+
+$(TRGDIR)/loop.o: loop.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c loop.c -o $(TRGDIR)/loop.o -I$(TRGDIR)
+
+$(TRGDIR)/alias.o: alias.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c alias.c -o $(TRGDIR)/alias.o -I$(TRGDIR)
+
+$(TRGDIR)/preproc.o: preproc.c vbpp.h supp.h vbc.h $(TRGDIR)/dt.h
+	$(CC) -c preproc.c -o $(TRGDIR)/preproc.o -I$(TRGDIR)
+
+$(TRGDIR)/assert.o: ucpp/assert.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/assert.c -o $(TRGDIR)/assert.o -I$(TRGDIR)
+
+$(TRGDIR)/cpp.o: ucpp/cpp.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/cpp.c -o $(TRGDIR)/cpp.o -I$(TRGDIR)
+
+$(TRGDIR)/hash.o: ucpp/hash.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/hash.c -o $(TRGDIR)/hash.o -I$(TRGDIR)
+
+$(TRGDIR)/lexer.o: ucpp/lexer.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/lexer.c -o $(TRGDIR)/lexer.o -I$(TRGDIR)
+
+$(TRGDIR)/macro.o: ucpp/macro.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/macro.c -o $(TRGDIR)/macro.o -I$(TRGDIR)
+
+$(TRGDIR)/mem.o: ucpp/mem.c ucpp/cpp.h ucpp/mem.h ucpp/hash.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/mem.c -o $(TRGDIR)/mem.o -I$(TRGDIR)
+
+$(TRGDIR)/eval.o: ucpp/eval.c ucpp/cpp.h ucpp/mem.h ucpp/tune.h $(TRGDIR)/dt.h
+	$(CC) -DNO_UCPP_ERROR_FUNCTIONS -c ucpp/eval.c -o $(TRGDIR)/eval.o -I$(TRGDIR)
+
+$(TRGDIR)/machine.o: $(TRGDIR)/machine.c supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h dwarf2.c
+	$(CC) -c $(TRGDIR)/machine.c -o $(TRGDIR)/machine.o -I$(TRGDIR) -I.
+
+$(TRGDIR)/opts.o: opt.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c -DNO_OPTIMIZER opt.c -o $(TRGDIR)/opts.o -I$(TRGDIR)
+
+$(TRGDIR)/regss.o: regs.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c -DNO_OPTIMIZER regs.c -o $(TRGDIR)/regss.o -I$(TRGDIR)
+
+$(TRGDIR)/vsc.o: vsc/vsc.h vsc/vsc.c $(TRGDIR)/schedule.h
+	$(CC) -c vsc/vsc.c -o $(TRGDIR)/vsc.o -I$(TRGDIR)
+
+$(TRGDIR)/schedule.o: vsc/vsc.h $(TRGDIR)/schedule.h $(TRGDIR)/schedule.c
+	$(CC) -c $(TRGDIR)/schedule.c -o $(TRGDIR)/schedule.o -I$(TRGDIR) -Ivsc
+
+
+# Graph coloring register allocator by Alex
+$(TRGDIR)/AdjList.o: GCRegAlloc/AdjList.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/AdjList.c -o $(TRGDIR)/AdjList.o -IGCRegAlloc -I$(TRGDIR)
+
+$(TRGDIR)/DUChain.o: GCRegAlloc/DUChain.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/DUChain.c -o $(TRGDIR)/DUChain.o -IGCRegAlloc -I$(TRGDIR)
+
+$(TRGDIR)/ICodeInsertion.o: GCRegAlloc/ICodeInsertion.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/ICodeInsertion.c -o $(TRGDIR)/ICodeInsertion.o -IGCRegAlloc -I$(TRGDIR)
+
+$(TRGDIR)/NodeList.o: GCRegAlloc/NodeList.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/NodeList.c -o $(TRGDIR)/NodeList.o -IGCRegAlloc -I$(TRGDIR)
+
+$(TRGDIR)/RAllocMain.o: GCRegAlloc/RAllocMain.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/RAllocMain.c -o $(TRGDIR)/RAllocMain.o -IGCRegAlloc -I$(TRGDIR)
+
+$(TRGDIR)/Web.o: GCRegAlloc/Web.c opt.h supp.h $(TRGDIR)/machine.h $(TRGDIR)/dt.h
+	$(CC) -c GCRegAlloc/Web.c -o $(TRGDIR)/Web.o -IGCRegAlloc -I$(TRGDIR)
diff -Naur vbcc/config/z /usr/glenda/advbcc/Advent-master/vbcc/config/z
--- vbcc/config/z	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/config/z	Tue Sep 22 04:19:14 2015
@@ -0,0 +1,5 @@
+-cc=../bin/vbccz -quiet %s -o=%s %s -O=%ld
+-ccv=../bin/vbccz %s -o=%s %s -O=%ld
+-as=cp %s %s
+-ld=echo "Don't know how to link Z-machine code" 1>&2; exit 0
+-rm=rm %s
diff -Naur vbcc/datatypes/dtgen.c /usr/glenda/advbcc/Advent-master/vbcc/datatypes/dtgen.c
--- vbcc/datatypes/dtgen.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/datatypes/dtgen.c	Tue Sep 22 04:19:14 2015
@@ -133,8 +133,8 @@
   do{
     printf("Type y or n [%s]: ",def);
     fflush(stdout);
-    fgets(in,sizeof(in),stdin);
-    if(*in=='\n') strcpy(in,def);
+    if (fgets(in,sizeof(in),stdin) == NULL || *in == '\n')
+      strcpy(in,def);
   }while(*in!='y'&&*in!='n');
   return *in=='y';
 }
@@ -271,7 +271,7 @@
     }else{
       if(!tst(i,spec)){
 	printf("Problem! Your system does not seem to provide all of the data types\n"
-	       "this version of vbcc needs.\nWrite to vb@compilers.de!\n");
+	       "this version of vbcc needs.\nWrite to volker@vb.franken.de!\n");
 	exit(EXIT_FAILURE);
       }
     }
diff -Naur vbcc/declaration.c /usr/glenda/advbcc/Advent-master/vbcc/declaration.c
--- vbcc/declaration.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/declaration.c	Tue Sep 22 04:23:31 2015
@@ -1,7 +1,4 @@
 /*  $VER: vbcc (declaration.c) V0.8     */
-
-#include <string.h>
-
 #include "vbcc_cpp.h"
 #include "vbc.h"
 
@@ -64,7 +61,7 @@
 
 static void clear_main_ret(void)
 {
-  if(c99&&!strcmp(cur_func,"main")&&return_typ&&ISSCALAR(return_typ->flags)){
+  if(c99&&!strcmp(cur_func,"main")&&ISSCALAR(return_typ->flags)){
     /* in c99, main returns 0 if it falls from back */
     struct IC *new=new_IC();
     new->code=SETRETURN;
@@ -109,24 +106,6 @@
   return p;
 }
 
-/* checks whether string is a valid vector type */
-/* returns the dimension */
-static int check_vect(char *s,char *base)
-{
-  int i=strlen(base),dim;
-  if(strncmp(s,base,i)) return 0;
-  dim=s[i];
-  if(dim=='2'||dim=='3'||dim=='4'||dim=='8'){
-    if(s[i+1]==0)
-      return dim-'0';
-    else
-      return 0;
-  }
-  if(s[i]=='1'&&s[i+1]=='6'&&s[i+2]==0)
-    return 16;
-  return 0;
-}
-
 int settyp(int typnew, int typold)
 /* Unterroutine fuer declaration_specifiers().              */
 {
@@ -165,7 +144,6 @@
   struct struct_list (*sl)[];
   size_t slsz;
   struct Var *v;
-  int dim;
 #ifdef HAVE_TARGET_ATTRIBUTES
   unsigned long tattr=0;
 #endif
@@ -604,6 +582,8 @@
 /* removed */
 /* removed */
 /* removed */
+/* removed */
+/* removed */
 #endif
           ident=imerk;
 					add_sl(ssd,sl);
@@ -737,46 +717,6 @@
         next_token();
         if(type_qualifiers&VOLATILE) error(58);
         type_qualifiers|=VOLATILE;notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"bool"))){
-	next_token();
-	typ=settyp(VECBOOL+dim-1,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"char"))){
-	next_token();
-	typ=settyp(VECCHAR+dim-1,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"uchar"))){
-	next_token();
-	typ=settyp((VECCHAR+dim-1)|UNSIGNED,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"short"))){
-	next_token();
-	typ=settyp(VECSHORT+dim-1,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"ushort"))){
-	next_token();
-	typ=settyp((VECSHORT+dim-1)|UNSIGNED,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"int"))){
-	next_token();
-	typ=settyp(VECINT+dim-1,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"uint"))){
-	next_token();
-	typ=settyp((VECINT+dim-1)|UNSIGNED,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"long"))){
-	next_token();
-	typ=settyp(VECLONG+dim-1,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"ulong"))){
-	next_token();
-	typ=settyp((VECLONG+dim-1)|UNSIGNED,typ);
-	notdone=1;
-      }else if(opencl&&(dim=check_vect(ctok->name,"float"))){
-	next_token();
-	typ=settyp(VECFLOAT+dim-1,typ);
-	notdone=1;
 #if 0
       }else if(c99&&!strcmp("restrict",ctok->name)){
         next_token();
@@ -1174,7 +1114,7 @@
       if(!ffreturn(a)&&(a->flags&NQ)!=VOID){
 	rpointer.flags=POINTER_TYPE(a);
         rpointer.next=a;
-        reg_parm(&reg_handle,&rpointer,0,0);
+        if(!reg_parm(&reg_handle,&rpointer,0,0)) ierror(0);
       }
 #endif
 #ifdef HAVE_MISRA
@@ -1611,7 +1551,7 @@
   }
 
   /* make room on the stack */
-  ds=new_node();
+  ds=mymalloc(NODES);
   ds->flags=IDENTIFIER;
   ds->identifier=empty;
   ds->dsize=vlength_szof(v->vtyp);
@@ -1687,7 +1627,7 @@
     gen_label(return_label);
     did_return_label=1;
   }
-  ds=new_node();
+  ds=mymalloc(NODES);
   ds->flags=IDENTIFIER;
   ds->identifier=empty;
   ds->dsize=block_vla[nesting];
@@ -1794,6 +1734,7 @@
     vla_nesting(p,vn,&nest);
   }
   ierror(0);
+  return;
 }
 
 void vla_jump_fix(void)
@@ -1857,7 +1798,7 @@
 	if(DEBUG&1) printf("generating sp-adjust\n");
         merkfic=first_ic;merklic=last_ic;
 	first_ic=0;last_ic=0;
-	ds=new_node();
+	ds=mymalloc(NODES);
 	ds->flags=IDENTIFIER;
 	ds->identifier=empty;
 	ds->dsize=p->savedsp;
@@ -2068,33 +2009,6 @@
     if((storage_class&OLDSTYLE)&&f==FLOAT){
       /*  Bei alten Funktionen werden DOUBLE nach FLOAT konvertiert   */
       if(!(storage_class&REGPARM)){
-#if HAVE_LIBCALLS
-	static struct Typ dt={DOUBLE},ft={FLOAT};
-	static struct node n,nn;
-	struct IC *conv=new_IC();
-	n.flags=REINTERPRET;
-	n.left=&nn;
-	n.ntyp=&dt;
-	nn.flags=IDENTIFIER;
-	nn.identifier=identifier;
-	nn.ntyp=&ft;
-	nn.o.flags=VAR|DONTREGISTERIZE;
-	nn.o.v=new;
-	nn.o.val.vmax=l2zm(0L);
-	n.o=nn.o;
-	convert(&n,FLOAT);
-	
-
-	conv->code=ASSIGN;
-	conv->typf=FLOAT;
-	conv->q1=n.o;
-	conv->z.v=new;
-	conv->z.flags=VAR;
-	conv->z.val.vmax=l2zm(0L);
-	conv->q2.val.vmax=sizetab[FLOAT];
-	conv->z.v=new;
-	add_IC(conv);	
-#else
 	struct IC *conv=new_IC();
 	conv->code=CONVERT;
 	conv->typf=FLOAT;
@@ -2105,7 +2019,6 @@
 	conv->q1.v=conv->z.v=new;
 	conv->q1.val.vmax=conv->z.val.vmax=l2zm(0);
 	add_IC(conv);
-#endif
       }
       new->flags|=CONVPARAMETER;
     }
@@ -2302,7 +2215,6 @@
 /* removed */
 #endif
   ts=declaration_specifiers();notdone=1;
-
   storage_class=return_sc;hard_reg=return_reg;vattr=return_vattr;
   inline_flag=return_inline;
 #ifdef HAVE_ECPP
@@ -2406,10 +2318,7 @@
           error(27,vident);
         }else{
           if(t&&v->vtyp&&!compatible_types(v->vtyp,t,NU|CONST|VOLATILE)){
-	    if(ISFUNC(t->flags)&&!ISFUNC(v->vtyp->flags))
-	      error(361,vident);
-	    else
-	      error(68,vident);
+            error(68,vident);
 #ifdef HAVE_MISRA
 /* removed */
 #endif
@@ -2717,7 +2626,7 @@
       add_sl(t->exact,&sl);
       nesting++;
     }
-    if(om&&om->exact&&!compare_sd(om->exact,t->exact)) {
+    if(om&&!compare_sd(om->exact,t->exact)) {
       error(123);
 #ifdef HAVE_MISRA
 /* removed */
@@ -2742,12 +2651,9 @@
         rt->flags=POINTER_TYPE(return_typ);rt->next=return_typ;
 #ifdef HAVE_REGPARMS
         reg=reg_parm(&reg_handle,rt,0,v->vtyp);
-        if(!reg){
-	  return_var=add_var(empty,clone_typ(rt),AUTO|PARAMETER|oldstyle,0);
-	}else{
-	  return_var=add_var(empty,clone_typ(rt),reg<0?(AUTO|PARAMETER|REGPARM|DBLPUSH|oldstyle):(AUTO|PARAMETER|REGPARM|oldstyle),0);
-	  return_var->reg=reg;
-	}
+        if(!reg) ierror(0);
+        return_var=add_var(empty,clone_typ(rt),reg<0?(AUTO|PARAMETER|REGPARM|DBLPUSH|oldstyle):(AUTO|PARAMETER|REGPARM|oldstyle),0);
+        return_var->reg=reg;
 #else
         return_var=add_var(empty,clone_typ(rt),AUTO|PARAMETER|oldstyle,0);
 #endif
@@ -2830,22 +2736,6 @@
 /* removed */
 #endif
 
-    if(c99){
-      /* c99 predefined __func__ */
-      struct Typ *ft=new_typ();
-      struct Var *fnc;
-
-      /* create type */
-      ft->flags=ARRAY;
-      ft->size=l2zm((long)strlen(cur_func)+1);
-      ft->next=new_typ();
-      ft->next->flags=CONST|CHAR;
-
-      /* use string_expression() to create const_list */
-      fnc=add_var("__func__",ft,STATIC,cl_from_string(cur_func,cur_func+strlen(cur_func)));
-      fnc->flags|=DEFINED;
-    }
-
     /* Generate intermediate code for function */
     compound_statement();
 
@@ -3065,7 +2955,6 @@
         if(p->storage_class==STATIC||p->storage_class==EXTERN){
           if(!(p->flags&GENERATED)){
             if(p->storage_class==EXTERN&&!(p->flags&(USEDASSOURCE|USEDASDEST))&&!(p->flags&(TENTATIVE|DEFINED))) continue;
-	if(p->storage_class==STATIC&&p->nesting>0&&!(p->flags&(USEDASSOURCE|USEDASDEST))) continue;
             /*  erst konstante initialisierte Daten */
             if(mode==0){
               if(!p->clist) continue;
@@ -3430,53 +3319,6 @@
   return 0;
 }
 
-/* declare a builtin function with up to two scalar arguments */
-struct Var *declare_builtin(char *name,int ztyp,int q1typ,int q1reg,int q2typ,int q2reg,int nosidefx,char *asm)
-{
-  struct struct_declaration *sd;
-  struct Typ *t;
-  struct Var *v;
-  int args;
-  if(!(v=find_ext_var(name))){
-    sd=mymalloc(sizeof(*sd));
-    if(q1typ==0) args=1;
-    else if(q2typ!=0) args=3;
-    else args=2;
-    sd->sl=mymalloc(args*sizeof(struct struct_list));
-    memset(sd->sl,0,args*sizeof(struct struct_list));
-    sd->count=args;
-    if(q1typ){
-      (*sd->sl)[0].styp=new_typ();
-      (*sd->sl)[0].styp->flags=q1typ;
-      (*sd->sl)[0].reg=q1reg;
-    }
-    if(q2typ){
-      (*sd->sl)[1].styp=new_typ();
-      (*sd->sl)[1].styp->flags=q2typ;
-      (*sd->sl)[1].reg=q2reg;
-    }
-    (*sd->sl)[args-1].styp=new_typ();
-    (*sd->sl)[args-1].styp->flags=VOID;
-    t=new_typ();
-    t->flags=FUNKT;
-    t->exact=add_sd(sd,FUNKT);
-    t->next=new_typ();
-    t->next->flags=ztyp;
-    v=add_var(name,t,EXTERN,0);
-    v->flags|=BUILTIN;
-    if(asm||nosidefx){
-      v->fi=new_fi();
-      if(asm) v->fi->inline_asm=asm;
-      if(nosidefx){
-	v->fi->call_cnt=v->fi->use_cnt=v->fi->change_cnt=0;
-	v->fi->flags=ALL_CALLS|ALL_USES|ALL_MODS|ALWAYS_RETURNS|NOSIDEFX;
-      }
-    }
-  }
-  return v;
-}
-
-
 struct const_list *initialization(struct Typ *t,int noconst,int level,int desi,struct struct_declaration *fstruct,struct const_list *first)
 /*  Traegt eine Initialisierung in eine const_list ein.         */
 {
@@ -3547,9 +3389,6 @@
 	  push_token(&mtok);
 	}
       }
-
-      if(bracket&&zmeqto(i,l2zm(0L))) error(360);
-
 #ifdef HAVE_MISRA
 /* removed */
 /* removed */
@@ -3611,9 +3450,6 @@
 	push_token(&mtok);
       }
     }
-
-    if(bracket&&zmeqto(i,l2zm(0L))) error(360);
-
 #ifdef HAVE_MISRA
 /* removed */
 /* removed */
diff -Naur vbcc/doc/interface.texi /usr/glenda/advbcc/Advent-master/vbcc/doc/interface.texi
--- vbcc/doc/interface.texi	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/doc/interface.texi	Tue Sep 22 04:18:49 2015
@@ -1043,12 +1043,6 @@
 to type @code{MINADDI2P} when they are to be added to a pointer.
 This may be subsumed by @code{shortcut()} in the future.
 
-@item #define MAXADDI2P <type>
-Insert the largest integer type
-that can be added to a pointer. Larger types will be automatically converted
-to type @code{MAXADDI2P} when they are to be added to a pointer.
-This may be subsumed by @code{shortcut()} in the future.
-
 @item #define BIGENDIAN <0/1>
 Insert 1 if integers are represented in big endian, i.e. the
 most significant byte is at the lowest memory address, the least significant
@@ -1134,30 +1128,6 @@
 Insert this line if the backend provides an own @code{printval} function
 @pxref{tgtprintval}).
 
-@item #define JUMP_TABLE_DENSITY <float>
-@item #define JUMP_TABLE_LENGTH <int>
-These values controls the creation of jump-tables (@pxref{jumptables}).
-
-
-@item #define ALLOCVLA_REG <reg>
-@item #define ALLOCVLA_INLINEASM <inline-asm>
-@item #define FREEVLA_REG <reg>
-@item #define FREEVLA_INLINEASM <inline-asm>
-@item #define OLDSPVLA_INLINEASM <inline-asm>
-@item #define FPVLA_REG <reg>
-Necessary defines for C99 variable-length-arrays (@pxref{vlas}).
-
-@item #define HAVE_LIBCALLS 1
-Insert this line if the backend wants certain ICs to be replaced with
-calls to library functions (@pxref{libcalls}).
-
-@item #define AVOID_FLOAT_TO_UNSIGNED 1
-@item #define AVOID_UNSIGNED_TO_FLOAT 1
-Insert these lines to tell the frontend not to generate @code{CONVERT} ICs
-that convert between unsigned integers and floating point. In those cases,
-additional intermediate code will be generated that implements the
-conversion using only signed integers.
-
 @end table
 
 @section @file{machine.c}
@@ -2069,62 +2039,10 @@
     jmp   somefunc
 @end example
 
-@node jumptables
-@subsection Jump Tables
-
-An important optimization is the creation of jump-tables for a series of
-comparisons with constants. Such series are usually created by a C
-@code{switch} construct, but vbcc can also recognize some of them if they
-are created through @code{if}-sequences.
-
-@file{supp.c} provides the function @code{calc_case_table(<IC>,<density>)}
-to check for constructs that can be replaced by a jump table. The arguments
-are the start IC to look for (it has to be a @code{COMPARE}-IC with a 
-constant as @code{q2}) and a minimal density. The density reflects the
-number of cases that are used divided by the range of cases. If the density
-is high, vbcc will use jump-tables only for sequences that have few unused
-cases inside. If the case tables occupy multiple ranges, vbcc is able to split
-them up and create multiple jump-tables.
-
-@code{calc_case_table} returns a pointer to a @code{struct case_table} with
-the following content:
-
-@table @code
-@item num
-The number of cases.
-
-@item typf
-The type of the case IDs.
-
-@item next_ic
-The first IC after the list of ICs that can be replaced by the jump-table.
-
-@item density
-The case density.
-
-@item vals
-The values of the case IDs (array containing @code{num} entries).
-
-@item labels
-The labels of the code corresponding to the case IDs
-(array containing @code{num} entries).
-
-@item min
-The lowest case ID.
-
-@item max
-The highest case ID.
-
-@item diff
-@code{max-min}.
 
-@end table
+@subsection Jump Tables
 
-If the backend decides to emit a jump-table, it has to generate code that
-will check that the control expression lies between @code{min} and @code{max}.
-If not, the jump-table must not be executed. Code for the computed jump
-must then be generated. The actual table can be emitted using
-@code{emit_jump_table()}. Processing can then continue with @code{next_ic}.
+FIXME: To be written.
 
 @node targetralloc
 @subsection Context-sensitive Register-Allocation
@@ -2180,21 +2098,7 @@
 @node regsmodified
 @subsection Inter-procedural Register-Allocation
 
-To support inter-procedural register allocation, the backend must tell the
-optimizer which registers are used by a function. As the backend might use
-some registers internally, the frontend can not know this.
-
-Apart from defining @code{HAVE_REGS_MODIFIED} in @file{machine.h}, the
-backend has to mark all registers that are modified in the bitfield
-@code{regs_modified}. A register can be marked with
-@code{BSET(regs_modified,<reg>)}. For a call IC, the function @code{calc_regs()}
-(from @file{supp.h}) can be called to mark the registers used by a call IC.
-It will return 1 if it was able to determine all registers used by this IC.
-
-If the register usage could be determined for the entire function, the
-backend can set the bit @code{ALL_REGS} in the fi-member of the function
-variable (@code{v->fi->flags|=ALL_REGS;}).
-
+FIXME: To be written.
 
 @subsection Conditional Instructions
 
@@ -2203,9 +2107,7 @@
 @node extic
 @subsection Extended ICs
 
-If the backend defines @code{HACE_EXT_IC}, it has to define a
-@code{struct ext_ic} in @file{machine.h}. This structure will be added
-to each IC and can be used by the backend for private use.
+FIXME: To be written.
 
 @node asmpeephole
 @subsection Peephole Optimizations on Assembly Output
@@ -2271,17 +2173,7 @@
 @node markeffics
 @subsection Marking of efficient ICs
 
-If the backend sets @code{HAVE_EFF_ICS} in @file{machine.h}, it has to
-provide a function @code{void mark_eff_ics(void)}. This function will be
-called (possibly multiple times) by the frontend. The function has to set
-or clear the bit @code{EFF_IC} in the member @code{flags} of every IC.
-
-The flag should be set when the operation is in a context that suggests
-it will translate to efficient machine code. The optimizer will transform
-this IC less aggressively.
-
-As this is all happens before register allocation, the decision is of a very
-heuristic nature.
+FIXME: To be written.
 
 @subsection Function entry/exit Code
 
@@ -2336,31 +2228,7 @@
 
 @subsection Block copying
 
-There are many cases of copying of larger data. For the backend, those
-will mostly be used in @code{PUSH} and @code{ASSIGN} ICs. It is very
-important to implement those as efficient as possible.
-
-Some things to consider:
-
-@itemize @minus
-@item When alignment is known, use word-copy instead of byte-copy.
-
-@item Copy small blocks by a series of copy instructions.
-
-@item For larger blocks, loading addresses in registers may help.
-
-@item For large blocks, use a loop. Implement it efficiently and try to
-unroll the loop a few times.
-
-@item For very large blocks, calling a library function may be useful. While
-this creates some overhead, the function can dynamically check the alignment
-or perhaps even use special hardware, if available.
-
-@item Set @code{INLINEMEMCOPY} to reasonable values. Set it to a very high
-value if you implement very good block copying.
-
-@end itemize
-
+FIXME: To be written.
 
 @subsection Optimized Library Functions
 
@@ -2690,105 +2558,11 @@
 The library function is responsible to take into account its own
 stack-frame.
 
+
 @subsection Profiling
 
 FIXME: To be written.
 
-@node{vlas}
-@subsection Variable-length Arrays
-
-With the @code{-c99} option, vbcc supports variable-length arrays that
-are allocated on the stack. The backend has to take several steps to
-support this:
-
-@table @code
-@item vlas
-When this variable is non-zero, the current function uses variable-length
-arrays. The backend may take necessary steps to support this. For example,
-if local variables are usually addressed via stackpointer, switching to a
-separate framepointer may be necessary.
-
-@item ALLOCVLA_INLINEASM
-This define must contain inline code that is called when a vla is
-allocated. It has to create additional room on the stack and return a
-pointer to the beginning of the new space.
-
-@item ALLOCVLA_REG
-The register in which to pass the size to be allocated on the stack. 0 will
-pass on the stack.
-
-@item FREEVLA_INLINEASM
-This define must contain inline code that is called when a vla is
-freed. It has to restore the old stack pointer.
-
-@item FREEVLA_REG
-The register in which to pass the old stack pointer. 0 will
-pass on the stack.
-
-@item OLDSPVLA_INLINEASM
-This define must contain inline code that is called before the first vla is
-allocated. It has to return the current stack pointer before any vla has
-been allocated.
-
-@item FPVLA_REG
-An additional register used in functions containing vlas. The backend can
-specify a register (usually framepointer) that can not be used in functions
-with vlas. Therefore, it is possible to use this register in other functions
-(for example, if local variables are usually addressed directly through the
-stackpointer).
-
-@end table
-
-@node{libcalls}
-@subsection Library Calls
-
-Sometimes operations may be very complicated to generate code for (e.g.
-floating-point operations for machines without FPU, multiplication/division
-on some architectures or big data types like @code{long long}). Those are
-usually implemented by calling library functions.
-
-vbcc can be told to generate calls to library functions for certain ICs. When
-defining @code{HAVE_LIBCALLS}, the backend must provide the function
-@code{char *use_libcall(<code>,<typf>,<typf2>)}. This function gets
-called with the elements @code{code}, @code{typf} and @code{typf2} of an IC.
-If @code{use_libcall} returns a name, this library function will be called
-instead of the IC. Otherwise, 0 must be returned.
-
-All library functions have to be declared in @code{init_cg()} with
-@code{declare_builtin()}, supporting the following arguments:
-
-@table @code
-
-@item name
-The name of the library function. Usually, a reserved identifier should be
-chosen (e.g. starting with @code{__}).
-
-@item ztyp
-The return type of the function (only integral and float types are supported).
-
-@item q1typ
-The type of the first parameter (only integral and float types are supported).
-
-@item q1reg
-The register to pass the first argument in (0 passes via stack).
-
-@item q2typ
-The type of the second parameter (only integral and float types are supported).
-For functions with a single parameter, use 0.
-
-@item q2reg
-The register to pass the second argument in (0 passes via stack).
-
-@item nosidefx
-If this is non-zero, the function will be declared to have no side-effects
-and allow some more optimizations.
-
-@item inline_asm
-Inline assembly can be specified for the function.
-
-@end table
-
-Note that not all ICs can be converted to library calls.
 
 
 @section Changes from 0.7 Interface
diff -Naur vbcc/doc/vbcc.texi /usr/glenda/advbcc/Advent-master/vbcc/doc/vbcc.texi
--- vbcc/doc/vbcc.texi	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/doc/vbcc.texi	Tue Sep 22 04:18:49 2015
@@ -1,8 +1,3 @@
-\ifx\pdfminorversion\undefined
- \pdfoptionpdfminorversion=3
-\else
- \pdfminorversion=3
-\fi
 \input texinfo
 
 @setfilename index.texi
@@ -384,10 +379,6 @@
 @node 68hc12 Backend
 @chapter 68hc12 Backend
 @include vbcchc12.texi
-
-@node VideoCore IV Backend
-@chapter VideoCore IV Backend
-@include vbccvidcore.texi
 
 @node Instruction Scheduler
 @chapter Instruction Scheduler
diff -Naur vbcc/doc/vbcc_main.texi /usr/glenda/advbcc/Advent-master/vbcc/doc/vbcc_main.texi
--- vbcc/doc/vbcc_main.texi	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/doc/vbcc_main.texi	Tue Sep 22 04:18:49 2015
@@ -211,9 +211,8 @@
     @item -maxerrors=n
                 Abort the compilation after n errors; do not stop if n==0.
 
-    @item -dontwarn=n[,n...]
+    @item -dontwarn=n
                 Suppress warning number n; suppress all warnings if n<0.
-                Multiple warnings may be separated by commas.
                 @xref{Errors and Warnings}
 
     @item -warn=n
@@ -1497,7 +1496,7 @@
       @item #pragma warn <n>
         Enables warning number n. Must be followed by @code{#pragma popwarn}.
 
-      @item #pragma popwarn
+      @item pragma popwarn
         Undoes the last modification done by @code{#pragma warn} or
         @code{#pragma dontwarn}.
 
@@ -1717,10 +1716,10 @@
 these side-effects using the following special variable-attributes
 (@pxref{Variable Attributes}).
 
-The @code{__regsused(<register-list>)} attribute specifies the volatile
-registers used or modified by a function. The register list is a list of
-register names (as defined in the backend-documentation) separated by
-slashes and enclosed in double-quotes, e.g.
+The @code{__regsused(<register-list>)} attribute specifies the registers
+used or modified by a function. The register list is a list of register
+names (as defined in the backend-documentation) separated by slashes and
+enclosed in double-quotes, e.g.
 
 @code{        __regsused("d0/d1") int abs();}
 
@@ -1815,7 +1814,6 @@
     @item Gary Watson
     @item Andrea Vallinotto
     @item Johnny Tevessen
-    @item Eero Tamminen
     @item Gabriele Svelto
     @item Dirk Stoecker
     @item Ralph Schmidt
@@ -1858,3 +1856,7 @@
     @item Alkinoos Alexandros Argiropoulos
     @item Thomas Aglassinger
 @end itemize
+
+
+
+
diff -Naur vbcc/doc/vbccvidcore.texi /usr/glenda/advbcc/Advent-master/vbcc/doc/vbccvidcore.texi
--- vbcc/doc/vbccvidcore.texi	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/doc/vbccvidcore.texi	Thu Jan  1 00:00:00 1970
@@ -1,157 +0,0 @@
-This chapter documents the Backend for the VideoCore IV processor family.
-
-The backend is in a very early stage, it is not complete, and it can not
-yet be considered useful!
-
-Also note that it is based on freely available, inofficial, and possibly
-incorrect information on the target processor.
-
-@section Additional options for this version
-
-This backend provides the following additional options:
-
-@table @option
-
-    @item -short-double
-
-                Use native 32bit floating point for double and long double.
-                This is much more efficient, but not ISO C conforming.
-
-    @item -one-section
-
-                Put all code and data in the same section (.text).
-
-
-    @item -no-delayed-popping
-
-                By default arguments of function calls are not always popped
-                from the stack immediately after the call, so that the
-                arguments of several calls may be popped at once.
-                With this option @command{vbcc} can be forced to pop them after every
-                function call.
-                This may simplify debugging and reduce the
-                stack size needed by the compiled program.
-
-    @item -no-peephole
-
-                Disable most backend peephole optimizations.
-                Just for testing.
-
-    @item -noext-regs
-
-                Do not use registers r16-r23. Just for testing.
-
-    @item -cond-limit=<n>
-
-                Set the limit (in number of intermediate code instructions)
-                for the length of code-sequences considered for conditional
-                execution (default: 2).
-
-
-@end table
-
-@section ABI
-
-        This backend supports the following registers:
-
-        @itemize @minus
-        @item @code{r0} through @code{r31} for the general purpose registers
-        @end itemize
-
-        Additionally, the register pairs @code{r0/r1} @code{r2/r3, r4/r5, r6/r7, r8/r9,
-        r10/r11, r12/r13, r14/r15,
-        r16/r17, r18/r19, r20/r21, r22/r23} are
-        available.
-
-        @code{r14, r15, r24-r31} are currently reserved by the
-        backend.
-
-        
-
-    The current version generates assembly output for use with @file{vasm}.
-
-
-    The registers r0-r5 and r14-r15 are used as scratch registers
-    (i.e. they can be destroyed in function calls), all other registers are
-    preserved. r25 is the stack-pointer.
-
-    The first 6 function arguments which have integer, float32 or pointer types
-    are passed in registers r0 through r5. All other arguments
-    are passed on the stack.
-
-    Integers, float32 and pointers are returned in r0.
-    All other types are returned by passing the function the address
-    of the result as a hidden argument - so when you call such a function
-    without a proper declaration in scope you can expect a crash.
-
-    The elementary data types are represented like:
-
-    @example
-    type        size in bits        alignment in bytes
-
-    char                8                       1 
-    short              16                       2 
-    int                32                       4 
-    long               32                       4 
-    long long          64                       8    not yet supported
-    all pointers       32                       4 
-    float              32                       4 
-    double             64 (32)                  4 
-    long double        64 (32)                  4
-    @end example
-
-@section Target-specific variable-attributes
-
-    The vidcore-backend offers the following variable-attributes:
-
-@table @code
-
-    @item __section("name","attr")
-                 Place this function/object in section "name" with
-                 attributes "attr".
-@end table
-
-
-@section Target-specific pragmas
-
-    The vidcore-backend offers the following #pragmas:
-
-@table @code
-
-       @item none at the moment...
-
-@end table
-
-@section Predefined Macros
-
-        This backend defines the following macros:
-
-@table @code
-        @item __VIDEOCORE__
-
-        @item __SHORT_DOUBLE__ (if -short-double is used)        
-@end table
-
-@section Stdarg
-
-stdarg-implementation is not yet fully working. One restriction is that
-when calling a varargs function, the prototype must be in scope (this is
-ISO C conforming). Another one is that the stdarg-macros only work as
-long as all fixed arguments are passed in registers.
-
-This will be fixed in the future.
-
-
-@section Known problems
-
-@itemize @minus
-         @item no support for long long
-         @item no support for 64bit floating point
-         @item stdarg problems mentioned above
-         @item suboptimal code quality
-         @item ...
-@end itemize
-
-
-
-
diff -Naur vbcc/doc/vclib.texi /usr/glenda/advbcc/Advent-master/vbcc/doc/vclib.texi
--- vbcc/doc/vclib.texi	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/doc/vclib.texi	Tue Sep 22 04:18:49 2015
@@ -887,27 +887,13 @@
 @end example
 
 
-@section Atari TOS/MiNT
-
-This section describes specifics of the C library for Atari TOS and MiNT.
-M680x0 processors are supported by the target @file{m68k-atari}, while
-ColdFire processors are supported by the target @file{cf-atari}. Both
-share the same startup-code and are based on common library sources and
-header files. Executables linked with this C library run on plain TOS as
-well as on MiNT, without modifications.
-
+@section Atari MiNT
+ 
+This section describes specifics of the C library for MiNT, a multitasking
+operating system for Atari 16/32 bit computers. Executables linked with
+this C library do also run on plain TOS, without modifications.
 The relevant files are @file{startup.o}, @file{minstart.o},
-@file{libvc.a}, @file{libvc16.a}, @file{libm.a}, @file{libm16.a}.
-
-The following config files are available:
-@table @code
-@item tos
-  M68k 32-bit @code{int}
-@item tos16
-  M68k 16-bit @code{int}
-@item toscf
-  ColdFire 32-bit @code{int}
-@end table
+@file{libvc.a}, @file{libvcs.a}, @file{libm.a}, @file{libms.a}.
 
 @subsection Startup
  
@@ -915,7 +901,7 @@
 global variables and initializes stdin, stdout and stderr and returns
 the unneeded memory to the system.
 The exit code closes all open files and frees all memory.
-
+ 
 @subsection Floating point
 
 Note that you have to link with a math library if you want to use
@@ -933,25 +919,20 @@
 which can adjust the stack size of an executable to any value, by looking
 for a symbol named @code{__stksize} (defined by vclib's startup code).
 
-Additionally the required stack size can be specified by defining a
-variable @code{__stack} (of type @code{size_t}) with external linkage, as
-in other vbcc targets.
-
-@subsection 16-bit integer model
-
-The default libraries use 32-bit @code{int} types, but you may want to
-use 16-bit @code{int} types for compatibility reasons. In this case you
-have to specify the config file @code{tos16} and link with the appropriate
-16-bit libraries (which have a '@file{16}' attached to their name).
-
-To compile and link a program using 16-bit integers a command like
+@subsection Small data model
 
+When using the small data model, you also have
+to link with appropriate libraries. Most libraries documented here are
+also available as small data versions (with an 's' attached to the
+file name).
+ 
+To compile and link a program using the small data model a command like
+ 
 @example
-vc +tos16 test.c -o test -lm16 -lvc16
+vc test.c -o test -sd -lms -lvcs
 @end example
  
-may be used. There are no 16-bit versions for ColdFire targets,
-because this is strictly a 32-bit CPU.
+might be used.
 
 @subsection Restrictions
  
@@ -965,177 +946,74 @@
  
 @item clock()
 The @code{clock()} function always returns -1. This is correct,
-according to the C standard, because neither under TOS nor under MiNT it
-is possible to obtain the time used by the calling process.
+according to the C standard, because under MiNT it is not possible to
+obtain the time used by the calling process.
 
 @end table
 
-@section VideoCore/Linux
-
-This section describes specifics of the C library for VideoCore under Linux.
 
-The relevant files are @code{vcload}, @file{startup.o},
-@file{libvc.a}, @file{libm.a}, @file{libms.a}.
+@section Atari TOS
+ 
+This section describes specifics of the C library for Atari 16/32 bit
+computers (Atari ST/TT, Atari Falcon, etc.).
+The relevant files are @file{startup.o}, @file{minstart.o},
+@file{libvc.a}, @file{libvcs.a}, @file{libm.a}, @file{libms.a}.
 
-The config file @code{vc4-linux} is part of the library.
+This target differs from Atari MiNT, as it uses 16 bit @code{int} data types.
+@code{int} arguments on the stack are also passed in 2 bytes. Therefore you
+should use the 16 bit aware @code{vbccm68ks} compiler.
 
 @subsection Startup
  
-The startup code @file{startup.o} sets up stack and heap and provides
-a function @code{__armcall()} to transfer control to the loader on
-the ARM side.
-The startup process calls constructors to set up some
-global variables and initialize stdin, stdout and stderr if needed.
-
+The startup code @file{startup.o} sets up some
+global variables and initializes stdin, stdout and stderr and returns
+the unneeded memory to the system.
+The exit code closes all open files and frees all memory.
+ 
 @subsection Floating point
 
 Note that you have to link with a math library if you want to use
-floating point operations that are not natively implemented.
-All math functions, special startup code and
+floating point. All math functions, special startup code and
 printf/scanf functions which support floating point are contained in
 the math libraries only.
 
-@subsection Stack
-
-The library contains a default stack of 32KB. If another size is needed,
-you can add the following to your project:
+At the moment (@file{libm.a}) is a soft-float library, which is compatible
+with all the Atari models without an FPU. There may be real FPU support
+in future updates.
 
-@example
-        .align  4
-        .space  <desired-size, suitably aligned>
-___stackend:
-        .global ___stackend
-@end example
+@subsection Stack
 
-@subsection Heap
+Stack-handling is similar to AmigaOS/68k (@xref{amiga-stack}).
+The default stack size is 4k.
 
-Currently, a global variable of 16KB is used to get memory for
-malloc() etc.  If another size is needed,
-you can add the following to your project:
+@subsection Small data model
 
+When using the small data model, you also have
+to link with appropriate libraries. Most libraries documented here are
+also available as small data versions (with an 's' attached to the
+file name).
+ 
+To compile and link a program using the small data model a command like
+ 
 @example
-#define HEAPSIZE <desired size>
-
-char __heap[HEAPSIZE],*__heapptr=__heap;
-size_t __heapsize=HEAPSIZE;
+vc test.c -o test -sd -lms -lvcs
 @end example
-
-Note that this mechanism will likely be changed in the future!
-
-@subsection System Calls
-
-To access system functions from the VideoCore-side, the function
-@code{__armcall()} can be used. It will save the current context and return
-to the loader. Registers @code{r0-r5} (the function arguments) will be saved
-and are available to the loader. The loader can then execute the system
-call and resume execution, passing the return value of the system
-function.
-
-Resuming is done by calling the image with offset 2.
-
-This functionality can also be used for debugging purposes.
-
-@subsection Loader
-
-A loader is required to execute VideoCore code from the ARM side. For
-standalone VideoCore code, the provided loader can be used. Usually, it
-will be necessary to adapt the loader to communicate between ARM and
-VideoCore side during runtime.
-
-@subsubsection Object Format
-
-Currently, the loader loads an simple binary image that must be pc-relative
-and located to address 0x00000000. Additionally, if present, a file
-with extension @file{.reltext} will be loaded for some limited
-relocation. This file contains a 32bit word containing the number of
-relocations followed by n 32bit words containing an offset. For each
-offset, the address will be relocated to the image load address.
-
-@subsubsection Command line arguments
-
-@code{vcload [-debug] [-cache] [-offset] <image-name>}
-
-The loader currently has the following options:
-
-@table @code
-
-@item -debug
-
-    The loader will enter debug mode (see below).
-
-@item -cache
-
-    The loader will set the LSB in the start address when executing
-    code. This is supposed to inhibit a cache flush.
-
-    Just for testing!
-
-@item -offset
-
-    The loader will allocate 1 KB more memory than required and leaves
-    this space unused at the beginning of the allocated memory.
-
-    Just for testing!
-
-@end table
-
-@subsubsection Debug Mode
-
-In debug mode, the loader will wait for user input before starting the
-VideoCore code as well as after every @code{__armcall}.
-
-The following commands are available:
-
-@table @code
-@item w <addr> [<num>]
-      Display <num> 32bit words starting at <addr>.
-      <addr> must be the offset into the image. If <num> is omitted,
-      one unit is displayed.
-
-      If one word is displayed, it is additionally displayed translated
-      as an offset into the image.
-
-@item h <addr> [<num>]
-      Display <num> 16bit halfwords starting at <addr>.
-      <addr> must be the offset into the image. If <num> is omitted,
-      one unit is displayed.
-
-@item b <addr> [<num>]
-      Display <num> 8bit bytes starting at <addr>.
-      <addr> must be the offset into the image. If <num> is omitted,
-      one unit is displayed.
-
-@item c
-      Start/continue execution.
-
-@item q
-      Quit.
-
-@item bp <addr>
-      Set a breakpoint at <addr>.
-
-      This is currently a very crude implementation. It will just write
-      a branch to @code{__armcall()} to <addr>. If everything works well,
-      you will end in the debugger if <addr> is reached. However, the
-      arguments passed are random (and might be dangerous syscalls by 
-      accident). Also, the old code at this address is currently not
-      restored.
-
-      As a result, you must not continue execution after hitting a
-      breakpoint!
-@end table
-
+ 
+might be used.
 
 @subsection Restrictions
  
 The following list contains some restrictions of this version of the
 library:
  
-@itemize @minus
+@table @code
  
-@item no real floating point support yet
-
-@item lots, lots, lots...
-
+@item tmpfile()
+The @code{tmpfile()} function always returns an error.
+ 
+@item clock()
+The @code{clock()} function always returns -1. This is correct,
+according to the C standard, because under TOS it is not possible to
+obtain the time used by the calling process.
 
-@end itemize
+@end table
diff -Naur vbcc/dwarf2.c /usr/glenda/advbcc/Advent-master/vbcc/dwarf2.c
--- vbcc/dwarf2.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/dwarf2.c	Tue Sep 22 04:18:49 2015
@@ -521,7 +521,7 @@
 
 static void dwarf2_add_line(int file,int line,int label,char *id)
 {
-  struct dwarf2_line_info *new;
+  struct dwarf2_line_info *new,*p,*lp;
   new=mymalloc(sizeof(*new));
   new->file=file;
   new->line=line;
@@ -533,12 +533,27 @@
     new->id=0;
   }
   new->next=0;
+#if 0
+  for(lp=p=dwarf2_first_li;p;p=p->next){
+    if(p!=lp&&p->file==file&&p->line>=line){
+      new->next=lp->next;
+      lp->next=new;
+      return;
+    }
+    lp=p;
+  }
+#endif
   if(dwarf2_last_li){
     dwarf2_last_li->next=new;
     dwarf2_last_li=new;
   }else{
     dwarf2_first_li=dwarf2_last_li=new;
   }
+#if 0
+  printf("linfo:\n");
+  for(p=dwarf2_first_li;p;p=p->next)
+    printf("li: line=%d\n",p->line);
+#endif
 }
 
 static void dwarf2_setup(int sa,char *dwarfd1s,char *dwarfd2s,char *dwarfd4s,char *das,char *lps,char *ips,char *ds)
diff -Naur vbcc/errors.h /usr/glenda/advbcc/Advent-master/vbcc/errors.h
--- vbcc/errors.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/errors.h	Tue Sep 22 04:18:49 2015
@@ -360,5 +360,3 @@
 "unterminated // comment",PREPROC|WARNING|ANSIV,
 "initialization of variable-length array",ERROR|ANSIV,
 "initialization of flexible array member",ERROR|ANSIV,
-"empty initializer",ERROR|FATAL|ANSIV,                             /* 360 */
-"redeclaration of var <%s> as new function",ERROR|FATAL|ANSIV,
diff -Naur vbcc/frontend/vc.c /usr/glenda/advbcc/Advent-master/vbcc/frontend/vc.c
--- vbcc/frontend/vc.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/frontend/vc.c	Tue Sep 22 04:21:52 2015
@@ -1,8 +1,8 @@
 /*  Frontend for vbcc                       */
-/*  (c) in 1995-2014 by Volker Barthelmann  */
-/*  #define AMIGA for Amiga version         */
-/*  #define ATARI for Atari version         */
+/*  (c) in 1995-2010 by Volker Barthelmann  */
+/*  #define AMIGA for Amiga-Version         */
 
+#include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -15,7 +15,6 @@
 #include <dos/dosasl.h>
 #endif
 #include <dos/dosextens.h>
-#include <dos/dostags.h>
 #include <exec/libraries.h>
 #include <proto/dos.h>
 #pragma default-align
@@ -68,7 +67,6 @@
 #define ASSRC 4
 #define OBJ 5
 
-char *vbccenv;
 char empty[]="";
 /*  Namen der einzelnen Phasen  */
 char *ppname=empty,*ccname=empty,*asname=empty,*ldname=empty,*l2name=empty;
@@ -129,13 +127,13 @@
 char *tmpnam(char *p)
 {
   static int c=1675;
-  static char tmp[NAMEBUF];
+  static char tmp[256];
   char *env;
 
   env=getenv("TEMP");
   if(!env) env=".";
   if(!p) p=tmp;
-  snprintf(p,NAMEBUF,"%s\\vbcc%04x",env,++c);
+  sprintf(p,"%s\\vbcc%04x",env,++c);
   return p;
 }
 #endif
@@ -179,37 +177,12 @@
     exit(rc);
 }
 
-#ifdef NO_LONGER_NEEDED
-/* Launch command from "$VBCC\bin\", when no absolute path was specified. */
-static int runcmd(char *cmd)
-{
-    char *p;
-
-    for(p=cmd;*p!=0&&*p>' ';p++){
-        if(*p==':')  /* absolute path */
-            goto do_cmd;
-    }
-    if(vbccenv){
-        /* prepend "$VBCC\bin\" in front of our command */
-        int len=strlen(vbccenv);
-        if(vbccenv[len-1]=='\\') len--;
-        memmove(cmd+len+5,cmd,strlen(cmd)+1);
-        memcpy(cmd,vbccenv,len);
-        memcpy(cmd+len,"\\bin\\",5);
-    }
-do_cmd:
-    return system(cmd);
-}
-#else
-#define runcmd(c) system(c)
-#endif
-
 static void del_scratch(struct NameList *p)
 {
     while(p){
         sprintf(command,rmname,p->obj);
         if(flags&VERBOSE) printf("%s\n",command);
-        if(runcmd(command)){printf("%s failed\n",command);raus(EXIT_FAILURE);}
+        if(system(command)){printf("%s failed\n",command);raus(EXIT_FAILURE);}
         p=p->next;
     }
 }
@@ -232,40 +205,50 @@
     }
 }
 
+static char *derelativize(int from_cfg, char *old_path)
+{
+    if (from_cfg && !strncmp(old_path, "../", 3)) {
+        char *vbcc_dir = getenv("VBCC");
+        int vbcc_dir_len;
+        char *new_path;
+        assert(vbcc_dir != NULL);  /* or we'd already have bailed */
+        vbcc_dir_len = strlen(vbcc_dir);
+        new_path = malloc(vbcc_dir_len + 1 + strlen(old_path+3) + 1);
+        sprintf(new_path, "%s%s%s",
+                vbcc_dir,
+                vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+                old_path+3);
+        return new_path;
+    }
+    return old_path;
+}
+
 static int read_config(const char *cfg_name)
 {
     int i,count; long size;
-    char *p,*name;
-    FILE *file=0;
-    for(i=0;i<sizeof(search_dirs)/sizeof(search_dirs[0]);i++){
-      name=malloc(strlen(search_dirs[i])+strlen(cfg_name)+1);
-      if(!name) {printf(nomem);raus(EXIT_FAILURE);}
-      strcpy(name,search_dirs[i]);
-      strcat(name,cfg_name);
-      file=fopen(name,"r");
-      free(name);
-      if(file) break;
-    }
-    if(!file){
-      if(p=vbccenv){
-        name=malloc(strlen(p)+strlen(cfg_name)+20);
-        if(!name){printf(nomem);raus(EXIT_FAILURE);}
-        strcpy(name,p);
-#if defined(_WIN32)||defined(MSDOS)||defined(ATARI)
-        strcat(name,"\\config\\");
-        strcat(name,cfg_name);
-#elif defined(AMIGA)
-        AddPart(name,"config",strlen(p)+strlen(cfg_name)+20);
-        AddPart(name,(STRPTR)cfg_name,strlen(p)+strlen(cfg_name)+20);
-#else
-        strcat(name,"/config/");
-        strcat(name,cfg_name);
-#endif
-        file=fopen(name,"r");
-        free(name);
-      }
+    char *p;
+    char *vbcc_dir = getenv("VBCC");
+    int vbcc_dir_len;
+    char *config_fullpath;
+    FILE *file;
+    if (vbcc_dir == NULL) {
+        puts("Environment variable VBCC must point to the vbcc install directory!");
+        raus(EXIT_FAILURE);
+    }
+    vbcc_dir_len = strlen(vbcc_dir);
+    config_fullpath = malloc(vbcc_dir_len + 1 + 7 + strlen(cfg_name) + 1);
+    sprintf(config_fullpath, "%s%s%s%s",
+            vbcc_dir,
+            vbcc_dir[vbcc_dir_len-1] == '/' ? "" : "/",
+            "config/",
+            cfg_name);
+    file = fopen(config_fullpath, "r");
+    if (file == NULL) {
+        printf("Config file %s not found!\n"
+               "Is environment variable VBCC set correctly?\n",
+               config_fullpath);
+        raus(EXIT_FAILURE);
     }
-    if(!file) {puts("No config file!");raus(EXIT_FAILURE);}
     if(fseek(file,0,SEEK_END)) return 0;
     size=ftell(file);
     if(fseek(file,0,SEEK_SET)) return 0;
@@ -323,32 +306,6 @@
     return str;
 }
 
-#if defined(_WIN32)||defined(MSDOS)||defined(ATARI)||defined(AMIGA)
-static char *convert_path(char *path)
-{
-    char c,*p,*newpath;
-    newpath=p=malloc(strlen(path)+1);
-    while(c=*path++){
-#ifdef AMIGA
-        if(c=='.'){
-            if(*path=='/') continue;
-            if(*path=='.'&&*(path+1)=='/'){
-                path++;
-                continue;
-            }
-        }
-#else
-        if(c=='/') c='\\';
-#endif
-        *p++=c;
-    }
-    *p=0;
-    return newpath;
-}
-#else
-#define convert_path(p) (p)
-#endif
-
 int main(int argc,char *argv[])
 {
     int tfl,i,len=10,pm,count,db=0,staticmode=0;
@@ -362,7 +319,6 @@
             break;
         }
     }
-    vbccenv=getenv("VBCC");
     count=read_config(config_name);
 #ifdef AMIGA
 #if !defined(__amigaos4__) && !defined(__MORPHOS__)
@@ -387,25 +343,26 @@
         if(!strncmp(parm,"-ul=",4)){ul=parm+4;*parm=0;}
     }
     for(i=1;i<argc+count;i++){
-        if(i<argc) parm=argv[i]; else parm=confp[i-argc];
+        int from_cfg = (i >= argc);
+        parm = (from_cfg ? confp[i-argc] : argv[i]);
 /*        printf("Parameter %d=%s\n",i,parm);*/
         if(!strncmp(parm,"-ldnodb=",8)){nodb=parm+8;*parm=0;}
         if(!strncmp(parm,"-ldstatic=",10)){staticflag=parm+10;*parm=0;}
         if(!strcmp(parm,"-g")) db=1;
         if(!strcmp(parm,"-static")){staticmode=1;*parm=0;}
         if(!strncmp(parm,"-ml=",4)){MAXCLEN=atoi(parm+4);*parm=0;}
-        if(!strncmp(parm,"-pp=",4)){ppname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-cc=",4)){ccname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-as=",4)){asname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ld=",4)){ldname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-l2=",4)){l2name=parm+4;*parm=0;}
-        if(!strncmp(parm,"-rm=",4)){rmname=parm+4;*parm=0;}
-        if(!strncmp(parm,"-ppv=",5)){ppv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ccv=",5)){ccv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-asv=",5)){asv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-ldv=",5)){ldv=parm+5;*parm=0;}
-        if(!strncmp(parm,"-l2v=",5)){l2v=parm+5;*parm=0;}
-        if(!strncmp(parm,"-rmv=",5)){rmv=parm+5;*parm=0;}
+        if(!strncmp(parm,"-pp=",4)){ppname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-cc=",4)){ccname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-as=",4)){asname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ld=",4)){ldname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-l2=",4)){l2name=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-rm=",4)){rmname=derelativize(from_cfg, parm+4);*parm=0;}
+        if(!strncmp(parm,"-ppv=",5)){ppv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ccv=",5)){ccv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-asv=",5)){asv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-ldv=",5)){ldv=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-l2v=",5)){l2v=derelativize(from_cfg, parm+5);*parm=0;}
+        if(!strncmp(parm,"-rmv=",5)){rmv=derelativize(from_cfg, parm+5);*parm=0;}
         if(!strncmp(parm,"-cf=",4)){cf=parm+4;*parm=0;}
         if(!strncmp(parm,"-isc=",5)){scname=parm+5;*parm=0;}
         if(!strncmp(parm,"-iscv=",6)){scv=parm+6;*parm=0;}
@@ -460,10 +417,6 @@
             *parm=0;continue;
         }
         len+=strlen(parm)+10;
-#ifdef ATARI
-        if(vbccenv)
-          len+=strlen(vbccenv)+5;
-#endif
     }
     if(!db&&*nodb){
       if(strlen(userlibs)+2+strlen(nodb)>=USERLIBS){
@@ -483,7 +436,7 @@
       userlibs[slen]=' ';
     }
     if(flags&VERBOSE){
-      printf("vc frontend for vbcc (c) in 1995-2014 by Volker Barthelmann\n");
+      printf("vc frontend for vbcc (c) in 1995-2010 by Volker Barthelmann\n");
 #ifdef SPECIAL_COPYRIGHT
       printf("%s\n",SPECIAL_COPYRIGHT);
 #endif
@@ -529,60 +482,59 @@
           parm=argv[i];
         else if(i<argc+count)
           parm=confp[i-argc];
-        else
+        else{
+#ifdef USECMDFILE
+          fclose(cmdfile);
+#endif
           parm=cmfiles;
+        }
         if(!parm||(*parm=='-'&&parm!=cmfiles)||!*parm) continue;
         if(flags&VERYVERBOSE) printf("Argument %d:%s\n",i,parm);
 #ifdef AMIGA
-        if(pm&&parm!=cmfiles)
-            if(MatchFirst((STRPTR)convert_path(parm),ap)){
-                printf("No match for %s\n",parm);continue;
-            }
+        if(pm&&parm!=cmfiles) if(MatchFirst((STRPTR)parm,ap)) {printf("No match for %s\n",parm);continue;}
 #endif
         do{
             if(parm==cmfiles){
-                file=parm;
-                t=CCSRC;
+              file=parm;
+              t=CCSRC;
             }else{
 #ifdef AMIGA
 #ifdef __amigaos4__
-                if(pm) file=(char *)ap->ap_Buffer; else file=parm;
+        if(pm) file=(char *)ap->ap_Buffer; else file=parm;
 #else
-                if(pm) file=(char *)&ap->ap_Buf[0]; else file=parm;
+              if(pm) file=(char *)&ap->ap_Buf[0]; else file=parm;
 #endif
 #else
-                file=convert_path(parm);
+              file=parm;
 #endif
-                t=typ(file);
-                strcpy(namebuf+1,file);
-                strcat(namebuf,"\"");
-                file=namebuf;
+              t=typ(file);
+              strcpy(namebuf+1,file);
+              strcat(namebuf,"\"");
+              file=namebuf;
             }
             if(flags&VERYVERBOSE) printf("File %s=%d\n",file,t);
             if(!cmname&&(flags&CROSSMODULE)&&t<=CCSRC){
-                cmname=malloc(NAMEBUF);
-                if(!cmname){printf(nomem);exit(EXIT_FAILURE);}
-                if(tfl==OBJ){
-                    strcpy(cmname,file);
-                }else{
-                    cmname[0]='\"';
-                    tmpnam(cmname+1);
-                }
+              cmname=malloc(NAMEBUF);
+              if(!cmname){printf(nomem);exit(EXIT_FAILURE);}
+              if(tfl==OBJ){
+                strcpy(cmname,file);
+              }else{
+                cmname[0]='\"';
+                tmpnam(cmname+1);
+              }
             }
             for(j=t;j<tfl;j++){
-                if(j==OBJ){
-                    if(j==t) add_name(file,&first_obj,&last_obj);
-                    continue;
-                }
+                if(j==OBJ){ if(j==t) add_name(file,&first_obj,&last_obj);
+                            continue;}
                 strcpy(oldfile,file);
                 if(file==cmfiles){
-                    file=cmoutput;
+                  file=cmoutput;
                 }else{
-                    if(j==t&&j!=tfl-1&&!(flags&(NOTMPFILE|KEEPSCRATCH))){
-                        file=namebuf2;
-                        tmpnam(file+1);
-                    }
-                    if(j==tfl-1||(flags&WPO)) file=namebuf;
+                  if(j==t&&j!=tfl-1&&!(flags&(NOTMPFILE|KEEPSCRATCH))){
+                    file=namebuf2;
+                    tmpnam(file+1);
+                  }
+                  if(j==tfl-1||(flags&WPO)) file=namebuf;
                 }
                 if(j==PPSRC){
                     file=add_suffix(file,".i");
@@ -592,11 +544,11 @@
                 }
                 /* MUST come before CCSRC-handling! */
                 if(j==SCSRC){
-                    /*if(final) file=cmname;*/
-                    file=add_suffix(file,".asm");
-                    if(tfl==ASSRC&&(flags&OUTPUTSET)) file=destname;
-                    sprintf(command,scname,oldfile,file);
-                    if(tfl!=ASSRC) add_name(file,&first_scratch,&last_scratch);
+                  /*if(final) file=cmname;*/
+                  file=add_suffix(file,".asm");
+                  if(tfl==ASSRC&&(flags&OUTPUTSET)) file=destname;
+                  sprintf(command,scname,oldfile,file);
+                  if(tfl!=ASSRC) add_name(file,&first_scratch,&last_scratch);
                 }
                 if(j==CCSRC){
                     if(file!=cmoutput){
@@ -645,13 +597,7 @@
                         break;
                       }
                     }
-                    if(flags&CROSSMODULE){
-#ifdef USECMDFILE
-                      fclose(cmdfile);
-                      cmdfile=0;
-#endif
-                      final=1;
-                    }
+                    if(flags&CROSSMODULE) final=1;
                     if((flags&(CROSSMODULE|SCHEDULER))==CROSSMODULE) j++;
                     sprintf(command,ccname,oldfile,file,options,opt);
                     if(flags&WPO){
@@ -670,19 +616,7 @@
                     if((tfl)!=OBJ) add_name(file,&first_scratch,&last_scratch);
                 }
                 if(flags&VERBOSE) printf("%s\n",command);
-#ifdef AMIGA
-#if !defined(__amigaos4__) && !defined(__MORPHOS__)
-                if(DOSBase->dl_lib.lib_Version>=36){
-#else
-                if(1){
-#endif
-                    if(SystemTags(command,NP_Priority,-2,TAG_DONE)){
-                        printf("%s failed\n",command);
-                        raus(EXIT_FAILURE);
-                    }
-                }else
-#endif
-                if(runcmd(command)){printf("%s failed\n",command);raus(EXIT_FAILURE);}
+                if(system(command)){printf("%s failed\n",command);raus(EXIT_FAILURE);}
             }
 #ifdef AMIGA
         }while(pm&&!MatchNext(ap));
@@ -699,9 +633,6 @@
         objects=malloc(linklen);
         if(!objects){printf(nomem);raus(EXIT_FAILURE);}
         linklen+=strlen(ldname)+strlen(destname)+strlen(userlibs)+10;
-#ifdef ATARI
-        if(vbccenv) linklen+=strlen(vbccenv)+5;
-#endif
         if(flags&VERYVERBOSE) printf("linklen=%d\n",linklen);
         if(!(linkcmd=malloc(linklen))){printf(nomem);raus(EXIT_FAILURE);}
         p=first_obj;
@@ -729,7 +660,7 @@
             sprintf(linkcmd,ldname,objects,userlibs,destname);
             if(flags&VERBOSE) printf("%s\n",linkcmd);
             /*  hier wird objfile bei Fehler nicht geloescht    */
-            if(runcmd(linkcmd)){printf("%s failed\n",linkcmd);raus(EXIT_FAILURE);}
+            if(system(linkcmd)){printf("%s failed\n",linkcmd);raus(EXIT_FAILURE);}
 #ifdef AMIGA
             if(flags&VERBOSE){
                 BPTR l;
@@ -744,4 +675,5 @@
     }
     if(!(flags&KEEPSCRATCH)) del_scratch(first_scratch);
     raus(0);
+	return;
 }
diff -Naur vbcc/ic.c /usr/glenda/advbcc/Advent-master/vbcc/ic.c
--- vbcc/ic.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/ic.c	Tue Sep 22 04:24:00 2015
@@ -1,5 +1,6 @@
 /*  $VER: vbcc (ic.c) V0.8  */
 
+#include <assert.h>
 #include "vbc.h"
 #include "opt.h"
 
@@ -7,74 +8,39 @@
 
 static struct IC *first_pushed;
 static unsigned int opushed;
+
 static int volatile_convert;
 
 int do_arith(np,struct IC *,np,struct obj *);
-np gen_libcall(char *fname,np arg1,struct Typ *t1,np arg2,struct Typ *t2);
 
 static void handle_reglist(struct regargs_list *,struct obj *);
 
-#if HAVE_LIBCALLS
-/* avoid calling use_libcall with illegal operands */
-static char *use_libcall_wrap(int c,int t,int t2)
-{
-  if(optflags&2)
-    return 0;
-
-  if(c==PMULT) c=MULT;
-  if((c>=OR&&c<=XOR)||(c>=LSHIFT&&c<=KOMPLEMENT)||c==COMPARE||c==CONVERT||c==MINUS||c==TEST)
-    return use_libcall(c,t,t2);
-  return 0;
-}
-#endif
-
 void gen_test(struct obj *o,int t,int branch,int label)
 /*  Generiert ein test o, branch label und passt auf, dass      */
 /*  kein TEST const generiert wird.                             */
 {
-  struct IC *new;
-  if(o->flags&KONST){
-    eval_const(&o->val,t);
-    if(zldeqto(vldouble,d2zld(0.0))&&zmeqto(vmax,l2zm(0L))&&zumeqto(vumax,ul2zum(0UL))){
-      if(branch==BEQ) branch=BRA; else branch=0;
+    struct IC *new;
+    if(o->flags&KONST){
+        eval_const(&o->val,t);
+        if(zldeqto(vldouble,d2zld(0.0))&&zmeqto(vmax,l2zm(0L))&&zumeqto(vumax,ul2zum(0UL))){
+            if(branch==BEQ) branch=BRA; else branch=0;
+        }else{
+            if(branch==BNE) branch=BRA; else branch=0;
+        }
     }else{
-      if(branch==BNE) branch=BRA; else branch=0;
+        new=new_IC();
+        new->code=TEST;
+        new->q2.flags=new->z.flags=0;
+        new->typf=t;
+        new->q1=*o;
+        add_IC(new);
     }
-  }else{
-#if HAVE_LIBCALLS
-    static struct node n={TEST},nn={REINTERPRET};
-    static struct Typ nt,it={INT};
-    char *libname;
-    n.left=&nn;
-    n.ntyp=&it;
-    nn.ntyp=&nt;
-    nt.flags=t;
-    n.o=nn.o=*o;
-    if(libname=use_libcall_wrap(TEST,t,0)){
-      new=new_IC();
-      new->code=TEST;
-      new->q2.flags=new->z.flags=0;
-      new->typf=INT;
-      new->q1=gen_libcall(libname,&nn,&nt,0,0)->o;
-      add_IC(new);
-    }else{
-#endif
-      new=new_IC();
-      new->code=TEST;
-      new->q2.flags=new->z.flags=0;
-      new->typf=t;
-      new->q1=*o;
-      add_IC(new);
-#if HAVE_LIBCALLS
+    if(branch){
+        new=new_IC();
+        new->code=branch;
+        new->typf=label;
+        add_IC(new);
     }
-#endif
-  }
-  if(branch){
-    new=new_IC();
-    new->code=branch;
-    new->typf=label;
-    add_IC(new);
-  }
 }
 
 /* remove a freereg if a scratch register is needed more than once */
@@ -276,8 +242,7 @@
     if(code==ALLOCREG||code==FREEREG||code==SAVEREGS||code==RESTOREREGS) new->typf=0;
     if(DEBUG&64){ pric(stdout,first_ic);printf("new\n");pric2(stdout,new);printf("-\n");}
     if(new->q1.flags&VAR){
-        if(!new->q1.v) 
-	  ierror(0);
+        if(!new->q1.v) ierror(0);
         new->q1.v->flags|=USEDASSOURCE;
         if(code==ADDRESS||(new->q1.flags&VARADR))
 	  if(!is_vlength(new->q1.v->vtyp))
@@ -475,10 +440,10 @@
 {
   np new; 
   struct argument_list *al=0,*t;
-  new=new_node();
+  new=mymalloc(NODES);
   new->flags=CALL;
   new->right=0;
-  new->left=new_node();
+  new->left=mymalloc(NODES);
   new->left->flags=IDENTIFIER;
   new->left->left=new->left->right=0;
   new->left->identifier=add_identifier(fname,strlen(fname));
@@ -491,7 +456,7 @@
     al->arg=arg1;
     al->next=0;
     if(t1){
-      np cnv=new_node();
+      np cnv=mymalloc(NODES);
       cnv->flags=CAST;
       cnv->left=arg1;
       cnv->right=0;
@@ -505,7 +470,7 @@
     t->next=0;
     al->next=t;
     if(t2){
-      np cnv=new_node();
+      np cnv=mymalloc(NODES);
       cnv->flags=CAST;
       cnv->left=arg2;
       cnv->right=0;
@@ -524,6 +489,194 @@
   return new;
 }
 
+/* This function serves a dual purpose: it turns the const_list into a nice
+ * C string, but it also checks to see if it's null-terminated, and if
+ * it's not, we simply return NULL. Our caller is responsible for doing the
+ * right thing in that case. */
+static char *const_list_to_string(struct const_list *cl)
+{
+    int len = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++len) {
+	int ch = cx->other->val.vchar;
+	switch (ch) {
+	    case '\0': if (cx->next != NULL) return NULL; break;
+	    case '\t': case '\n': /* okay */ break;
+	    default:
+		if (cx->next == NULL) return NULL;  /* not null-terminated */
+		break;
+	}
+    }
+    /* Okay, the string is a valid, printable string. */
+    char *text = mymalloc(len);
+    int i = 0;
+    for (struct const_list *cx = cl; cx != NULL; cx = cx->next, ++i) {
+	text[i] = cx->other->val.vchar;
+    }
+    return text;
+}
+
+static struct const_list *string_to_const_list(const char *text)
+{
+    struct const_list *cl = NULL;
+    struct const_list **pp = &cl;
+    for (int i=0; /*true*/; ++i) {
+	*pp = mymalloc(CLS);
+	(*pp)->tree = NULL;
+	(*pp)->idx = i;
+	(*pp)->val.vmax = 0;
+	(*pp)->other = mymalloc(CLS);
+	(*pp)->other->next = (*pp)->other->other = NULL;
+	(*pp)->other->tree = NULL;
+	(*pp)->other->idx = 0;
+	(*pp)->other->val.vchar = text[i];
+	pp = &(*pp)->next;
+	*pp = NULL;
+	if (text[i] == '\0')
+	    break;
+    }
+    return cl;
+}
+
+static void emit_print_num(np p, struct argument_list *arg)
+{
+    assert(strcmp(p->left->left->o.v->identifier, "printf") == 0);
+    
+    static struct Var *internal_print_num = NULL;
+    static struct Typ *voidfunc_ptr_typ = NULL;
+    if (internal_print_num == NULL) {
+	struct Typ voidt = {VOID};
+	struct Typ *voidfunctyp = new_typ();
+	voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+	voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+	voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+	voidfunctyp->flags = FUNKT;
+	internal_print_num = add_var("XXinternal_print_num", voidfunctyp, EXTERN, NULL);
+	internal_print_num->fi = new_fi();
+	internal_print_num->fi->inline_asm = malloc(sizeof("\t@print_num r0;\n"));
+	strcpy(internal_print_num->fi->inline_asm, "\t@print_num r0;\n");
+	
+	voidfunc_ptr_typ = new_typ();
+	voidfunc_ptr_typ->next = clone_typ(voidfunctyp);
+	voidfunc_ptr_typ->flags = POINTER_TYPE(voidfunc_ptr_typ->next);
+    }
+    
+    struct argument_list *saved_alist = p->alist;
+    struct Var *saved_ov = p->left->left->o.v;
+    struct Typ *saved_ntyp = p->left->ntyp;
+    p->alist = arg;
+    assert(arg->next == NULL);
+    p->left->left->o.v = internal_print_num;
+    p->left->ntyp = voidfunc_ptr_typ;
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+
+    p->left->left->o.v = saved_ov;
+    p->left->ntyp = saved_ntyp;
+    p->alist = saved_alist;
+}
+
+/* Emit a call to printf() with the given arguments. We expect that parameter "p"
+ * will point to an existing printf call, so all we need to do is swap out the
+ * arguments. */
+static void emit_printf(np p, const char *fmt, struct argument_list *other_args)
+{
+    struct argument_list *al = p->alist;
+    assert(al->arg->flags == ADDRESSA);
+    assert(al->arg->left->flags == STRING);
+    struct const_list *saved_cl = al->arg->left->cl;
+    struct const_list *cl = string_to_const_list(fmt);
+    al->arg->left->cl = cl;
+    /* Shrink the declared size of the string literal's char-array type. */
+    int saved_size = al->arg->left->ntyp->size;
+    int length = 0;
+    for (struct const_list *sx = cl; sx; sx = sx->next)
+	++length;
+    assert(length >= 1);
+    al->arg->left->ntyp->size = length;
+    
+    struct argument_list *saved_alist = p->alist;
+    struct argument_list *new_alist = mymalloc(sizeof(struct argument_list));
+    new_alist->arg = al->arg;
+    new_alist->next = other_args;
+    p->alist = new_alist;
+
+    assert(strcmp(p->left->left->o.v->identifier, "printf") == 0);
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+
+    p->alist = saved_alist;
+    al->arg->left->cl = saved_cl;
+    al->arg->left->ntyp->size = saved_size;
+    free(new_alist);
+}
+
+static void emit_puts(np p, const char *text)
+{
+    extern const char *z_optimize_puts_name;
+    assert(*text != '\0');
+    int cap = strlen(z_optimize_puts_name) + strlen(text) + 16;
+    char *inline_asm = mymalloc(cap);
+
+    sprintf(inline_asm, "\t%s(\"", z_optimize_puts_name);
+    int len = strlen(inline_asm);
+    for (int i=0; text[i] != '\0'; ++i) {
+	cap += strlen(z_optimize_puts_name) + 32;
+        inline_asm = myrealloc(inline_asm, cap);
+	if ((text[i] & 0x80) != 0) {
+	    unsigned int w = text[i] & 0xFF;
+	    if (0xC2 <= w && w <= 0xDF) {
+		w &= 0x1F;
+		w = (w << 6) | text[++i] & 0x3F;
+	    } else if (0xE0 <= w && w <= 0xEF) {
+		w &= 0x0F;
+		w = (w << 6) | text[++i] & 0x3F;
+		w = (w << 6) | text[++i] & 0x3F;
+	    } else {
+		ierror(0);  /* unsupported or invalid UTF-8 encoding */
+	    }
+            strcpy(inline_asm+len, "\");\n"); len += 3;
+	    sprintf(inline_asm+len, "\t@print_unicode $%04X;\n"
+		                    "\t%s(\"", w, z_optimize_puts_name);
+	    len = strlen(inline_asm);
+	} else {
+	    switch (text[i]) {
+		case '\n': inline_asm[len++] = '^'; break;
+		case '\t': strcpy(inline_asm+len, "@{9}"); len += 4; break;
+		case '"': inline_asm[len++] = '~'; break;
+		case '@': strcpy(inline_asm+len, "@{40}"); len += 5; break;
+		case '\\': strcpy(inline_asm+len, "@{5c}"); len += 5; break;
+		case '~': strcpy(inline_asm+len, "@{7e}"); len += 5; break;
+		case '^': strcpy(inline_asm+len, "@@94\",\""); len += 7; break;
+		default:
+		    /* This should have been assured by const_list_to_string(). */
+		    assert(32 <= text[i] && text[i] <= 126);
+		    inline_asm[len++] = text[i];
+		    break;
+	    }
+	}
+    }
+    strcpy(inline_asm+len, "\");\n"); len += 3;
+
+    char pfname[50];
+    static int counter = 0;
+    struct Typ voidt = {VOID};
+    struct Typ *voidfunctyp = new_typ();
+    sprintf(pfname, "XXinternal_pf_%07x_puts", ++counter);
+    voidfunctyp->next = clone_typ(&voidt);  /* returning void */
+    voidfunctyp->exact = mymalloc(sizeof *voidfunctyp->exact);
+    voidfunctyp->exact->count = 0;  /* taking unspecified arguments */
+    voidfunctyp->flags = FUNKT;
+    struct Var *pseudofunc = add_var(pfname, voidfunctyp, EXTERN, NULL);
+    pseudofunc->fi = new_fi();
+    pseudofunc->fi->inline_asm = inline_asm;
+
+    struct Var *saved_v = p->left->left->o.v;
+    struct argument_list *saved_alist = p->alist;
+    p->left->left->o.v = pseudofunc;
+    p->alist = NULL;
+    gen_IC(p, /*ltrue=*/0, /*lfalse=*/0);
+    p->left->left->o.v = saved_v;
+    p->alist = saved_alist;
+}
+
 
 void gen_IC(np p,int ltrue,int lfalse)
 /*  Erzeugt eine IC-Liste aus einer expression      */
@@ -589,31 +742,23 @@
         p->o=p->right->o;
         return;
     }
-    if(p->flags==REINTERPRET){
-      if(p->left){
-	gen_IC(p->left,0,0);
-	p->o=p->left->o;
-      }
-      /* if no left, do nothing, use just object */
-      return;
-    }
     if(p->flags==CAST){
-      gen_IC(p->left,0,0);
-      if((p->ntyp->flags&NQ)==VOID){
-	if((p->left->o.flags&(SCRATCH|REG))==(SCRATCH|REG)) free_reg(p->left->o.reg);
-	p->o.flags=0;
-      }else{
-	if(ISPOINTER(p->ntyp->flags)&&(p->ntyp->next->flags&VOLATILE))
-	  volatile_convert=1;
-	convert(p->left,p->ntyp->flags);
-	if(volatile_convert){
-	  if((p->left->o.flags&VAR)&&p->left->o.v->vtyp->next)
-	    p->left->o.v->vtyp->next->flags|=VOLATILE;
-	  volatile_convert=0;
-	}
-	p->o=p->left->o;
-      }
-      return;
+        gen_IC(p->left,0,0);
+        if((p->ntyp->flags&NQ)==VOID){
+            if((p->left->o.flags&(SCRATCH|REG))==(SCRATCH|REG)) free_reg(p->left->o.reg);
+            p->o.flags=0;
+        }else{
+	  if(ISPOINTER(p->ntyp->flags)&&(p->ntyp->next->flags&VOLATILE))
+	    volatile_convert=1;
+	  convert(p->left,p->ntyp->flags);
+	  if(volatile_convert){
+	    if((p->left->o.flags&VAR)&&p->left->o.v->vtyp->next)
+	      p->left->o.v->vtyp->next->flags|=VOLATILE;
+	    volatile_convert=0;
+	  }
+	  p->o=p->left->o;
+        }
+        return;
     }
     if(p->flags==FIRSTELEMENT){
         gen_IC(p->left,0,0);
@@ -621,28 +766,27 @@
         return;
     }
 #if HAVE_LIBCALLS
-    if(!(optflags&2)){
-      char *libname;
-      if(libname=use_libcall_wrap(p->flags,p->ntyp->flags,0)){
-	np lc;struct Typ *t1,*t2;
-	if(p->flags==LSHIFT||p->flags==RSHIFT){
-	  t1=clone_typ(p->ntyp);
-	  t2=new_typ();
-	  t2->flags=INT;
+    { char *libname;
+    if(libname=use_libcall(p)){
+      np lc;struct Typ *t1,*t2;
+      if(p->flags==LSHIFT||p->flags==RSHIFT){
+	t1=clone_typ(p->ntyp);
+	t2=new_typ();
+	t2->flags=INT;
+      }else{
+	if(p->right){
+	  t1=arith_typ(p->left->ntyp,p->right->ntyp);
+	  t2=clone_typ(t1);
 	}else{
-	  if(p->right){
-	    t1=arith_typ(p->left->ntyp,p->right->ntyp);
-	    t2=clone_typ(t1);
-	  }else{
-	    t1=arith_typ(p->left->ntyp,p->left->ntyp);
-	    t2=0;
-	  }
+	  t1=arith_typ(p->left->ntyp,p->left->ntyp);
+	  t2=0;
 	}
-	lc=gen_libcall(libname,p->left,t1,p->right,t2);
-	*p=*lc;
-	free(lc);
-	return;
       }
+      lc=gen_libcall(libname,p->left,t1,p->right,t2);
+      *p=*lc;
+      free(lc);
+      return;
+    }
     }
 #endif
     new=new_IC();
@@ -699,8 +843,6 @@
       new->z=p->left->o;
       new->q2.val.vmax=szof(p->left->ntyp);
       p->o=new->z;
-      if(!ISSCALAR(p->ntyp->flags))
-	new->typf2=zm2l(falign(p->ntyp));
       add_IC(new);
       return;
     }
@@ -715,25 +857,17 @@
 	return;
       }
 #if HAVE_LIBCALLS
-      if(libname=use_libcall_wrap(p->right->flags,p->right->ntyp->flags,(p->right->flags==LSHIFT||p->right->flags==LSHIFT)?INT:0)){
+      if(libname=use_libcall(p->right)){
 	struct Typ *t1,*t2;
-	np a1;
-	gen_IC(p->left,0,0);
-	a1=new_node();
-	a1->o=p->left->o;
-	a1->flags=REINTERPRET;
-	a1->o.flags&=~SCRATCH;
-	a1->ntyp=clone_typ(p->left->ntyp);
-	t1=clone_typ(p->right->ntyp);
+	t1=clone_typ(p->ntyp);
 	if(p->right->flags==LSHIFT||p->right->flags==RSHIFT){
 	  t2=new_typ();
 	  t2->flags=INT;
 	}else
-	  t2=clone_typ(t1);
-	lc=gen_libcall(libname,a1/*p->right->left*/,t1,p->right->right,t2);
+	  t2=clone_typ(p->ntyp);
+	lc=gen_libcall(libname,p->right->left,t1,p->right->right,t2);
 	/**p->right=*lc;*/
 	o=p->left->o;
-	free(a1);
 	/*p->left=0;*/
 	/*free(lc);*/
       }else
@@ -823,12 +957,6 @@
     if(p->flags==LAND||p->flags==LOR){
         int l1,l2,l3,l4;
 /*        printf("%s true=%d false=%d\n",ename[p->flags],ltrue,lfalse);*/
-
-	if(ISVECTOR(p->ntyp->flags)){
-	  do_arith(p,new,0,0);
-	  return;
-	}
-
         l1=++label;
 	if(!ltrue) {l2=++label;l3=++label;l4=++label;}
         if(!ltrue){
@@ -876,21 +1004,6 @@
     }
     if(p->flags==NEGATION){
         int l1,l2,l3;
-	if(ISVECTOR(p->ntyp->flags)){
-	  gen_IC(p->left,0,0);
-	  if((p->left->o.flags&(SCRATCH|REG))==(SCRATCH|REG)&&regok(p->left->o.reg,p->ntyp->flags,0)){
-	    new->z=p->left->o;
-	    new->z.flags&=~DREFOBJ;
-	  }else{
-	    get_scratch(&new->z,p->left->ntyp->flags,0,p->left->ntyp);
-	  }
-	  new->typf=p->left->ntyp->flags;
-	  new->q1=p->left->o;
-	  p->o=new->z;
-	  new->code=NEGATION;
-	  add_IC(new);
-	  return;
-	}
         if(!ltrue) {l1=++label;l2=++label;l3=++label;}
         if(ltrue)
 	  gen_IC(p->left,lfalse,ltrue);
@@ -914,49 +1027,35 @@
         return;
     }
     if(p->flags>=EQUAL&&p->flags<=GREATEREQ){
-      int l1,l2,l3,tl,tr;
-      struct Typ *at=0;
-      char *libname;
-      if(ISVECTOR(p->ntyp->flags)){
-	do_arith(p,new,0,0);
-	return;
-      }
-      if(!ltrue) {l1=++label;l2=++label;l3=++label;}
-      if(p->left->flags==CEXPR){
+        int l1,l2,l3,tl,tr;
+        if(!ltrue) {l1=++label;l2=++label;l3=++label;}
+        if(p->left->flags==CEXPR){
         /*  Konstanten nach rechts  */
-	np merk;merk=p->left;p->left=p->right;p->right=merk;
-	if(p->flags==LESS) p->flags=GREATER;
-	else if(p->flags==LESSEQ) p->flags=GREATEREQ;
-	else if(p->flags==GREATER) p->flags=LESS;
-	else if(p->flags==GREATEREQ) p->flags=LESSEQ;
-      }
-#if HAVE_LIBCALLS
-      at=arith_typ(p->left->ntyp,p->right->ntyp);
-      if(libname=use_libcall_wrap(COMPARE,at->flags,0)){
-	new->q1=gen_libcall(libname,p->left,at,p->right,clone_typ(at))->o;
-	new->code=TEST;
-	new->typf=INT;
-      }else{
-#endif
+            np merk;merk=p->left;p->left=p->right;p->right=merk;
+            if(p->flags==LESS) p->flags=GREATER;
+            else if(p->flags==LESSEQ) p->flags=GREATEREQ;
+            else if(p->flags==GREATER) p->flags=LESS;
+            else if(p->flags==GREATEREQ) p->flags=LESSEQ;
+        }
         new->code=COMPARE;
         tl=p->left->ntyp->flags&NU;tr=p->right->ntyp->flags&NU;
         if(p->right->flags==CEXPR&&ISINT(tr)&&ISINT(tl)){
-	  int negativ;
-	  eval_constn(p->right);
-	  if(zmleq(vmax,l2zm(0L))) negativ=1; else negativ=0;
-	  if((tl&UNSIGNED)||(tr&UNSIGNED)) negativ=0;
-	  if((!negativ||zmleq(t_min(tl),vmax))&&(negativ||zumleq(vumax,t_max(tl)))){
-	    convert(p->right,tl);
-	    tr=tl;
-	  }
+            int negativ;
+            eval_constn(p->right);
+            if(zmleq(vmax,l2zm(0L))) negativ=1; else negativ=0;
+            if((tl&UNSIGNED)||(tr&UNSIGNED)) negativ=0;
+            if((!negativ||zmleq(t_min(tl),vmax))&&(negativ||zumleq(vumax,t_max(tl)))){
+                convert(p->right,tl);
+                tr=tl;
+            }
         }
         if(ISARITH(tl)&&(tl!=tr||!shortcut(COMPARE,tl))){
-	  struct Typ *t;
-	  t=arith_typ(p->left->ntyp,p->right->ntyp);
-	  new->typf=t->flags;
-	  freetyp(t);
+            struct Typ *t;
+            t=arith_typ(p->left->ntyp,p->right->ntyp);
+            new->typf=t->flags;
+            freetyp(t);
         }else{
-	  new->typf=p->left->ntyp->flags;
+            new->typf=p->left->ntyp->flags;
         }
         gen_IC(p->left,0,0);
         convert(p->left,new->typf);
@@ -975,42 +1074,159 @@
 	    }
 	  }
 	}
-#if HAVE_LIBCALLS
-      }
-#endif
-      freetyp(at);
-      add_IC(new);
-      new=new_IC();
-      if(p->flags==EQUAL) new->code=BEQ;
-      if(p->flags==INEQUAL) new->code=BNE;
-      if(p->flags==LESS) new->code=BLT;
-      if(p->flags==LESSEQ) new->code=BLE;
-      if(p->flags==GREATER) new->code=BGT;
-      if(p->flags==GREATEREQ) new->code=BGE;
-      if(ltrue) new->typf=ltrue; else new->typf=l1;
-      add_IC(new);
-      if(ltrue){
-	new=new_IC();
-	new->code=BRA;
-	new->typf=lfalse;
-	add_IC(new);
-	p->o.flags=0;
-      }else{
-	gen_label(l3);
-	gen_cond(&p->o,1,l1,l2);
-      }
-      return;
+        add_IC(new);
+        new=new_IC();
+        if(p->flags==EQUAL) new->code=BEQ;
+        if(p->flags==INEQUAL) new->code=BNE;
+        if(p->flags==LESS) new->code=BLT;
+        if(p->flags==LESSEQ) new->code=BLE;
+        if(p->flags==GREATER) new->code=BGT;
+        if(p->flags==GREATEREQ) new->code=BGE;
+        if(ltrue) new->typf=ltrue; else new->typf=l1;
+        add_IC(new);
+        if(ltrue){
+            new=new_IC();
+            new->code=BRA;
+            new->typf=lfalse;
+            add_IC(new);
+            p->o.flags=0;
+        }else{
+            gen_label(l3);
+            gen_cond(&p->o,1,l1,l2);
+        }
+        return;
     }
     if(p->flags==CALL){
-        int r=0,radrpush=0;
-	struct obj *op,cfunc,ret_obj;
-	zmax sz;
+        int r=0;struct obj *op,cfunc,ret_obj;zmax sz;
         int mregs[MAXR+1];
 	struct IC *callic;
 #ifdef ORDERED_PUSH
         struct IC *merk_fp,*lp;
 	unsigned int merk_opushed=opushed;
 #endif
+	/* [ajo] The following code optimizes puts("hello") into a single
+	 * Z-machine opcode: print "hello". This cuts down a little bit on
+	 * code size, but greatly on static data size, because (as far as I
+	 * know) the Z-machine stores text strings differently from regular
+	 * static data. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "puts")) {
+            /* Generating IC for puts() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING &&
+		al->next == NULL) {
+                /* Generating IC for puts() of a string literal */
+                char *text = const_list_to_string(al->arg->left->cl);
+		if (text != NULL) {
+		    text = myrealloc(text, strlen(text)+2);
+		    strcat(text, "\n");
+		    emit_puts(p, text);
+		    free(text);
+		    return;
+		}
+            }
+        }
+
+	/* [ajo] The following code optimizes printf("prefix%ssuffix\n", arg)
+	 * into printf("prefix%s", arg); puts("suffix");
+	 * Again, this is very useful on the Z-machine. */
+        if (ltrue == 0 && lfalse == 0 &&
+	    p->left->flags==ADDRESS &&
+            p->left->left->flags==IDENTIFIER &&
+            p->left->left->o.v->storage_class==EXTERN &&
+            !strcmp(p->left->left->o.v->identifier, "printf")) {
+            /* Generating IC for printf() of something */
+            struct argument_list *al = p->alist;
+            if (al != NULL && al->arg != NULL && al->arg->flags == ADDRESSA &&
+                al->arg->left != NULL && al->arg->left->flags == STRING) {
+                /* Generating IC for printf("literal", ...) */
+		char *fmt = const_list_to_string(al->arg->left->cl);
+		if (fmt == NULL) {
+		    /* The format string contains some unprintable characters.
+		     * Fall back on the standard library's printf()
+		     * implementation. */
+		} else if (strcmp(fmt, "%s") == 0) {
+		    /* This should compile to fputs(), but for now let's allow
+		     * it also to fall back on the default printf(). */
+		} else if (fmt[0] == '%' && fmt[1] != 'd' && fmt[1] != 's') {
+		    /* The format string *begins* with an unrecognized
+		     * format specifier. We can't optimize this one. */
+		} else {
+		    int start = 0;
+		    int end;
+		    struct argument_list *current_argument = al->next;
+		    for (end = 0; fmt[end] != '\0'; ) {
+			if (fmt[end] != '%') {
+			    ++end;
+			    continue;
+			}
+			/* We've hit a format specifier. */
+			if (start != end) {
+			    /* There's some plaintext to print before we
+			     * get to this format specifier. */
+			    fmt[end] = '\0';
+			    emit_puts(p, fmt+start);
+			    fmt[end] = '%';
+			    start = end;
+			}
+			assert(start == end);
+			assert(fmt[start] == '%');
+			if (fmt[start+1] == 'd') {
+			    struct argument_list *saved_al = current_argument->next;
+			    current_argument->next = NULL;
+			    emit_print_num(p, current_argument);
+			    current_argument->next = saved_al;
+			    /* Advance to the next unconsumed argument. */
+			    current_argument = current_argument->next;
+			    start = end = start+2;
+			} else if (fmt[start+1] == 's') {
+			    struct argument_list *saved_al = current_argument->next;
+			    current_argument->next = NULL;
+			    /* Recurse to handle this one. */
+			    emit_printf(p, "%s", current_argument);
+			    current_argument->next = saved_al;
+			    /* Advance to the next unconsumed argument. */
+			    current_argument = current_argument->next;
+			    start = end = start+2;
+			} else if (fmt[start+1] == '%') {
+			    emit_puts(p, "%");
+			    start = end = start+2;
+			} else {
+			    /* This format specifier is unrecognized. It might
+			     * for example be "%x" or "%02.5d". We must be
+			     * conservative and fall back on the standard
+			     * library's printf() for the entire rest of the
+			     * format string. */
+			    emit_printf(p, fmt+start, current_argument);
+			    free(fmt);
+			    return;
+			}
+		    }
+		    if (start != end) {
+			/* There's plaintext at the end of the format string. */
+			emit_puts(p, fmt+start);
+		    }
+		    /* If we've reached here, we're done emitting the
+		     * optimized code, and we can stop. But we do need
+		     * to make sure we've evaluated all the arguments,
+		     * even if the user wrote something like
+		     *     printf("hello world\n", ++foo);
+		     * where the arguments go unused. */
+		    while (current_argument != NULL) {
+			gen_IC(current_argument->arg, /*ltrue=*/0, /*lfalse=*/0);
+			current_argument = current_argument->next;
+		    }
+		    free(fmt);
+		    return;
+		}
+		free(fmt);
+	    }
+        }
+
         if(p->left->flags==ADDRESS&&p->left->left->flags==IDENTIFIER){
             struct Var *v;
             gen_IC(p->left,0,0); r=1;
@@ -1056,7 +1272,6 @@
                     new->z.val.vmax=l2zm(0L);
                     new->z.v=argl2[i];
                     new->typf=vp->vtyp->flags;
-		    new->typf2=falign(vp->vtyp);
                     add_IC(new);
                     i++;
                     al=al->next;
@@ -1226,31 +1441,25 @@
           struct IC *new2;static struct Typ ptyp={0};
 	  struct reg_handle reg_handle=empty_reg_handle;
 	  int reg;
+          new2=new_IC();
+          new2->code=ADDRESS;
+          new2->typf=p->ntyp->flags;
+	  new2->typf2=POINTER_TYPE(p->ntyp);
+          new2->q1.flags=VAR;
+          new2->q1.v=add_var(empty,clone_typ(p->ntyp),AUTO,0);
+          new2->q1.val.vmax=l2zm(0L);
+          op=&new2->q1;
+          new2->q2.flags=0;
+          get_scratch(&new2->z,POINTER_TYPE(p->ntyp),p->ntyp->flags,0);
+          ret_obj=new2->z;
+          add_IC(new2);
 	  ptyp.next=p->ntyp;
 	  ptyp.flags=POINTER_TYPE(p->ntyp);
 	  reg=reg_parm(&reg_handle,&ptyp,0,p->left->ntyp);
-	  if(reg){
-	    new2=new_IC();
-	    new2->code=ADDRESS;
-	    new2->typf=p->ntyp->flags;
-	    new2->typf2=POINTER_TYPE(p->ntyp);
-	    new2->q1.flags=VAR;
-	    new2->q1.v=add_var(empty,clone_typ(p->ntyp),AUTO,0);
-	    new2->q1.val.vmax=l2zm(0L);
-	    op=&new2->q1;
-	    new2->q2.flags=0;
-	    get_scratch(&new2->z,POINTER_TYPE(p->ntyp),p->ntyp->flags,0);
-	    ret_obj=new2->z;
-	    add_IC(new2);
-	    sz=push_args(p->alist,p->left->ntyp->next->exact,0,&rl,&reg_handle,&ret_obj,p->ntyp,reg,p->left->ntyp);
-	    if(optflags&2)
-	      handle_reglist(rl,&ret_obj);
-	  }else{
-	    sz=push_args(p->alist,p->left->ntyp->next->exact,0,&rl,&reg_handle,0,p->ntyp,reg,p->left->ntyp);
-	    radrpush=1;
-	    if(optflags&2)
-	      handle_reglist(rl,0);
-	  }
+	  if(!reg) ierror(0);
+	  sz=push_args(p->alist,p->left->ntyp->next->exact,0,&rl,&reg_handle,&ret_obj,p->ntyp,reg,p->left->ntyp);
+	  if(optflags&2)
+	    handle_reglist(rl,&ret_obj);
 	}else{
 	  struct reg_handle reg_handle=empty_reg_handle;
 	  sz=push_args(p->alist,p->left->ntyp->next->exact,0,&rl,&reg_handle,0,0,-1,p->left->ntyp);
@@ -1314,38 +1523,35 @@
         }
 #endif
 
+#ifndef HAVE_REGPARMS
         /*  gegebenenfalls Adresse des Ziels auf den Stack  */
-#ifdef HAVE_REGPARMS
-	if(radrpush)
-#else
-        if(!ffreturn(p->ntyp)&&(p->ntyp->flags&NQ)!=VOID)
-#endif
-	{
-#if defined(ORDERED_PUSH) && defined(HAVE_REGPARMS)
-	  ierror(0);
+        if(!ffreturn(p->ntyp)&&(p->ntyp->flags&NQ)!=VOID){
+#ifdef ORDERED_PUSH
+            ierror(0);
 #endif
-	  new=new_IC();
-	  new->code=ADDRESS;
-	  new->typf=p->ntyp->flags;
-	  new->typf2=POINTER_TYPE(p->ntyp);
-	  new->q1.flags=VAR;
-	  new->q1.v=add_var(empty,clone_typ(p->ntyp),AUTO,0);
-	  new->q1.val.vmax=l2zm(0L);
-	  op=&new->q1;
-	  new->q2.flags=0;
-	  get_scratch(&new->z,POINTER_TYPE(p->ntyp),p->ntyp->flags,0);
-	  ret_obj=new->z;
-	  add_IC(new);
-	  new=new_IC();
-	  new->code=PUSH;
-	  new->typf=POINTER_TYPE(p->ntyp);
-	  new->q1=ret_obj;
-	  new->q2.flags=new->z.flags=0;
-	  new->q2.val.vmax=sizetab[new->typf&NQ];
-	  new->z.val.vmax=new->q2.val.vmax;
-	  add_IC(new);
-	  sz=zmadd(sz,sizetab[new->typf&NQ]);
+            new=new_IC();
+            new->code=ADDRESS;
+            new->typf=p->ntyp->flags;
+	    new->typf2=POINTER_TYPE(p->ntyp);
+            new->q1.flags=VAR;
+            new->q1.v=add_var(empty,clone_typ(p->ntyp),AUTO,0);
+            new->q1.val.vmax=l2zm(0L);
+            op=&new->q1;
+            new->q2.flags=0;
+            get_scratch(&new->z,POINTER_TYPE(p->ntyp),p->ntyp->flags,0);
+            ret_obj=new->z;
+            add_IC(new);
+            new=new_IC();
+            new->code=PUSH;
+            new->typf=POINTER_TYPE(p->ntyp);
+            new->q1=ret_obj;
+            new->q2.flags=new->z.flags=0;
+            new->q2.val.vmax=sizetab[new->typf&NQ];
+	    new->z.val.vmax=new->q2.val.vmax;
+            add_IC(new);
+            sz=zmadd(sz,sizetab[new->typf&NQ]);
         }
+#endif
 
         /*  Scratchregister evtl. sichern   */
 	cfunc=p->o;
@@ -1499,7 +1705,7 @@
 	      new->next=p->next;
 	      if(p==last_ic) last_ic=new;
 	      if(p==first_ic) first_ic=new;
-              if(new->q1.flags&&!(p->flags&ORDERED_PUSH_COPY)){
+              if(new->q1.flags){
                 new->code=ASSIGN;
                 new->z.flags=VAR;
                 new->z.val.vmax=l2zm(0L);
@@ -1512,7 +1718,6 @@
                 remove_IC(new);
               }
 	      p->next=p->prev=0;
-	      p->flags|=ORDERED_PUSH_COPY;
               add_IC(p);
               if(!m&&!nocode) m=p;
             }
@@ -1558,7 +1763,7 @@
 	gval.vmax=l2zm(1L);
 	eval_const(&gval,MAXINT);
 	insert_const(&one.val,p->ntyp->flags&NU);
-	if(libname=use_libcall_wrap(tn.flags,tn.ntyp->flags,0)){
+	if(libname=use_libcall(&tn)){
 	  np lc;
 	  lc=gen_libcall(libname,p->left,0,&one,0);
 	  new=new_IC();
@@ -2047,6 +2252,7 @@
             return of;
         }
     }
+	return;
 }
 
 void convert(np p,int f)
@@ -2055,12 +2261,8 @@
 {
   struct IC *new;
   int o=p->ntyp->flags;
-  int to,tn,mc,dr;
-  static struct node n,nn;
-  static struct Typ nt;
-  char *libname;
+  int to,tn;
   if((f&NQ)==VOID) return;
-
   if(p->flags==CEXPR||p->flags==PCEXPR){
 #ifdef HAVE_MISRA
 /* removed */
@@ -2090,7 +2292,6 @@
     new->code=COMPARE;
     new->typf=o;
     new->q1=p->o;
-    new->q1.flags&=~SCRATCH;
     new->q2.flags=KONST;
     new->q2.val.vumax=t_max[it];
     eval_const(&new->q2.val,MAXINT|UNSIGNED);
@@ -2106,12 +2307,11 @@
     new->code=SUB;
     new->typf=o;
     new->q1=p->o;
-    new->q1.flags&=~SCRATCH;
     new->q2.flags=KONST;
     new->q2.val=val;
     new->z.flags=VAR;
     get_scratch(&new->z,o,0,0);
-    t=new_node();
+    t=mymalloc(NODES);
     t->ntyp=clone_typ(p->ntyp);
     t->ntyp->flags&=~UNSIGNED;
     t->o=new->z;
@@ -2121,7 +2321,6 @@
     new->code=ADD;
     new->typf=f;
     new->q1=t->o;
-    new->q1.flags&=~SCRATCH;
     freetyp(t->ntyp);
     free(t);
     new->q2.flags=KONST;
@@ -2160,11 +2359,7 @@
     add_IC(new);
     return;
   }
-  if(ISVECTOR(f)&&ISSCALAR(o)){
-    o=VECTYPE(f);
-    convert(p,o);
-  }
-  if(!volatile_convert&&((o&NU)==(f&NU)||(!(mc=must_convert(o,f,const_expr))&&(const_expr||!(optflags&2))))){
+  if(!volatile_convert&&((o&NU)==(f&NU)||(!must_convert(o,f,const_expr)&&(const_expr||!(optflags&2))))){
     p->ntyp->flags=f;
     if(!ISPOINTER(f)&&!ISARRAY(f)){freetyp(p->ntyp->next);p->ntyp->next=0;}
     return;
@@ -2181,41 +2376,19 @@
   }else{
     to=o;
   }
-#if HAVE_LIBCALLS
-  n.flags=CONVERT;
-  n.ntyp=&nt;
-  nt.flags=f;
-  n.left=&nn;
-  nn.ntyp=p->ntyp;
-  if((libname=use_libcall_wrap(CONVERT,tn,to))&&mc){
-    struct node *n=new_node();
-    n->flags=REINTERPRET;
-    n->o=p->o;
-    n->ntyp=p->ntyp;
-    p->o=gen_libcall(libname,n,p->ntyp,0,0)->o;
+  new=new_IC();
+  new->q1=p->o;
+  new->q2.flags=0;
+  new->code=CONVERT;
+  new->typf2=to;
+  new->typf=tn;
+  if((p->o.flags&(SCRATCH|REG))!=(SCRATCH|REG)||!regok(p->o.reg,tn,0)){
+    get_scratch(&new->z,tn,0,0);
   }else{
-#endif
-    new=new_IC();
-    new->q1=p->o;
-    new->q2.flags=0;
-    new->code=CONVERT;
-    new->typf2=to;
-    new->typf=tn;
-    if((p->o.flags&(SCRATCH|REG))!=(SCRATCH|REG)||!regok(p->o.reg,tn,0)){
-      get_scratch(&new->z,tn,0,0);
-    }else{
-      new->z=p->o;new->z.flags&=~DREFOBJ;
-    }
-    p->o=new->z;
-    /* hmm... */
-    if(!mc&&libname){
-      new->code=ASSIGN;
-      new->q2.val.vmax=sizetab[tn&NQ];
-    }
-    add_IC(new);
-#if HAVE_LIBCALLS
+    new->z=p->o;new->z.flags&=~DREFOBJ;
   }
-#endif
+  p->o=new->z;
+  add_IC(new);
   if(f!=tn){
     p->ntyp->flags=tn;
     convert(p,f);
@@ -2333,7 +2506,7 @@
 /*  nicht effizient, aber wer hat schon so wenig Register...    */
 {
   struct Typ *nt;
-  if(!ISSCALAR(t)&&!ISVECTOR(t)){
+  if(!ISSCALAR(t)){
     if(!typ) ierror(0);
     nt=clone_typ(typ);
   }else{
@@ -2456,8 +2629,7 @@
       if(dest) dest->o.flags=mflags;
       return f;
     }
-    if(!ISVECTOR(p->ntyp->flags)||!ISVECTOR(p->left->ntyp->flags))
-      convert(p->left,p->ntyp->flags);
+    convert(p->left,p->ntyp->flags);
     if(p->flags==LSHIFT||p->flags==RSHIFT){
       if(shortcut(p->flags,p->left->ntyp->flags&NU)){
 	convert(p->right,p->right->ntyp->flags);
@@ -2475,17 +2647,11 @@
       new->typf2=st->flags;
       freetyp(st);
 #endif
-    }else{
-      if(!ISVECTOR(p->ntyp->flags)||!ISVECTOR(p->right->ntyp->flags))
-	convert(p->right,p->ntyp->flags);
-    }
+    }else
+      convert(p->right,p->ntyp->flags);
     new->q1=p->left->o;
     new->q2=p->right->o;
-    if(ISVECTOR(p->ntyp->flags)){
-      new->typf=p->left->ntyp->flags;
-      new->typf2=p->ntyp->flags;
-    }else
-      new->typf=p->ntyp->flags;
+    new->typf=p->ntyp->flags;
     /*  Bei dest!=0, d.h. ASSIGNOP, darf q1 nicht als Ziel benuzt werden!  */
     if(!dest&&(new->q1.flags&(SCRATCH|REG))==(SCRATCH|REG)&&regok(new->q1.reg,p->ntyp->flags,0)){
       new->z=new->q1;
diff -Naur vbcc/loop.c /usr/glenda/advbcc/Advent-master/vbcc/loop.c
--- vbcc/loop.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/loop.c	Tue Sep 22 04:18:49 2015
@@ -714,14 +714,8 @@
 		k1=0;
 	      }else{
 		i=p->q1.v->index;
-		if(p->q1.flags&DREFOBJ){
-		  i+=vcount-rcount;
-		  if(p->q1.dtyp&VOLATILE)
-		    k1=0;
-		  else
-		    k1=def_invariant(i,-1);
-		}else
-		  k1=def_invariant(i,-1);
+		if(p->q1.flags&DREFOBJ) i+=vcount-rcount;
+		k1=def_invariant(i,-1);
 	      }
 	    }
 	    if(k1){
@@ -732,18 +726,12 @@
 		  k2=0;
 		}else{
 		  i=p->q2.v->index;
-		  if(p->q2.flags&DREFOBJ){
-		    i+=vcount-rcount;
-		    if(p->q2.dtyp&VOLATILE)
-		      k2=0;
-		    else
-		      k2=def_invariant(i,-1);
-		  }else
-		    k2=def_invariant(i,-1);
+		  if(p->q2.flags&DREFOBJ) i+=vcount-rcount;
+		  k2=def_invariant(i,-1);
 		}
 	      }
 	    }
-	    if(k1&&k2&&!(ztyp(p)&VOLATILE)&&!(q1typ(p)&VOLATILE)){
+	    if(k1&&k2){
 	      if(DEBUG&1024){ printf("found loop-invariant IC:\n");pric2(stdout,p);}
 	      if(!BTST(moved,p->defindex)&&(always_reached(start,end,g,p,0)||(!dangerous_IC(p)&&used_in_loop_only(start,end,&p->z)))){
 		if(p->z.flags&DREFOBJ){
diff -Naur vbcc/machines/arm/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.c
--- vbcc/machines/arm/machine.c	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.c	Tue Sep 22 04:18:49 2015
@@ -0,0 +1,2395 @@
+/*
+ * ARM code generator
+ * A 32-bit RISC with 16 general purpose registers.
+ * Written by Frank Wille <frank@phoenix.owl.de>
+ */
+
+#include "supp.h"
+#include "vbc.h"
+
+static char FILE_[] = __FILE__;
+
+
+/*  Public data that MUST be there.                             */
+
+/* Name and copyright. */
+char cg_copyright[] = "vbcc code-generator for ARM V0.0 (c) in 2006 by Frank Wille";
+
+/* Commandline-flags the code-generator accepts:
+   0: just a flag
+   VALFLAG: a value must be specified
+   STRINGFLAG: a string can be specified
+   FUNCFLAG: a function will be called
+   apart from FUNCFLAG, all other versions can only be specified once */
+int g_flags[MAXGF] = {
+    STRINGFLAG,STRINGFLAG,0,0,0,0,
+    0,0,0,0
+};
+
+/* the flag-name, do not use names beginning with l, L, I, D or U, because
+   they collide with the frontend */
+char *g_flags_name[MAXGF] = {
+    "cpu","fpu","little-endian","big-endian","arm","thumb",
+    "const-in-data","merge-constants","elf","use-commons"
+};
+
+/* the results of parsing the command-line-flags will be stored here */
+union ppi g_flags_val[MAXGF];
+
+/*  Alignment-requirements for all types in bytes.              */
+zmax align[MAX_TYPE+1];
+
+/*  Alignment that is sufficient for every object.              */
+zmax maxalign;
+
+/*  CHAR_BIT for the target machine.                            */
+zmax char_bit;
+
+/*  sizes of the basic types (in bytes) */
+zmax sizetab[MAX_TYPE+1];
+
+/*  Minimum and Maximum values each type can have.              */
+/*  Must be initialized in init_cg().                           */
+zmax t_min[MAX_TYPE+1];
+zumax t_max[MAX_TYPE+1];
+zumax tu_max[MAX_TYPE+1];
+
+/*  Names of all registers. */
+char *regnames[MAXR+1] = {
+    "noreg",
+    "r0","r1","r2","r3","r4","r5","r6","r7",
+    "r8","r9","r10","r11","r12","sp","lr","pc",
+    "s0","s1","s2","s3","s4","s5","s6","s7",
+    "s8","s9","s10","s11","s12","s13","s14","s15",
+    "cpsr",
+    "r0/r1","r2/r3","r4/r5","r6/r7","r10/r11",
+    "d0","d1","d2","d3","d4","d5","d6","d7"
+};
+
+/*  The Size of each register in bytes.                         */
+zmax regsize[MAXR+1];
+
+/*  a type which can store each register. */
+struct Typ *regtype[MAXR+1];
+
+/*  regsa[reg]!=0 if a certain register is allocated and should */
+/*  not be used by the compiler pass.                           */
+int regsa[MAXR+1];
+
+/*  Specifies which registers may be scratched by functions.    */
+int regscratch[MAXR+1] = {
+    0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,  /* r0-r3,r12 */
+    1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,    /* vfp s0-s3 */
+    1,                                  /* cpsr */
+    1,1,0,0,0,                          /* r0/r1, r2/r3 */
+    1,1,0,0,0,0,0,0                     /* vfp d0-d1 */
+};
+
+/* specifies the priority for the register-allocator, if the same
+   estimated cost-saving can be obtained by several registers, the
+   one with the highest priority will be used */
+int reg_prio[MAXR+1] = {
+    0,10,11,12,13,2,3,4,5,6,7,8,9,14,0,1,0,
+    1,2,3,4,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,
+    10,12,2,4,8,
+    1,2,0,0,0,0,0,0
+};
+
+/* an empty reg-handle representing initial state */
+struct reg_handle empty_reg_handle = {0,0};
+
+/* Names of target-specific variable attributes.                */
+char *g_attr_name[] = {
+    "__arm","__thumb","__interrupt","__syscall",0
+};
+#define ARM 1
+#define THUMB 2
+#define INTERRUPT 4
+#define SYSCALL 8
+
+
+/****************************************/
+/*  Private data and functions.         */
+/****************************************/
+
+#define LE_MODE (g_flags[2]&USEDFLAG)
+#define BE_MODE (g_flags[3]&USEDFLAG)
+#define ARM_DEFAULT (g_flags[4]&USEDFLAG)
+#define THUMB_DEFAULT (g_flags[5]&USEDFLAG)
+#define CONST_IN_DATA (g_flags[6]&USEDFLAG)
+#define ELF_LABELS (g_flags[8]&USEDFLAG)
+#define USE_COMMONS (g_flags[9]&USEDFLAG)
+
+int arm_le_mode = 1;          /* defaults to little-endian */
+static int thumb_default = 0; /* we start in ARM mode */
+static int thumb = 0;         /* current mode */
+
+enum {
+  AAANY=0,AA2,AA3,AA3M,AA4,AA4T,AA5,AA5T,AA5TE
+};
+static int aa = AAANY;        /* ARM architecture version */
+
+/* alignment of basic data-types, used to initialize align[] */
+static long malign[MAX_TYPE+1] = {
+    1,1,2,4,4,8,4,8,8,1,4,1,1,1,4,1
+};
+/* sizes of basic data-types, used to initialize sizetab[] */
+static long msizetab[MAX_TYPE+1] = {
+    1,1,2,4,4,8,4,8,8,0,4,0,0,0,4,0
+};
+
+/* used to initialize regtyp[] */
+static struct Typ ltyp  = {LONG};
+static struct Typ lltyp = {LLONG};
+static struct Typ ftyp  = {FLOAT};
+static struct Typ dtyp  = {DOUBLE};
+
+/* macros defined by the backend */
+static char *marray[]={"__section(x,y)=__vattr(\"section(\"#x\",\"#y\")\")",
+                       "__ARM__",
+                       0};
+
+/* special registers */
+static int ip = FIRST_GPR+12;       /* inter-procedural scratch register */
+static int sp = FIRST_GPR+13;       /* stack pointer */
+static int lr = FIRST_GPR+14;       /* link register */
+static int pc = FIRST_GPR+15;       /* program counter */
+static int r0 = FIRST_GPR;
+static int r1 = FIRST_GPR+1;
+
+/* load/store instructions */
+static char *ldts[MAX_TYPE+1] = {
+    "ldr","ldrsb","ldrsh","ldr","ldr","ldr","ldr","ldr","ldr","??","ldr"};
+static char *ldtu[MAX_TYPE+1] = {
+    "ldr","ldrb","ldrh","ldr","ldr","ldr","??","??","??","??","??"};
+static char *sdts[MAX_TYPE+1] = {
+    "str","strb","strh","str","str","str","str","str","str","??","str"};
+static char *sdtu[MAX_TYPE+1] = {
+    "str","strb","strh","str","str","str","??","??","??","??","??"};
+#define ldt(t) ((t&UNSIGNED) ? ldtu[(t)&NQ] : ldts[(t)&NQ])
+#define sdt(t) ((t&UNSIGNED) ? sdtu[(t)&NQ] : sdts[(t)&NQ])
+
+static char *ldstprefix[] = {
+    "ld","st"
+};
+
+static char *dct[] = {
+    "","byte","short","word","word","word","word","word","word"
+};
+
+static char *ccs[] = {
+    "eq","ne","lt","ge","le","gt",""
+};
+
+static char *logicals[] = {
+    "orr","eor","and"
+};
+
+static char *shifts[2][2] = {
+    "lsl","asr","lsl","lsr"
+};
+
+/* sections */
+#define DATA 0
+#define BSS 1
+#define CODE 2
+#define RODATA 3
+#define SPECIAL 4
+
+#if 0
+static long stack;
+static int stack_valid;
+#endif
+static int newobj;
+static int section = -1;
+
+static char *codename = "\t.text\n";
+static char *dataname = "\t.data\n";
+static char *bssname = "";
+static char *rodataname = "\t.rodata\n";
+
+/* list of floating point constants to output at end of file */
+struct fpconstlist {
+  struct fpconstlist *next;
+  int label;
+  int typ;
+  union atyps val;
+};
+static struct fpconstlist *firstfpc = NULL;
+
+/* data reference pointers at the end of each function */
+struct DataRefPtrList {
+  struct DataRefPtrList *next;
+  int label;
+  struct Var *vptr;             /* valid, when label==0 */
+};
+static struct DataRefPtrList *dataptrs = NULL;
+static int drefptr_array_label; /* current array's label */
+
+#define isreg(x) (((x)&(REG|DREFOBJ))==REG)
+#define isconst(x) (((x)&(KONST|DREFOBJ))==KONST)
+
+static int q1reg,q2reg,zreg;
+static struct Var *current_function;
+static int icnt;                /* counts number of lines in cur. function */
+
+#define MAXCODELINES 500        /* emit data-ref. ptr array after that */
+#define MAXCOPYINSTS 4          /* max. nb. of load/store copy-instructions */
+
+/* return-instruction */
+static char *ret;
+
+/* label at the end of the function (if any) */
+static int exit_label;
+
+/* assembly-prefixes for labels and external identifiers */
+static char *labprefix="l";
+static char *idprefix="_";
+
+/* variables to calculate the size and partitioning of the stack-frame */
+static long frameoffset,pushoffs,framesize;
+static int needframe;
+static long localsize,rsavesize,argsize,rsaveoffs,maxrsaveoffs;
+
+
+
+static long real_offset(struct obj *o)
+/* calculate the actual current offset of an object relative to the
+   stack-pointer; we use a layout like this:
+   ------------------------------------------------
+   | stack-arguments to this function             |
+   ------------------------------------------------
+   | caller-save registers [size=rsavesize]       |
+   ------------------------------------------------
+   | local variables [size=localsize]             |
+   ------------------------------------------------
+   | arguments to called functions [size=argsize] |
+   ------------------------------------------------
+   All sizes will be aligned as necessary.
+   The stack-pointer will be adjusted at
+   function-entry to leave enough space for the arguments and have it
+   aligned to 16 bytes. Therefore, when calling a function, the
+   stack-pointer is always aligned to 16 bytes.
+*/
+{
+  long off = zm2l(o->v->offset);
+
+  if (off < 0) {
+    /* function parameter */
+    off = localsize + rsavesize - off - zm2l(maxalign);
+  }
+  else {
+    /* local variable */
+    off += argsize;
+    off += zm2l(o->val.vmax);
+  }
+
+  return off;
+}
+
+
+static struct obj *cam(int flags,int base,long offset)
+/*  Initializes an addressing-mode structure and returns a pointer to
+    that object. Will not survive a second call! */
+{
+  static struct obj obj;
+  static struct AddressingMode am;
+
+#if 0
+  obj.am = &am;
+  am.flags = flags;
+  am.base = base;
+  am.offset = offset;
+#endif
+  return &obj;
+}
+
+
+static int objalign(struct obj *o)
+/* yields the object's lower two bits, 1 when unknown */
+{
+  if (o->flags & DREFOBJ)
+    return 1;
+  if (o->am)
+    ierror(0);
+  if (!(o->flags & VAR))
+    ierror(0);
+
+  if (isstatic(o->v->storage_class) || isextern(o->v->storage_class)) {
+    /* all static data should be 32-bits aligned */
+    return zm2l(zmand(o->val.vmax,l2zm(3L)));
+  }
+
+  if (isauto(o->v->storage_class)) {
+    zmax of = o->v->offset;
+
+    if (!zmleq(l2zm(0L),of))
+      of = zmsub(l2zm(0L),zmadd(of,maxalign));
+    return zm2l(zmand(zmadd(of,o->val.vmax),l2zm(3L)));
+  }
+
+  ierror(0);
+}
+
+
+static void title(FILE *f)
+/* set file symbol with input file name */
+{
+  extern char *inname;
+  static int done;
+
+  if (!done && f) {
+    done = 1;
+    emit(f,"\t.file\t\"%s\"\n",inname);
+  }
+}
+
+
+static void emitnl(FILE *f)
+/* emit a newline character */
+{
+  emit(f,"\n");
+}
+
+
+static void emit_obj(FILE *f,struct obj *p,int t)
+/* prints an object */
+{
+  if (p->flags & VAR) {
+    if (isauto(p->v->storage_class)) {
+      emit(f,"[%s,#%ld]",regnames[sp],real_offset(p));
+    }
+    else {
+      if (!zmeqto(l2zm(0L),p->val.vmax)) {
+        emitval(f,&p->val,LONG);
+        emit(f,"+");
+      }
+      if (isstatic(p->v->storage_class))
+        emit(f,"%s%ld",labprefix,zm2l(p->v->offset));
+      else
+        emit(f,"%s%s",idprefix,p->v->identifier);
+    }
+  }
+
+  if (p->flags & REG) {
+    emit(f,"%s",regnames[p->reg]);
+  }
+
+  if (p->flags & KONST) {
+    emit(f,"#");
+    emitval(f,&p->val,t&NU);
+  }
+}
+
+
+static int special_section(FILE *f,struct Var *v)
+/* changes to a special section, used for __section() */
+{
+  char *sec;
+
+  if (v->vattr) {
+    if (sec = strstr(v->vattr,"section(")) {
+      sec += strlen("section(");
+      emit(f,"\t.section\t");
+      while (*sec && *sec!=')')
+        emit_char(f,*sec++);
+      emitnl(f);
+      if (f)
+        section = SPECIAL;
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+static int addfpconst(struct obj *o,int t)
+/* return label for a float-constant, create if it didn't exist */
+{
+  struct fpconstlist *p=firstfpc;
+
+  t &= NQ;
+  if (t == LDOUBLE)
+    t = DOUBLE;
+
+  for (p=firstfpc; p; p=p->next) {
+    if (t == p->typ) {
+      eval_const(&p->val,t);
+      if (t==FLOAT && zldeqto(vldouble,zf2zld(o->val.vfloat)))
+        return p->label;
+      if (t==DOUBLE && zldeqto(vldouble,zd2zld(o->val.vdouble)))
+        return p->label;
+    }
+  }
+
+  p = mymalloc(sizeof(struct fpconstlist));
+  p->next = firstfpc;
+  p->label = ++label;
+  p->typ = t;
+  p->val = o->val;
+  firstfpc = p;
+
+  return p->label;
+}
+
+
+static void emit_dataptr_array(FILE *f)
+/* emit all data-reference pointers which were collected until now,
+   then reset the array */
+{
+  struct DataRefPtrList *drp,*next;
+
+  if (next = dataptrs) {
+    emit(f,"\t.align\t2\n");
+    emit(f,"%s%d:\n",labprefix,drefptr_array_label);
+
+    while (drp = next) {
+      next = drp->next;
+      emit(f,"\t.%s\t",dct[LONG]);
+      if (drp->label) {
+        emit(f,"%s%d\n",labprefix,drp->label);
+      }
+      else {
+        if (isstatic(drp->vptr->storage_class))
+          emit(f,"%s%ld\n",labprefix,zm2l(drp->vptr->offset));
+        else
+          emit(f,"%s%s\n",idprefix,drp->vptr->identifier);
+      }
+      free(drp);
+    }
+    dataptrs = NULL;
+  }
+  drefptr_array_label = 0;
+}
+
+
+static int cg_getreg(FILE *f,struct IC *ic)
+/* allocate a code generator internal general purpose register */
+{
+  /* alloc_code: 1:compiler, 2:backend, >=4:backend rsave-area offset - 4 */
+  int alloc_code = 2;
+  int i,p,r;
+
+  /* try to get a free scratch-register or a non-volatile
+     register which has to be saved anyway,
+     r12 (ip) is reserved to the backend and will be used as well,
+     r14 (lr) is available when the function builds a stack frame */
+  for (i=FIRST_GPR,p=0,r=0; i<FIRST_GPR+13; i++) {
+    if (((i==ip && regs[i]==1) ||
+         (i==lr && regs[i]==1 && needframe) ||
+         (regs[i]==0 && (regscratch[i] || regused[i]))) &&
+        reg_prio[i]+(regused[i]<<8) > p) {
+      p = reg_prio[i] + (regused[i] << 8);
+      r = i;
+    }
+  }
+  if (!r) {
+    /* seems we have to save a new non-volatile register */
+    for (i=FIRST_GPR,p=0; i<FIRST_GPR+13; i++) {
+      if (regs[i]==0 && reg_prio[i]>p) {
+        p = reg_prio[i];
+        r = i;
+      }
+    }
+  }
+  if (!r) {
+    /* no register available - save one to the stack-frame, but
+       make sure it is not used in this IC */
+    for (i=FIRST_GPR,p=0; i<FIRST_GPR+13; i++) {
+      if (regs[i]<2 && reg_prio[i]>p) {
+        if ((!isreg(ic->q1.flags) || ic->q1.reg!=i) &&
+            (!isreg(ic->q2.flags) || ic->q2.reg!=i) &&
+            (!isreg(ic->z.flags) || ic->z.reg!=i)) {
+          p = reg_prio[i];
+          r = i;
+        }
+      }
+    }
+    if (r) {
+      if (f)
+        emit(f,"\tstr\t%s,[%s,#%ld]\n",
+             regnames[r],regnames[sp],argsize+localsize+rsaveoffs);
+      rsaveoffs += 4;
+      if (rsaveoffs > maxrsaveoffs)
+        maxrsaveoffs = rsaveoffs;
+      alloc_code = rsaveoffs;
+    }
+    else
+      ierror(0);
+  }
+
+  regs[r] = alloc_code;
+  regused[r] = 1;
+  return r;
+}
+
+
+static int cg_getdpreg(FILE *f,struct IC *ic)
+/* allocate a code generator internal double precision FP register */
+{
+  int i,p,r;
+  struct rpair rp;
+
+  /* try to get a free scratch-register or a non-volatile
+     register which has to be saved anyway */
+  for (i=FIRST_DOUBLE,p=0,r=0; i<=LAST_PAIR; i++) {
+    if (regs[i]==0 && (regscratch[i] || regused[i]) &&
+        reg_prio[i]+(regused[i]<<8) > p && reg_pair(i,&rp)) {
+      if (regs[rp.r1]==0 && regs[rp.r2]==0) {
+        p = reg_prio[i] + (regused[i] << 8);
+        r = i;
+      }
+    }
+  }
+  if (!r) {
+    ierror(0); /* @@@ FIXME */
+  }
+
+  regs[r] = 2;
+  regused[r] = 1;
+  if (!reg_pair(i,&rp))
+    ierror(0);
+  regs[rp.r1] = regs[rp.r2] = 2;
+  regused[rp.r1] = regused[rp.r2] = 1;
+  return r;
+}
+
+
+static void cg_restorereg(FILE *f,int r)
+{
+  if (f) {
+    if (r <= LAST_GPR)
+      emit(f,"\tldr\t%s,[%s,#%ld]\n",
+           regnames[r],regnames[sp],argsize+localsize+regs[r]-4);
+    else
+      ierror(0);  /* @@@ FIXME */
+  }
+}
+
+
+static void cg_freereg(FILE *f,int r)
+/* free a code generator internal general purpose register */
+{
+  struct rpair rp;
+
+  if (regs[r] > 1) {
+    if (regs[r] > 2)
+      cg_restorereg(f,r);
+    regs[r] = (r==ip||r==lr) ? 1 : 0;  /* ip/lr need to stay reserved */
+  }
+  else
+    ierror(0);
+
+  if (reg_pair(r,&rp)) {
+    if (regs[rp.r1]>1 && regs[rp.r2]>1) {
+      if (regs[rp.r1] > 2)
+        cg_restorereg(f,rp.r1);
+      if (regs[rp.r2] > 2)
+        cg_restorereg(f,rp.r2);
+      regs[rp.r1] = regs[rp.r2] = 0;
+    }
+    else
+      ierror(0);
+  }
+}
+
+
+static void cg_freeall(FILE *f)
+/* reset internal register allocations */
+{
+  int i;
+
+  for (i=1; i<=MAXR; i++) {
+    if (regs[i] > 1) {
+      if (regs[i] > 2)
+        cg_restorereg(f,i);
+      regs[i] = (i==ip||i==lr) ? 1 : 0;  /* ip/lr need to stay reserved */
+    }
+  }
+  rsaveoffs = 0;
+}
+
+
+static long dataptr_offset(int label,struct obj *o)
+/* return offset into data-reference-pointer array for label l
+   or for object o (mutually exclusive) */
+{
+  long off = 0;
+  struct DataRefPtrList **olddrp = &dataptrs;
+  struct DataRefPtrList *drp = dataptrs;
+
+  if (!label) {
+    if (!(o->flags & VAR))
+      ierror(0);
+    if (!isstatic(o->v->storage_class) && !isextern(o->v->storage_class))
+      ierror(0);
+  }
+
+  /* check if a pointer to this object already exists */
+  while (drp) {
+    if (label) {
+      if (drp->label == label)
+        break;
+    }
+    else {
+      if (drp->vptr == o->v)
+        break;
+    }
+    olddrp = &drp->next;
+    drp = drp->next;
+    off += 4;
+  }
+
+  /* create a new entry if it doesn't exist */
+  if (drp == NULL) {
+    *olddrp = drp = mymalloc(sizeof(struct DataRefPtrList));
+
+    drp->next = NULL;
+    if (drp->label = label)
+      drp->vptr = NULL;
+    else
+      drp->vptr = o->v;
+  }
+
+  return off;
+}
+
+
+static void load_dataptr(FILE *f,int r,int l,struct obj *o)
+/* load data-reference-pointer array entry for label l or object o into r */
+{
+  BSET(regs_modified,r);
+
+  if (!drefptr_array_label)
+    drefptr_array_label = ++label;
+
+  emit(f,"\tldr\t%s,%s%d+%ld\n",
+       regnames[r],labprefix,drefptr_array_label,dataptr_offset(l,o));
+}
+
+
+static void ldst64(FILE *f,int store,struct rpair *rp,int base)
+/* generate a ldmia or stmia (store=1) instruction to transfer a 64-bit
+   value in register pair rp pointed to by base-register base */
+{
+  emit(f,"%smia\t%s,{%s-%s}\n",
+       ldstprefix[store],regnames[base],regnames[rp->r1],regnames[rp->r2]);
+}
+
+
+static void load_address(FILE *f,int r,struct obj *o,int type)
+/*  Generates code to load the address of a variable into register r. */
+{
+  BSET(regs_modified,r);
+
+  if (!(o->flags & VAR))
+    ierror(0);
+
+  if (isauto(o->v->storage_class))
+    emit(f,"\tadd\t%s,%s,#%ld\n",regnames[r],regnames[sp],real_offset(o));
+  else
+    load_dataptr(f,r,0,o);
+}
+
+
+static void load_regindir(FILE *f,struct IC *p,int type,
+                          int dst,int base,long off)
+/*  Load register dst of type type from [base,#off].
+    base and dst may be the same.
+    Perform size extensions as required by architecture. */
+{
+  BSET(regs_modified,dst);
+
+  if (aa >= AA4) {
+    emit(f,"\t%s\t%s,[%s,#%ld]\n",
+         ldt(type),regnames[dst],regnames[base],off);
+  }
+
+  else {
+    /* this requires more effort on older ARMs */
+    int tmp;
+
+    switch (sizetab[type&NQ]) {
+      case 1:
+        emit(f,"\tldrb\t%s,[%s,#%ld]\n",regnames[dst],regnames[base],off);
+        if (!(type & UNSIGNED)) {
+          emit(f,"\tmov\t%s,%s,lsl #24\n",regnames[dst],regnames[dst]);
+          emit(f,"\tmov\t%s,%s,asr #24\n",regnames[dst],regnames[dst]);
+        }
+        break;
+      case 2:
+        tmp = cg_getreg(f,p);
+        emit(f,"\tldrb\t%s,[%s,#%ld]\n",regnames[tmp],regnames[base],
+                                        off+1-arm_le_mode);
+        emit(f,"\tldrb\t%s,[%s,#%ld]\n",regnames[dst],regnames[base],
+                                        off+arm_le_mode);
+        if (!(type & UNSIGNED)) {
+          emit(f,"\tmov\t%s,%s,lsl #24\n",regnames[dst],regnames[dst]);
+          emit(f,"\torr\t%s,%s,%s asr #16\n",
+               regnames[dst],regnames[tmp],regnames[dst]);
+        }
+        else {
+          emit(f,"\torr\t%s,%s,%s lsl #8\n",
+               regnames[dst],regnames[tmp],regnames[dst]);
+        }
+        cg_freereg(f,tmp);
+        break;
+      case 4:
+        emit(f,"\tldr\t%s,[%s,#%ld]\n",regnames[dst],regnames[base],off);
+        break;
+      default:
+        ierror(0);
+    }
+  }
+}
+
+
+static void load_reg(FILE *f,struct IC *p,int r,struct obj *o,int type)
+/* Generates code to load a memory object into register r. */
+{
+  type &= NU;
+  BSET(regs_modified,r);
+
+  if (o->flags & KONST) {
+    /* evaluate and load a constant */
+
+    eval_const(&o->val,type);
+
+    if (ISFLOAT(type)) {
+      int lab = addfpconst(o,type);
+
+      load_dataptr(f,r,lab,NULL);
+      if (type == FLOAT)
+        load_regindir(f,p,type,r,r,0);
+      else
+        ierror(0);  /* double can only be in a register-pair */
+    }
+
+    else {
+      /* integer constant */
+      emit(f,"\tmov\t%s,",regnames[r]);
+      emit_obj(f,o,type);
+      emitnl(f);
+    }
+  }
+
+  else if (isreg(o->flags)) {
+    if (r != o->reg)
+      emit(f,"\tmov\t%s,%s\n",regnames[r],regnames[o->reg]);
+  }
+
+  else if ((o->flags & (REG|DREFOBJ)) == (REG|DREFOBJ)) {
+    load_regindir(f,p,type,r,o->reg,0);
+  }
+
+  else if (o->flags & VAR) {
+    if (isstatic(o->v->storage_class) || isextern(o->v->storage_class)) {
+      /* load from a static variable */
+      if (o->flags & VARADR) {
+        load_address(f,r,o,POINTER);
+      }
+      else {
+        load_dataptr(f,r,0,o);
+        load_regindir(f,p,type,r,r,zm2l(o->val.vmax));
+      }
+    }
+    else {
+      /* dynamic variable on stack */
+      load_regindir(f,p,type,r,sp,real_offset(o));
+    }
+  }
+
+  else
+    ierror(0);
+}
+
+
+static void store_regindir(FILE *f,struct IC *p,int type,
+                           int src,int base,long off)
+/*  Store register src of type type to [base,#off]. */
+{
+  if (aa>=AA4 || sizetab[type&NQ]!=2) {
+    emit(f,"\t%s\t%s,[%s,#%ld]\n",
+         sdt(type),regnames[src],regnames[base],off);
+  }
+
+  else {
+    /* storing halfwords requires more effort on older ARMs */
+    int tmp = cg_getreg(f,p);
+
+    emit(f,"\tstrb\t%s,[%s,#%ld]\n",regnames[src],regnames[base],
+                                    off+1-arm_le_mode);
+    emit(f,"\tmov\t%s,%s,asr #8\n",regnames[tmp],regnames[src]);
+    emit(f,"\tstrb\t%s,[%s,#%ld]\n",regnames[src],regnames[base],
+                                    off+arm_le_mode);
+    cg_freereg(f,tmp);
+  }
+}
+
+
+static void store_reg(FILE *f,struct IC *p,int r,struct obj *o,int type)
+/* Generates code to store register r into memory object o. */
+{
+  if (isreg(o->flags)) {
+    if (r != o->reg)
+      emit(f,"\tmov\t%s,%s\n",regnames[o->reg],regnames[r]);
+  }
+
+  else if ((o->flags & (REG|DREFOBJ)) == (REG|DREFOBJ)) {
+    store_regindir(f,p,type,r,o->reg,0);
+  }
+
+  else if (o->flags & VAR) {
+    if (isstatic(o->v->storage_class) || isextern(o->v->storage_class)) {
+      /* store to a static variable */
+      int tmp = cg_getreg(f,p);
+
+      load_dataptr(f,tmp,0,o);
+      store_regindir(f,p,type,r,tmp,zm2l(o->val.vmax));
+      cg_freereg(f,tmp);
+    }
+    else {
+      /* dynamic variable on stack */
+      store_regindir(f,p,type,r,sp,real_offset(o));
+    }
+  }
+
+  else
+    ierror(0);
+}
+
+
+static int load_objptr(FILE *f,struct IC *p,struct obj *o)
+/* Make sure object o can be dereferenced by a single load.
+   Return new base register, or 0 if object was not modified. */
+{
+  if ((o->flags & (REG|DREFOBJ)) == DREFOBJ) {
+    int r = cg_getreg(f,p);
+
+    load_reg(f,p,r,o,POINTER);
+    o->flags |= REG;
+    o->reg = r;
+    return r;
+  }
+
+  if ((o->flags & (VAR|REG)) == VAR) {
+    if (isstatic(o->v->storage_class) || isextern(o->v->storage_class)) {
+      int r = cg_getreg(f,p);
+
+      load_dataptr(f,r,0,o);
+      o->reg = r;
+      o->flags = REG|DREFOBJ;
+      return r;
+    }
+  }
+
+  return 0;
+}
+
+
+static void load_regpair(FILE *f,struct IC *p,struct rpair *rp,
+                         struct obj *o,int type)
+/* Generates code to load a memory object into the register pair rp.
+   tmp is a general purpose register which may be used. */
+{
+  BSET(regs_modified,rp->r1);
+  BSET(regs_modified,rp->r2);
+
+  if (o->flags & KONST) {
+    /* evaluate and load a constant */
+    eval_const(&o->val,type);
+
+    if (ISFLOAT(type)) {
+      int lab = addfpconst(o,type);
+      int tmp = cg_getreg(f,p);
+
+      load_dataptr(f,tmp,lab,NULL);
+      if (type != FLOAT)
+        ldst64(f,0,rp,tmp);
+      else
+        ierror(0);  /* have to load float in a single register */
+      cg_freereg(f,tmp);
+    }
+    else {
+      struct obj cobj;
+
+      cobj.flags = KONST;
+      cobj.val.vulong = zum2zul(zumand(vumax,ul2zum(0xffffffff))); 
+      load_reg(f,p,arm_le_mode?rp->r1:rp->r2,&cobj,UNSIGNED|LONG);
+      cobj.val.vulong = zum2zul(zumand(zumrshift(vumax,ul2zum(32UL)),
+                                       ul2zum(0xffffffff)));
+      load_reg(f,p,arm_le_mode?rp->r2:rp->r1,&cobj,UNSIGNED|LONG);
+    }
+  }
+
+  else {
+    /* make sure that object can be addressed through a register */
+    load_objptr(f,p,o);
+
+    if (isreg(o->flags)) {
+      struct rpair qrp;
+
+      if (!reg_pair(o->reg,&qrp))
+        ierror(0);
+      if (qrp.r1 != rp->r1) {
+        emit(f,"\tmov\t%s,%s\n\tmov\t%s,%s\n",regnames[rp->r1],
+             regnames[qrp.r1],regnames[rp->r2],regnames[qrp.r2]);
+      }
+    }
+    else if ((o->flags & (REG|DREFOBJ)) == (REG|DREFOBJ)) {
+      ldst64(f,0,rp,o->reg);
+    }
+    else
+      ierror(0);
+  }
+}
+
+
+static void store_regpair(FILE *f,struct IC *p,struct rpair *rp,
+                          struct obj *o,int type)
+/* Generates code to store the register pair rp into memory object o.
+   tmp is a general purpose register which may be used. */
+{
+  /* make sure that object can be addressed through a register */
+  load_objptr(f,p,o);
+
+  if (isreg(o->flags)) {
+    struct rpair zrp;
+
+    if (!reg_pair(o->reg,&zrp))
+      ierror(0);
+    if (zrp.r1 != rp->r1) {
+      emit(f,"\tmov\t%s,%s\n\tmov\t%s,%s\n",regnames[zrp.r1],
+           regnames[rp->r1],regnames[zrp.r2],regnames[rp->r2]);
+    }
+  }
+  else if ((o->flags & (REG|DREFOBJ)) == (REG|DREFOBJ)) {
+    ldst64(f,1,rp,o->reg);
+  }
+  else
+    ierror(0);
+}
+
+
+static long pof2(zumax x)
+/* yields log2(x)+1 or 0 */
+{
+  zumax p;
+  int ln = 1;
+
+  p = ul2zum(1L);
+  while (ln<=32 && zumleq(p,x)) {
+    if (zumeqto(x,p))
+        return ln;
+    ln++;
+    p = zumadd(p,p);
+  }
+  return 0;
+}
+
+
+static struct IC *preload(FILE *f,struct IC *p)
+/* Does some pre-processing like fetching operands from memory to
+   registers etc. */
+/* @@@ FIXME - Is this function needed at all ??? */
+{
+#if 0
+  if (isreg(p->q1.flags))
+    q1reg = p->q1.reg;
+  else
+    q1reg = 0;
+
+  if (isreg(p->q2.flags))
+    q2reg = p->q2.reg;
+  else
+    q2reg = 0;
+#endif
+
+  if (isreg(p->z.flags)) {
+    zreg = p->z.reg;
+  }
+  else {
+    if (ISFLOAT(ztyp(p)))
+      zreg = FIRST_PAIR;  /* @@@ VFP? ->f1 */
+    else
+      zreg = cg_getreg(f,p);
+  }
+  
+#if 0  /* Better use load_objptr() when needed? */
+  if ((p->q1.flags & (REG|DREFOBJ)) == DREFOBJ) {
+    int tmp = cg_getreg(f,p);
+
+    p->q1.flags &= ~DREFOBJ;
+    load_reg(f,p,tmp,&p->q1,q1typ(p));
+    p->q1.reg = tmp;
+    p->q1.flags |= REG|DREFOBJ;
+  }
+
+  if ((p->q2.flags & (REG|DREFOBJ)) == DREFOBJ) {
+    int tmp = cg_getreg(f,p);
+
+    p->q2.flags &= ~DREFOBJ;
+    load_reg(f,p,tmp,&p->q2,q2typ(p));
+    p->q2.reg = tmp;
+    p->q2.flags |= REG|DREFOBJ;
+  }
+#endif
+
+  return p;
+}
+
+
+static void save_result(FILE *f,struct IC *p)
+/* save the result (in zreg) into p->z */
+{
+  if ((p->z.flags&(REG|DREFOBJ)) == DREFOBJ) {
+    int tmp = cg_getreg(f,p);
+
+    p->z.flags &= ~DREFOBJ;
+    load_reg(f,p,tmp,&p->z,POINTER);
+    p->z.reg = tmp;
+    p->z.flags |= REG|DREFOBJ;
+  }
+  if (isreg(p->z.flags)) {
+    if (p->z.reg != zreg)
+      emit(f,"\tmov\t%s,%s\n",regnames[p->z.reg],regnames[zreg]);
+  }
+  else {
+    store_reg(f,p,zreg,&p->z,ztyp(p));
+  }
+}
+
+
+static void registerize(FILE *f,struct IC *p,struct obj *o,int t)
+/* make sure object is loaded into a register */
+{
+  if (!(isreg(o->flags))) {
+    int r;
+
+    r = load_objptr(f,p,o);
+    if (!r)
+      r = cg_getreg(f,p);
+    if ((o->flags & (REG|DREFOBJ)) == DREFOBJ)
+      ierror(0);
+    load_reg(f,p,r,o,t);
+    o->reg = r;
+  }
+  o->flags = REG;
+}
+
+
+static void cg_memcopy(FILE *f,struct IC *p)
+/* generates code to copy an object of non-elementary type (ARRAY, STRUCT) */
+{
+  unsigned long size = opsize(p);
+  int a1 = objalign(&p->q1);
+  int a2 = (p->code==ASSIGN) ? objalign(&p->z) : 0;
+  int b = 1;
+  char *ld = ldt(CHAR);
+  char *st = sdt(CHAR);
+  unsigned long l;
+  int srcreg,dstreg,tmpreg,cntreg,ncp;
+
+  if (p->q1.flags & VAR) {
+    if (p->q1.flags & DREFOBJ) {
+      if (p->q1.v->vtyp->next &&
+          zmeqto(p->q2.val.vmax,szof(p->q1.v->vtyp->next)) && (a1&1)) {
+        a1 = zm2l(falign(p->q1.v->vtyp->next)) & 3;
+        a2 &= a1;
+      }
+    }
+    else {
+      if (zmeqto(p->q2.val.vmax,szof(p->q1.v->vtyp)) && (a1&1)) {
+        a1 = zm2l(falign(p->q1.v->vtyp)) & 3;
+        a2 &= a1;
+      }
+    }
+  }
+  if (p->z.flags & VAR) {
+    if (p->z.flags & DREFOBJ) {
+      if (p->z.v->vtyp->next &&
+          zmeqto(p->q2.val.vmax,szof(p->z.v->vtyp->next)) && (a2&1)) {
+        a2 = zm2l(falign(p->z.v->vtyp->next)) & 3;
+        a1 &= a2;
+      }
+    }
+    else {
+      if (zmeqto(p->q2.val.vmax,szof(p->z.v->vtyp)) && (a2&1)) {
+        a2 = zm2l(falign(p->z.v->vtyp)) & 3;
+        a1 &= a2;
+      }
+    }
+  } 
+
+  /* @@@ implement with ldmia/stmia */
+  if (a1>=0 && a2>=0) {
+    if (a1==0 && a2==0) {
+      /* 32-bit copy */
+      b = 4;
+      ld = ldt(LONG);
+      st = sdt(LONG);
+    }
+    else if ((a1&1)==0 && (a2&1)==0 && aa>=AA4) {
+      /* 16-bit copy for ARM-architecture 4 and better only */
+      b = 2;
+      ld = ldt(SHORT);
+      st = sdt(SHORT);
+    }
+  }
+
+  srcreg = cg_getreg(f,p);
+  BSET(regs_modified,srcreg);
+
+  if (p->q1.flags & DREFOBJ) {
+    p->q1.flags &= ~DREFOBJ;
+    if (isreg(p->q1.flags))
+      emit(f,"\tmov\t%s,%s\n",regnames[srcreg],regnames[p->q1.reg]);
+    else
+      load_reg(f,p,srcreg,&p->q1,POINTER);
+    p->q1.flags |= DREFOBJ;
+  }
+  else {
+    load_address(f,srcreg,&p->q1,POINTER);
+  }
+
+  dstreg = cg_getreg(f,p);
+  BSET(regs_modified,dstreg);
+
+  if (p->z.flags & DREFOBJ) {
+    p->z.flags &= ~DREFOBJ;
+    if (isreg(p->z.flags))
+      emit(f,"\tmov\t%s,%s\n",regnames[dstreg],regnames[p->z.reg]);
+    else
+      load_reg(f,p,dstreg,&p->z,POINTER);
+    p->z.flags |= DREFOBJ;
+  }
+  else {
+    if (p->code == PUSH) {
+      emit(f,"\tadd\t%s,%s,#%ld\n",regnames[dstreg],regnames[sp],pushoffs);
+      pushoffs += size;
+    }
+    else
+      load_address(f,dstreg,&p->z,POINTER);
+  }
+
+  tmpreg = cg_getreg(f,p);
+  BSET(regs_modified,tmpreg);
+  l = size/b;
+
+  if (l > MAXCOPYINSTS) { /* @@@ make MAXCOPYINSTS changeable by an option? */
+    cntreg = cg_getreg(f,p);
+    BSET(regs_modified,cntreg);
+    emit(f,"\tmov\t%s,#%lu\n",regnames[cntreg],l);
+    emit(f,"%s%d:\n",labprefix,++label);
+    ncp = 1;
+  }
+  else
+    ncp = l;
+  while (ncp--) {
+    emit(f,"\t%s\t%s,[%s],#%d\n",ld,regnames[tmpreg],regnames[srcreg],b);
+    emit(f,"\t%s\t%s,[%s],#%d\n",st,regnames[tmpreg],regnames[dstreg],b);
+  }
+  if (l > MAXCOPYINSTS) {
+    emit(f,"\tsubs\t%s,%s,#1\n",regnames[cntreg],regnames[cntreg]);
+    emit(f,"\tbne\t%s%d\n",labprefix,label);
+    cg_freereg(f,cntreg);
+  }
+
+  size = size % b;
+  ncp = 0;
+  if (size & 2) {
+    if (aa >= AA4) {
+      emit(f,"\t%s\t%s,[%s],#%d\n",ldt(SHORT),regnames[tmpreg],regnames[srcreg],b);
+      emit(f,"\t%s\t%s,[%s],#%d\n",sdt(SHORT),regnames[tmpreg],regnames[dstreg],b);
+    }
+    else
+      ncp = 2;
+  }
+  ncp += (size & 1);
+  while (ncp--) {
+    emit(f,"\t%s\t%s,[%s],#%d\n",ldt(CHAR),regnames[tmpreg],regnames[srcreg],b);
+    emit(f,"\t%s\t%s,[%s],#%d\n",sdt(CHAR),regnames[tmpreg],regnames[dstreg],b);
+  }
+}
+
+
+static int exists_freereg(struct IC *p,int reg)
+/*  Test if there is a sequence of FREEREGs containing FREEREG reg.
+    Used by peephole(). */
+{
+  while (p && (p->code==FREEREG || p->code==ALLOCREG)) {
+    if (p->code==FREEREG && p->q1.reg==reg)
+      return 1;
+    p=p->next;
+  }
+  return 0;
+}
+
+
+#if 0
+static void peephole(struct IC *p)
+/* search for possible addressing-modes */
+{
+  int c,c2,r;struct IC *p2;struct AddressingMode *am;
+
+  for(;p;p=p->next){
+    c=p->code;
+    if(c!=FREEREG&&c!=ALLOCREG&&(c!=SETRETURN||!isreg(p->q1.flags)||p->q1.reg!=p->z.reg)) exit_label=0;
+    if(c==LABEL) exit_label=p->typf;
+
+    /* Try const(reg) */
+    if(IMM_IND&&(c==ADDI2P||c==SUBIFP)&&isreg(p->z.flags)&&isconst(p->q2.flags)){
+      int base;zmax of;struct obj *o;
+      eval_const(&p->q2.val,p->typf);
+      if(c==SUBIFP) of=zmsub(l2zm(0L),vmax); else of=vmax;
+      if(1/*zmleq(l2zm(-32768L),vmax)&&zmleq(vmax,l2zm(32767L))*/){
+        r=p->z.reg;
+        if(isreg(p->q1.flags)) base=p->q1.reg; else base=r;
+        o=0;
+        for(p2=p->next;p2;p2=p2->next){
+          c2=p2->code;
+          if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
+          if(c2!=FREEREG&&isreg(p2->q1.flags)&&p2->q1.reg==r) break;
+          if(c2!=FREEREG&&isreg(p2->q2.flags)&&p2->q2.reg==r) break;
+          if(c2!=CALL&&(c2<LABEL||c2>BRA)/*&&c2!=ADDRESS*/){
+            if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r){
+              if(o) break;
+              o=&p2->q1;
+            }
+            if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r){
+              if(o) break;
+              o=&p2->q2;
+            }
+            if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r){
+              if(o) break;
+              o=&p2->z;
+            }
+          }
+          if(c2==FREEREG||isreg(p2->z.flags)){
+            int m;
+            if(c2==FREEREG)
+              m=p2->q1.reg;
+            else
+              m=p2->z.reg;
+            if(m==r){
+              if(o){
+                o->am=am=mymalloc(sizeof(*am));
+                am->flags=IMM_IND;
+                am->base=base;
+                am->offset=zm2l(of);
+                if(isreg(p->q1.flags)){
+                  p->code=c=NOP;p->q1.flags=p->q2.flags=p->z.flags=0;
+                }else{
+                  p->code=c=ASSIGN;p->q2.flags=0;
+                  p->typf=p->typf2;p->q2.val.vmax=sizetab[p->typf2&NQ];
+                }
+              }
+              break;
+            }
+            if(c2!=FREEREG&&m==base) break;
+            continue;
+          }
+        }
+      }
+    }
+    /* Try reg,reg */
+    if(GPR_IND&&c==ADDI2P&&isreg(p->q2.flags)&&isreg(p->z.flags)&&(isreg(p->q1.flags)||p->q2.reg!=p->z.reg)){
+      int base,idx;struct obj *o;
+      r=p->z.reg;idx=p->q2.reg;
+      if(isreg(p->q1.flags)) base=p->q1.reg; else base=r;
+      o=0;
+      for(p2=p->next;p2;p2=p2->next){
+        c2=p2->code;
+        if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
+        if(c2!=FREEREG&&isreg(p2->q1.flags)&&p2->q1.reg==r) break;
+        if(c2!=FREEREG&&isreg(p2->q2.flags)&&p2->q2.reg==r) break;
+        if(isreg(p2->z.flags)&&p2->z.reg==idx&&idx!=r) break;
+        
+        if(c2!=CALL&&(c2<LABEL||c2>BRA)/*&&c2!=ADDRESS*/){
+          if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r){
+            if(o||(q1typ(p2)&NQ)==LLONG) break;
+            o=&p2->q1;
+          }
+          if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r){
+            if(o||(q2typ(p2)&NQ)==LLONG) break;
+            o=&p2->q2;
+          }
+          if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r){
+            if(o||(ztyp(p2)&NQ)==LLONG) break;
+            o=&p2->z;
+          }
+        }
+        if(c2==FREEREG||isreg(p2->z.flags)){
+          int m;
+          if(c2==FREEREG)
+            m=p2->q1.reg;
+          else
+            m=p2->z.reg;
+          if(m==r){
+            if(o){
+              o->am=am=mymalloc(sizeof(*am));
+              am->flags=GPR_IND;
+              am->base=base;
+              am->offset=idx;
+              if(isreg(p->q1.flags)){
+                p->code=c=NOP;p->q1.flags=p->q2.flags=p->z.flags=0;
+              }else{
+                p->code=c=ASSIGN;p->q2.flags=0;
+                p->typf=p->typf2;p->q2.val.vmax=sizetab[p->typf2&NQ];
+              }
+            }
+            break;
+          }
+          if(c2!=FREEREG&&m==base) break;
+          continue;
+        }
+      }
+    }
+  }
+}
+#endif
+
+
+static void function_top(FILE *f,struct Var *v,long offset)
+/* generates the function entry code */
+{
+  static char ret_instr[64];
+  char gprsave[32];
+  char *p;
+  int i;
+
+  title(f);
+
+  /* determine rsavesize and registers to save */
+  rsavesize = 0;
+  gprsave[0] = '\0';
+  for (i=FIRST_GPR,p=gprsave; i<=LAST_GPR; i++) {
+    if (!regsa[i] && !regscratch[i] && regused[i]) {
+      p += sprintf(p,"%s,",regnames[i]);
+      rsavesize += 4;
+    }
+  }
+
+  if (!special_section(f,v) && section!=CODE) {
+    emit(f,codename);
+    section = CODE;
+  } 
+
+  if (isextern(v->storage_class)) {
+    if ((v->flags & (INLINEFUNC|INLINEEXT)) != INLINEFUNC)
+      emit(f,"\t.global\t%s%s\n",idprefix,v->identifier);
+    emit(f,"%s%s:\n",idprefix,v->identifier);
+  }
+  else
+    emit(f,"%s%ld:\n",labprefix,zm2l(v->offset));
+
+  if (rsavesize==0 && !needframe) {
+    ret = "\tmov\tpc,lr\n";
+  }
+  else {
+    rsavesize += 3*4;  /* sp,lr,pc to be saved as well */
+    emit(f,"\tstmfd\t%s!,{%s%s,%s,%s}\n",
+         regnames[sp],gprsave,regnames[sp],regnames[lr],regnames[pc]);
+    sprintf(ret_instr,"\tldmfd\t%s,{%s%s,%s}\n",
+            regnames[sp],gprsave,regnames[sp],regnames[pc]);
+    ret = ret_instr;
+    if (localsize+argsize > 0) {
+      emit(f,"\tsub\t%s,%s,#%ld\n",
+           regnames[sp],regnames[sp],localsize+argsize);
+    }
+  }
+}
+
+
+static void function_bottom(FILE *f,struct Var *v,long offset)
+/* generates the function exit code */
+{
+  if (localsize+argsize > 0) {
+    emit(f,"\tadd\t%s,%s,#%ld\n",
+         regnames[sp],regnames[sp],localsize+argsize);
+  }
+  emit(f,ret);
+  emit_dataptr_array(f);
+
+  if (isextern(v->storage_class)) {
+    emit(f,"\t.type\t%s%s,@function\n",idprefix,v->identifier);
+    emit(f,"\t.size\t%s%s,.-%s%s\n\n",
+         idprefix,v->identifier,idprefix,v->identifier);
+  }
+  else {
+    emit(f,"\t.type\t%s%ld,@function\n",labprefix,zm2l(v->offset));
+    emit(f,"\t.size\t%s%ld,.-%s%ld\n\n",
+         labprefix,zm2l(v->offset),labprefix,zm2l(v->offset));
+  }    
+
+  /*if(all_regs&&v->fi) v->fi->flags|=ALL_REGS;*/
+}
+
+
+/****************************************/
+/*  End of private data and functions.  */
+/****************************************/
+
+
+int init_cg(void)
+/*  Does necessary initializations for the code-generator. Gets called  */
+/*  once at the beginning and should return 0 in case of problems.      */
+{
+  int i;
+
+  /*  Initialize some values which cannot be statically initialized   */
+  /*  because they are stored in the target's arithmetic.             */
+  maxalign = l2zm(8L);
+  stackalign = l2zm(4L);
+  char_bit = l2zm(8L);
+
+  for (i=0; i<=MAX_TYPE; i++) {
+    sizetab[i] = l2zm(msizetab[i]);
+    align[i] = l2zm(malign[i]);
+  }
+
+  for (i=FIRST_GPR; i<=LAST_GPR; i++) {
+    regsize[i] = l2zm(4L);
+    regtype[i] = &ltyp;
+  }
+
+  for (i=FIRST_FPR; i<=LAST_FPR; i++) {
+    regsize[i] = l2zm(8L);
+    regtype[i] = &ftyp;
+  }
+
+  for (i=FIRST_CCR; i<=LAST_CCR; i++) {
+    regsize[i] = l2zm(4L);
+    regtype[i] = &ltyp;
+  }
+
+  for (i=FIRST_PAIR; i<FIRST_DOUBLE; i++) {
+    regsize[i] = l2zm(8L);
+    regtype[i] = &lltyp;
+  }
+
+  for (i=FIRST_DOUBLE; i<=LAST_PAIR; i++) {
+    regsize[i] = l2zm(8L);
+    regtype[i] = &dtyp;
+  }
+
+  /*  Initialize the min/max-settings. Note that the types of the     */
+  /*  host system may be different from the target system and you may */
+  /*  only use the smallest maximum values ANSI guarantees if you     */
+  /*  want to be portable.                                            */
+  /*  That's the reason for the subtraction in t_min[INT]. Long could */
+  /*  be unable to represent -2147483648 on the host system.          */
+  t_min[CHAR] = l2zm(-128L);
+  t_min[SHORT] = l2zm(-32768L);
+  t_min[INT] = zmsub(l2zm(-2147483647L),l2zm(1L));
+  t_min[LONG] = t_min(INT);
+  t_min[LLONG] = zmlshift(l2zm(1L),l2zm(63L));
+  t_min[MAXINT] = t_min(LLONG);
+  t_max[CHAR] = ul2zum(127L);
+  t_max[SHORT] = ul2zum(32767UL);
+  t_max[INT] = ul2zum(2147483647UL);
+  t_max[LONG] = t_max(INT);
+  t_max[LLONG] = zumrshift(zumkompl(ul2zum(0UL)),ul2zum(1UL));
+  t_max[MAXINT] = t_max(LLONG);
+  tu_max[CHAR] = ul2zum(255UL);
+  tu_max[SHORT] = ul2zum(65535UL);
+  tu_max[INT] = ul2zum(4294967295UL);
+  tu_max[LONG] = t_max(UNSIGNED|INT);
+  tu_max[LLONG] = zumkompl(ul2zum(0UL));
+  tu_max[MAXINT] = t_max(UNSIGNED|LLONG);
+
+  /*  Reserve a few registers for use by the code-generator.      */
+  regsa[ip] = regsa[sp] = regsa[lr] = regsa[pc] = 1;
+  regscratch[ip] = regscratch[sp] = regscratch[lr] = regscratch[pc] = 0;
+
+  if (LE_MODE)
+    arm_le_mode = 1;
+  if (BE_MODE)
+    arm_le_mode = 0;
+  if (ARM_DEFAULT)
+    thumb_default = 0;
+  if (THUMB_DEFAULT)
+    thumb_default = 1;
+  if (ELF_LABELS) {
+    labprefix = ".l";
+    idprefix = "";
+  }
+
+  target_macros = marray;
+
+  return 1;
+}
+
+
+void init_db(FILE *f)
+{
+}
+
+
+int freturn(struct Typ *t)
+/*  Returns the register in which variables of type t are returned. */
+/*  If the value cannot be returned in a register returns 0.        */
+/*  A pointer MUST be returned in a register. The code-generator    */
+/*  has to simulate a pseudo register if necessary.                 */
+{
+  int tu = t->flags&NQ;
+
+  /* @@@ handle VFP */
+
+  if (tu==LLONG || tu==DOUBLE)
+    return FIRST_PAIR;
+
+  if (zmleq(szof(t),l2zm(4L)))
+    return FIRST_GPR;
+
+  return 0;
+}
+
+
+int reg_pair(int r,struct rpair *p)
+/* Returns 0 if the register is no register pair. If r  */
+/* is a register pair non-zero will be returned and the */
+/* structure pointed to p will be filled with the two   */
+/* elements.                                            */
+{
+  if (r<FIRST_PAIR || r>LAST_PAIR)
+    return 0;
+
+  switch (r) {
+    case FIRST_PAIR:
+      p->r1 = FIRST_GPR;
+      p->r2 = FIRST_GPR+1;
+      return 1;
+    case FIRST_PAIR+1:
+      p->r1 = FIRST_GPR+2;
+      p->r2 = FIRST_GPR+3;
+      return 1;
+    case FIRST_PAIR+2:
+      p->r1 = FIRST_GPR+4;
+      p->r2 = FIRST_GPR+5;
+      return 1;
+    case FIRST_PAIR+3:
+      p->r1 = FIRST_GPR+6;
+      p->r2 = FIRST_GPR+7;
+      return 1;
+    case FIRST_PAIR+4:
+      p->r1 = FIRST_GPR+10;
+      p->r2 = FIRST_GPR+11;
+      return 1;
+    case FIRST_DOUBLE:
+      p->r1 = FIRST_FPR;
+      p->r2 = FIRST_FPR+1;
+      return 1;
+    case FIRST_DOUBLE+1:
+      p->r1 = FIRST_FPR+2;
+      p->r2 = FIRST_FPR+3;
+      return 1;
+    case FIRST_DOUBLE+2:
+      p->r1 = FIRST_FPR+4;
+      p->r2 = FIRST_FPR+5;
+      return 1;
+    case FIRST_DOUBLE+3:
+      p->r1 = FIRST_FPR+6;
+      p->r2 = FIRST_FPR+7;
+      return 1;
+    case FIRST_DOUBLE+4:
+      p->r1 = FIRST_FPR+8;
+      p->r2 = FIRST_FPR+9;
+      return 1;
+    case FIRST_DOUBLE+5:
+      p->r1 = FIRST_FPR+10;
+      p->r2 = FIRST_FPR+11;
+      return 1;
+    case FIRST_DOUBLE+6:
+      p->r1 = FIRST_FPR+12;
+      p->r2 = FIRST_FPR+13;
+      return 1;
+    case FIRST_DOUBLE+7:
+      p->r1 = FIRST_FPR+14;
+      p->r2 = FIRST_FPR+15;
+      return 1;
+    default:
+      ierror(0);
+  }
+
+  return 0;
+}
+
+
+int cost_savings(struct IC *p,int r,struct obj *o)
+/* estimate the cost-saving if object o from IC p is placed in */
+/* register r                                                  */
+{
+  int c = p->code;
+
+  /* @@@ FIXME */
+  if (o->flags & VKONST) {
+    if (o==&p->q1 && p->code==ASSIGN && (p->z.flags&DREFOBJ))
+      return 4;
+    else
+      return 2;
+  }
+  if (o->flags & DREFOBJ)
+    return 4;
+  if (c==SETRETURN && r==p->z.reg && !(o->flags&DREFOBJ))
+    return 3;
+  if (c==GETRETURN && r==p->q1.reg && !(o->flags&DREFOBJ))
+    return 3;
+  return 2;
+}
+
+
+int regok(int r,int t,int mode)
+/*  Returns 0 if register r cannot store variables of   */
+/*  type t. If t==POINTER and mode!=0 then it returns   */
+/*  non-zero only if the register can store a pointer   */
+/*  and dereference a pointer to mode.                  */
+{
+  if (r==0)
+    return 0;
+
+  if (t==0 && r>=FIRST_CCR && r<=LAST_CCR)
+    return 1;
+
+  t &= NQ;
+
+  if (ISFLOAT(t)) {
+    /* @@@ handle VFP */
+    if (t==FLOAT && r>=FIRST_GPR && r<=LAST_GPR)
+      return 1;
+    else if (r>=FIRST_PAIR && r<=LAST_PAIR)
+      return 1;
+  }
+  else if (t==POINTER && r>=FIRST_GPR && r<=LAST_GPR)
+    return 1;
+  else if (t>=CHAR && t<=LONG && r>=FIRST_GPR && r<=LAST_GPR)
+    return 1;
+  else if (t==LLONG && r>=FIRST_PAIR && r<=LAST_PAIR)
+    return 1;
+
+  return 0;
+}
+
+
+int dangerous_IC(struct IC *p)
+/*  Returns zero if the IC p can be safely executed     */
+/*  without danger of exceptions or similar things.     */
+/*  vbcc may generate code in which non-dangerous ICs   */
+/*  are sometimes executed although control-flow may    */
+/*  never reach them (mainly when moving computations   */
+/*  out of loops).                                      */
+/*  Typical ICs that generate exceptions on some        */
+/*  machines are:                                       */
+/*      - accesses via pointers                         */
+/*      - division/modulo                               */
+/*      - overflow on signed integer/floats             */
+{
+  if ((p->q1.flags&DREFOBJ) || (p->q2.flags&DREFOBJ) || (p->z.flags&DREFOBJ))
+    return 1;
+  /* ARM has no division/modulo instructions */
+  return 0;
+}
+
+
+int must_convert(int o,int t,int const_expr)
+/*  Returns zero if code for converting np to type t    */
+/*  can be omitted.                                     */
+/*  On the PowerPC cpu pointers and 32bit               */
+/*  integers have the same representation and can use   */
+/*  the same registers.                                 */
+{
+  int op = o & NQ;
+  int tp = t & NQ;
+
+  if ((op==INT||op==LONG||op==POINTER) && (tp==INT||tp==LONG||tp==POINTER))
+    return 0;
+  if (op==DOUBLE && tp==LDOUBLE)
+    return 0;
+  if (op==LDOUBLE && tp==DOUBLE)
+    return 0;
+  if(op==tp)
+    return 0;
+  return 1;
+}
+
+
+char *use_libcall(np p)
+/* Return name of library function, if this node should be
+   implemented via libcall. */
+{
+  static char fname[16];
+  char *ret = NULL;
+  int f = p->ntyp->flags & NU;
+
+  if ((f&NQ) == LLONG) {
+    ierror(0);  /* @@@ FIXME */
+  }
+
+  else if ((((p->flags==MULT || p->flags==PMULT) && aa<AA2) ||
+           (p->flags>MULT && p->flags<=MOD)) && (f&NQ) <= LONG) {
+    if ((f&UNSIGNED) && (p->flags==DIV || p->flags==MOD))
+      sprintf(fname,"__%s",ename[p->flags]);
+    else
+      sprintf(fname,"__%ss",ename[p->flags==PMULT?MULT:p->flags]);
+    ret = fname;
+  }
+
+  if (ret) {
+    /* declare function if necessary */
+    struct struct_declaration *sd;
+    struct Typ *t;
+    struct Var *v;
+
+    if (!find_ext_var(ret)) {
+      sd = mymalloc(sizeof(*sd));
+      sd->count = 0;
+      t = new_typ();
+      t->flags = FUNKT;
+      t->exact = add_sd(sd,FUNKT);
+      t->next = clone_typ(p->ntyp);
+      add_var(ret,t,EXTERN,0);  
+    }
+  }
+
+  return ret;
+}
+
+
+void gen_ds(FILE *f,zmax size,struct Typ *t)
+/*  This function has to create <size> bytes of storage */
+/*  initialized with zero.                              */
+{
+  title(f);
+
+  if (newobj && section!=SPECIAL)
+    emit(f,"%ld\n",zm2l(size));
+  else
+    emit(f,"\t.space\t%ld\n",zm2l(size));
+
+  newobj = 0;
+}
+
+
+void gen_align(FILE *f,zmax align)
+/*  This function has to make sure the next data is     */
+/*  aligned to multiples of <align> bytes.              */
+{
+  title(f);
+
+  if (zm2l(align) > 1)
+    emit(f,"\t.align\t2\n");
+}
+
+
+void gen_var_head(FILE *f,struct Var *v)
+/*  This function has to create the head of a variable  */
+/*  definition, i.e. the label and information for      */
+/*  linkage etc.                                        */
+{
+  int constflag;
+  char *sec;
+
+  title(f);
+
+  if(v->clist)
+    constflag = is_const(v->vtyp);
+
+  if (isstatic(v->storage_class)) {
+    if (ISFUNC(v->vtyp->flags))
+      return;
+    if (!special_section(f,v)) {
+      if (v->clist && (!constflag || CONST_IN_DATA) && section!=DATA) {
+        emit(f,dataname);
+        if (f)
+          section = DATA;
+      }
+      if (v->clist && constflag && !CONST_IN_DATA && section!=RODATA) {
+        emit(f,rodataname);
+        if (f)
+          section = RODATA;
+      }
+      if (!v->clist && section!=BSS) {
+        emit(f,bssname);
+        if (f)
+          section = BSS;
+      }
+    }
+    if (v->clist || section==SPECIAL) {
+      gen_align(f,falign(v->vtyp));
+      emit(f,"%s%ld:\n",labprefix,zm2l(v->offset));
+    }
+    else
+      emit(f,"\t.lcomm\t%s%ld,",labprefix,zm2l(v->offset));
+    newobj = 1;
+  }
+
+  if (isextern(v->storage_class)) {
+    emit(f,"\t.globl\t%s%s\n",idprefix,v->identifier);
+    if (v->flags & (DEFINED|TENTATIVE)) {
+      if (!special_section(f,v)) {
+        if (v->clist && (!constflag || CONST_IN_DATA) && section!=DATA) {
+          emit(f,dataname);
+          if(f)
+            section = DATA;
+        }
+        if (v->clist && constflag && !CONST_IN_DATA && section!=RODATA) {
+          emit(f,rodataname);
+          if (f)
+            section = RODATA;
+        }
+        if (!v->clist && section!=BSS) {
+          emit(f,bssname);
+          if (f)
+            section = BSS;
+        }
+      }
+      if (v->clist || section==SPECIAL) {
+        gen_align(f,falign(v->vtyp));
+        emit(f,"%s%s:\n",idprefix,v->identifier);
+      }
+      else {
+        emit(f,"\t.global\t%s%s\n\t.%scomm\t%s%s,",idprefix,
+             v->identifier,(USE_COMMONS?"":"l"),idprefix,v->identifier);
+      }
+      newobj = 1;
+    }
+  }
+}
+
+
+void gen_dc(FILE *f,int t,struct const_list *p)
+/*  This function has to create static storage          */
+/*  initialized with const-list p.                      */
+{
+  title(f);
+
+  if ((t&NQ) == POINTER)
+    t = UNSIGNED|LONG;
+  emit(f,"\t.%s\t",dct[t&NQ]);
+
+  if (!p->tree) {
+    if (ISFLOAT(t)) {
+      unsigned char *ip = (unsigned char *)&p->val.vdouble;
+
+      emit(f,"0x%02x%02x%02x%02x",ip[0],ip[1],ip[2],ip[3]);
+      if ((t&NQ) != FLOAT)
+        emit(f,",0x%02x%02x%02x%02x",ip[4],ip[5],ip[6],ip[7]);
+    }
+    else {
+      emitval(f,&p->val,t&NU);
+    }
+  }
+  else {
+    emit_obj(f,&p->tree->o,t&NU);
+  }
+
+  emitnl(f);
+  newobj = 0;
+}
+
+
+/*  The main code-generation routine.                   */
+/*  f is the stream the code should be written to.      */
+/*  p is a pointer to a doubly linked list of ICs       */
+/*  containing the function body to generate code for.  */
+/*  v is a pointer to the function.                     */
+/*  offset is the size of the stackframe the function   */
+/*  needs for local variables.                          */
+
+void gen_code(FILE *f,struct IC *p,struct Var *v,zmax offset)
+/*  The main code-generation routine.                   */
+{
+  FILE *outfile = f;
+  struct IC *p_start = p;
+  int c,t,i,pass;
+  struct rpair rp;
+
+  if (DEBUG & 1)
+    printf("gen_code()\n");
+
+  current_function = v;
+  icnt = 0;
+  drefptr_array_label = 0;
+  argsize = 0;
+  rsavesize = 0;
+  maxrsaveoffs = 0;
+  needframe = 0;
+
+  for (c=1; c<=MAXR; c++)
+    regs[c] = regsa[c];
+
+  for (p=p_start; p; p=p->next) {
+    c = p->code;
+    t = p->typf & NU;
+
+    if (c == ALLOCREG) {
+      if (reg_pair(p->q1.reg,&rp)) {
+        regs[rp.r1] = 1;
+        regs[rp.r2] = 1;
+      }
+      regs[p->q1.reg] = 1;
+      continue;
+    }
+
+    if (c == FREEREG) {
+      if (reg_pair(p->q1.reg,&rp)) {
+        regs[rp.r1] = 0;
+        regs[rp.r2] = 0;
+      }
+      regs[p->q1.reg] = 0;
+      continue;
+    }
+
+    /* try MULT/DIV/MOD with powers of two */
+    if ((c==MULT || ((c==DIV || c==MOD) && (t&UNSIGNED))) &&
+        (t&NQ)<=LONG && isconst(p->q2.flags)) {
+      eval_const(&p->q2.val,t);
+      if (i = pof2(vmax)) {
+        if (c == MOD) {
+          vmax = zmsub(vmax,l2zm(1L));
+          p->code = AND;
+        }
+        else {
+          vmax = l2zm(i-1);
+          p->code = c==DIV ? RSHIFT : LSHIFT;
+        }
+        c = p->code;
+        gval.vmax = vmax;
+        eval_const(&gval,MAXINT);
+        if (c == AND) {
+          insert_const(&p->q2.val,t);
+        }
+        else {
+          insert_const(&p->q2.val,INT);
+          p->typf2 = INT;
+        }
+      }
+    }
+
+    if (c == CALL) {
+      needframe = 1;
+      if (argsize < zm2l(pushedargsize(p)))
+        argsize = zm2l(pushedargsize(p));  /* set max argsize */
+    }
+  }
+
+  /*peephole(p); @@@ FIXME */
+
+  for (c=i; i<=MAXR; i++) {
+    if (regsa[i] || regused[i])
+      BSET(regs_modified,i);
+    if (!regsa[i] && !regscratch[i] && regused[i])
+      needframe = 1;
+  }
+
+  /* determine word-aligned space for local variables */
+  localsize = ((zm2l(offset) + 3) / 4) * 4;
+  if (localsize > 0)
+    needframe = 1;
+
+  for (pass=0,f=NULL; pass<2; pass++,f=outfile) {
+    struct IC my_ic;
+    struct IC *p2;
+
+    if (pass) {
+      emit_dataptr_array(NULL);  /* reset ptr-array */
+      icnt = 0;
+      function_top(f,v,argsize+localsize);
+    }
+
+    pushoffs = 0;
+
+    for (p2=p_start; p2; p2=p2->next) {
+      if (pass) {
+        p = p2;
+      }
+      else {  /* work on a copy in first pass */
+        p = &my_ic;
+        *p = *p2;
+      }
+
+      c = p->code;
+      t = p->typf;
+
+      cg_freeall(f);  /* reset internal register allocations */
+
+      if (icnt > MAXCODELINES) {
+        /* function has grown too big, emit all data-reference pointers first */
+        emit(f,"\tb\t%s%d\n",labprefix,++label);
+        emit_dataptr_array(f);
+        emit(f,"%s%d:\n",labprefix,label);
+        icnt = 0;
+      }
+
+      if (c == NOP) {
+        p->z.flags = 0;
+        continue;
+      }
+
+      if (c == ALLOCREG) {
+        if (reg_pair(p->q1.reg,&rp)) {
+          regs[rp.r1] = 1;
+          regs[rp.r2] = 1;
+        }
+        regs[p->q1.reg] = 1;
+        continue;
+      }
+
+      if (c == FREEREG) {
+        if (reg_pair(p->q1.reg,&rp)) {
+          regs[rp.r1] = 0;
+          regs[rp.r2] = 0;
+        }
+        regs[p->q1.reg] = 0;
+        continue;
+      }
+
+      if (c == LABEL) {
+        emit(f,"%s%d:\n",labprefix,t);
+        continue;
+      }
+
+      if (c == BRA) {
+        if (t==exit_label && framesize==0)
+          emit(f,ret);
+        else
+          emit(f,"\tb\t%s%d\n",labprefix,t);
+        continue;
+      }
+
+      if (c>=BEQ && c<BRA) {
+        emit(f,"\tb%s\t",ccs[c-BEQ]);
+        if (isreg(p->q1.flags)) {
+          ierror(0);  /* @@@ was ist das? */
+          emit_obj(f,&p->q1,0);
+          emit(f,",");
+        }
+        emit(f,"%s%d\n",labprefix,t);
+        continue;
+      }
+
+      if (c == MOVETOREG) {
+        if (p->z.reg>=FIRST_GPR && p->z.reg<=LAST_GPR) {
+          load_reg(f,p,p->z.reg,&p->q1,t);
+        }
+        else if (reg_pair(p->z.reg,&rp)) {
+          BSET(regs_modified,p->z.reg);
+          load_regpair(f,p,&rp,&p->q1,t);
+        }
+        else
+          ierror(0);  /* @@@ VFP registers */
+        p->z.flags = 0;
+        continue;
+      }
+
+      if (c == MOVEFROMREG) {
+        if (p->q1.reg>=FIRST_GPR && p->q1.reg<=LAST_GPR) {
+          store_reg(f,p,p->q1.reg,&p->z,t);
+        }
+        else if (reg_pair(p->q1.reg,&rp)) {
+          store_regpair(f,p,&rp,&p->z,t);
+        }
+        else
+          ierror(0);  /* @@@ VFP registers */
+        p->z.flags = 0;
+        continue;
+      }
+
+      if ((c==ASSIGN || c==PUSH) &&
+          ((t&NQ)>POINTER || ((t&NQ)==CHAR && zm2l(opsize(p))!=1))) {
+        cg_memcopy(f,p);
+        p->z.flags = 0;
+        continue;
+      }
+
+      p = preload(f,p);
+      c = p->code;
+
+      if (c == SUBPFP)
+        c = SUB;
+      else if (c == ADDI2P)
+        c = ADD;
+      else if (c == SUBIFP)
+        c = SUB;
+
+      if (c == CONVERT) {
+        if (ISFLOAT(q1typ(p)) || ISFLOAT(ztyp(p)))   /* @@@ */
+          ierror(0);
+
+        if (sizetab[q1typ(p)&NQ] < sizetab[ztyp(p)&NQ]) {
+          int sh = 0;
+
+          if ((q1typ(p)&NQ) == CHAR)
+            sh = 24;
+          else if ((q1typ(p)&NQ) == SHORT)
+            sh = 16;
+          else if (sizetab[ztyp(p)&NQ] > 4)
+            ierror(0);  /* @@@ */
+
+          if (sh) {
+            registerize(f,p,&p->q1,q1typ(p));
+            emit(f,"\tmov\t%s,%s,lsl #%d\n",regnames[zreg],regnames[p->q1.reg],sh);
+            emit(f,"\tmov\t%s,%s,%csr #%d\n",regnames[zreg],regnames[zreg],
+                                             (q1typ(p)&UNSIGNED)?'l':'a',sh);
+          }
+        }
+        save_result(f,p);
+        continue;
+      }
+
+      if (c == KOMPLEMENT) {
+        registerize(f,p,&p->q1,t);
+        emit(f,"\tmvn\t%s,%s\n",regnames[zreg],regnames[p->q1.reg]);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c == SETRETURN) {
+        load_reg(f,p,p->z.reg,&p->q1,t);
+        BSET(regs_modified,p->z.reg);
+        continue;
+      }
+
+      if (c == GETRETURN) {
+        if (p->q1.reg) {  /* REG-flag is not set!? */
+          zreg = p->q1.reg;
+          save_result(f,p);
+        }
+        else
+          p->z.flags = 0;
+        continue;
+      }
+
+      if (c == CALL) {
+        if ((p->q1.flags & (VAR|DREFOBJ))==VAR &&
+            p->q1.v->fi && p->q1.v->fi->inline_asm) {
+          emit_inline_asm(f,p->q1.v->fi->inline_asm);
+        }
+        else if (p->q1.flags & DREFOBJ) {
+          int reg;
+
+          if (p->q1.flags & REG) {
+            reg = p->q1.reg;
+          }
+          else {
+            reg = cg_getreg(f,p);
+            load_reg(f,p,reg,&p->q1,POINTER);
+          }
+          emit(f,"\tmov\t%s,%s\n",regnames[lr],regnames[pc]);
+          if (aa < AA4T)
+            emit(f,"\tmov\t%s,%s\n",regnames[pc],regnames[reg]);
+          else
+            emit(f,"\tbx\t%s\n",regnames[reg]);
+        }
+        else {
+          emit(f,"\tbl\t");
+          emit_obj(f,&p->q1,t);
+          emitnl(f);
+        }
+
+        pushoffs -= zm2l(pushedargsize(p));
+
+        if ((p->q1.flags & (VAR|DREFOBJ))==VAR &&
+            p->q1.v->fi && (p->q1.v->fi->flags & ALL_REGS)) {
+          bvunite(regs_modified,p->q1.v->fi->regs_modified,RSIZE);
+        }
+        else{
+          int i;
+
+          for (i=1; i<=MAXR; i++) {
+            if (regscratch[i])
+              BSET(regs_modified,i);
+          }
+        }
+        continue;
+      }
+
+      if (c == PUSH) {
+        if (t == 0)
+          ierror(0);
+        registerize(f,p,&p->q1,t);
+        emit(f,"\tstr\t%s,[%s,#%ld]\n",
+             regnames[p->q1.reg],regnames[sp],pushoffs);
+        pushoffs += zm2l(opsize(p));
+        continue;
+      }
+
+      if (c == ASSIGN) {
+        if (t == 0)
+          ierror(0);
+        if (isreg(p->q1.flags))
+          zreg = p->q1.reg;
+        else
+          load_reg(f,p,zreg,&p->q1,t);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c == ADDRESS) {
+        load_address(f,zreg,&p->q1,POINTER);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c == MINUS) {
+        registerize(f,p,&p->q1,t);
+        emit(f,"\trsb\t%s,%s,#0\n",regnames[zreg],regnames[p->q1.reg]);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c == TEST) {
+        registerize(f,p,&p->q1,t);
+        emit(f,"\tteq\t%s,#0\n",regnames[p->q1.reg]);
+        continue;
+      }
+
+      if (c == COMPARE) {
+        if (!isconst(p->q1.flags))
+          registerize(f,p,&p->q1,t);
+        emit(f,"\tcmp\t%s,",regnames[p->q1.reg]);
+        emit_obj(f,&p->q2,t);
+        emitnl(f);
+        continue;
+      }
+
+      if ((c>=OR && c<=AND)) {
+        registerize(f,p,&p->q1,t);
+        if (!isconst(p->q2.flags))
+          registerize(f,p,&p->q2,t);
+        emit(f,"\t%s\t%s,%s,",logicals[c-OR],regnames[zreg],
+             regnames[p->q1.reg]);
+        emit_obj(f,&p->q2,t);
+        emitnl(f);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c>=LSHIFT && c<=RSHIFT) {
+        registerize(f,p,&p->q1,t);
+        if (!isconst(p->q2.flags))
+          registerize(f,p,&p->q2,t);
+        emit(f,"\tmov\t%s,%s,%s ",regnames[zreg],regnames[p->q1.reg],
+             shifts[(t&UNSIGNED)!=0][c-LSHIFT]);
+        emit_obj(f,&p->q2,t);
+        emitnl(f);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c>=ADD && c<=SUB) {
+        registerize(f,p,&p->q1,t);
+        if (!isconst(p->q2.flags))
+          registerize(f,p,&p->q2,t);
+        emit(f,"\t%s\t%s,%s,",c==ADD?"add":"sub",
+             regnames[zreg],regnames[p->q1.reg]);
+        emit_obj(f,&p->q2,t);
+        emitnl(f);
+        save_result(f,p);
+        continue;
+      }
+
+      if (c==MULT && aa>=AA2 && sizetab[t&NQ]<=4) {
+        registerize(f,p,&p->q1,t);
+        registerize(f,p,&p->q2,t);
+        emit(f,"\tmul\t%s,%s,%s\n",
+             regnames[zreg],regnames[p->q1.reg],regnames[p->q2.reg]);
+        save_result(f,p);
+        continue;
+      }
+
+      if (pass) {
+        pric2(stdout,p);
+        ierror(0);
+      }
+    }
+  }
+
+  cg_freeall(f);
+  function_bottom(f,v,argsize+localsize+rsavesize);
+
+#if 0  /* @@@ wozu? */
+  if (stack_valid) {
+    if (!v->fi)
+      v->fi = new_fi();
+    v->fi->flags |= ALL_STACK;
+    v->fi->stack1 = stack;
+  }
+  emit(f,"; stacksize=%lu%s\n",zum2ul(stack),stack_valid?"":"+??");
+#endif
+}
+
+
+int shortcut(int code,int typ)
+{
+  return 0;
+}
+
+
+int reg_parm(struct reg_handle *m, struct Typ *t,int vararg,struct Typ *d)
+{
+  int f;
+
+  if (!m || !t)
+    ierror(0);
+
+  f = t->flags & NQ;
+
+  if (f<=LONG || f==POINTER) {
+    if (m->gregs >= GPR_ARGS)
+      return 0;
+    else
+      return FIRST_GPR + m->gregs++;
+  }
+
+  if (f == LLONG) {
+    if (m->gregs >= GPR_ARGS-1)
+      return 0;
+    else
+      ierror(0);  /* @@@ check ABI if odd registers are skipped!? */
+  }
+
+  if (ISFLOAT(f)) {
+#if 0 /* @@@ VFP only! */
+    if (m->fregs >= FPR_ARGS)
+      return 0;
+    else
+      return FIRST_DOUBLE + m->fregs++;
+#endif
+  }
+
+  return 0;
+}
+
+
+int emit_peephole(void)
+/* This function will not optimize anything, but just update the
+   number of lines counter, icnt, for the current function.
+   It is required to estimate if a data-reference-pointer array
+   is still reachable with a 12-bit offset. */
+{
+  int entries;
+
+  entries = emit_f ? EMIT_BUF_DEPTH : emit_l - emit_f + 1;
+  icnt += entries;
+  return 0;
+}
+
+
+int handle_pragma(const char *s)
+{
+  return 0;
+}
+
+
+void cleanup_cg(FILE *f)
+{
+}
+
+
+void cleanup_db(FILE *f)
+{
+  if (f)
+    section = -1;
+}
diff -Naur vbcc/machines/arm/machine.dt /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.dt
--- vbcc/machines/arm/machine.dt	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.dt	Tue Sep 22 04:18:49 2015
@@ -0,0 +1,16 @@
+S8BS
+S8BU
+S16BSLE S16BSBE
+S16BULE S16BUBE
+S32BSLE S32BSBE
+S32BULE S32BUBE
+S32BSLE S32BSBE
+S32BULE S32BUBE
+S64BSLE S64BSBE
+S64BULE S64BUBE
+S32BIEEELE
+S64BIEEELE
+S64BIEEELE
+S32BULE S32BUBE
+
+
diff -Naur vbcc/machines/arm/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.h
--- vbcc/machines/arm/machine.h	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/arm/machine.h	Tue Sep 22 04:18:49 2015
@@ -0,0 +1,141 @@
+/*
+ * ARM code generator
+ * Written by Frank Wille <frank@phoenix.owl.de>
+ */
+
+/* built-time configurable options: */
+#define NUM_GPRS 16
+#define NUM_FPRS 16
+#define NUM_CCRS 1
+#define NUM_PAIRS 13
+
+#include "dt.h"
+
+/* internally used by the backend */
+#define FIRST_GPR 1
+#define LAST_GPR (FIRST_GPR+NUM_GPRS-1)
+#define FIRST_FPR (LAST_GPR+1)
+#define LAST_FPR (FIRST_FPR+NUM_FPRS-1)
+#define FIRST_CCR (LAST_FPR+1)
+#define LAST_CCR (FIRST_CCR+NUM_CCRS-1)
+#define FIRST_PAIR (LAST_CCR+1)
+#define FIRST_DOUBLE (FIRST_PAIR+5)
+#define LAST_PAIR (FIRST_PAIR+NUM_PAIRS-1)
+
+
+/*  This struct can be used to implement machine-specific           */
+/*  addressing-modes.                                               */
+/*  Currently possible are (const,gpr) and (gpr,gpr)                */
+struct AddressingMode{
+    int never_used;
+};
+
+/*  The number of registers of the target machine.                  */
+#define MAXR NUM_GPRS+NUM_FPRS+NUM_CCRS+NUM_PAIRS
+
+/*  Number of commandline-options the code-generator accepts.       */
+#define MAXGF 10
+
+/*  If this is set to zero vbcc will not generate ICs where the     */
+/*  target operand is the same as the 2nd source operand.           */
+/*  This can sometimes simplify the code-generator, but usually     */
+/*  the code is better if the code-generator allows it.             */
+#define USEQ2ASZ 1
+
+/*  This specifies the smallest integer type that can be added to a */
+/*  pointer.                                                        */
+#define MINADDI2P INT
+
+/*  This specifies the largest integer type that can be added to a  */
+/*  pointer.                                                        */
+#define MAXADDI2P LONG
+
+/*  If the bytes of an integer are ordered most significant byte    */
+/*  byte first and then decreasing set BIGENDIAN to 1.              */
+#define BIGENDIAN (!arm_le_mode)
+
+/*  If the bytes of an integer are ordered lest significant byte    */
+/*  byte first and then increasing set LITTLEENDIAN to 1.           */
+#define LITTLEENDIAN (arm_le_mode)
+
+extern int arm_le_mode;
+/*  Note that BIGENDIAN and LITTLEENDIAN are mutually exclusive.    */
+
+/*  If switch-statements should be generated as a sequence of       */
+/*  SUB,TST,BEQ ICs rather than COMPARE,BEQ ICs set this to 1.      */
+/*  This can yield better code on some machines.                    */
+#define SWITCHSUBS 0
+
+/*  In optimizing compilation certain library memcpy/strcpy-calls   */
+/*  with length known at compile-time will be inlined using an      */
+/*  ASSIGN-IC if the size is less or equal to INLINEMEMCPY.         */
+/*  The type used for the ASSIGN-IC will be UNSIGNED|CHAR.          */
+#define INLINEMEMCPY 1024
+
+/*  Parameters are sometimes passed in registers without __reg.     */
+#define HAVE_REGPARMS 1
+
+/*  Parameters on the stack should be pushed in order rather than   */
+/*  in reverse order.                                               */
+#define ORDERED_PUSH 1
+
+/*  Structure for reg_parm().                                       */
+struct reg_handle{
+    unsigned long gregs;
+    unsigned long fregs;
+};
+
+/*  Number registers used for function arguments */
+#define GPR_ARGS 4
+#define FPR_ARGS 4
+
+/*  We have some target-specific variable attributes.               */
+#define HAVE_TARGET_ATTRIBUTES
+
+/* We have no target-specific pragmas */
+#undef HAVE_TARGET_PRAGMAS
+
+/*  We keep track of all registers modified by a function.          */
+#define HAVE_REGS_MODIFIED 1
+
+/* We have to implement our own cost-functions to adapt 
+   register-allocation */
+#define HAVE_TARGET_RALLOC 1
+#define cost_move_reg(x,y) 1
+#define cost_load_reg(x,y) 2
+#define cost_save_reg(x,y) 2
+#define cost_pushpop_reg(x) 3
+
+/* size of buffer for asm-output, this can be used to do
+   peephole-optimizations of the generated assembly-output */
+#define EMIT_BUF_LEN 1024 /* should be enough */
+/* number of asm-output lines buffered */
+#define EMIT_BUF_DEPTH 4
+
+/*  We have asm_peephole to optimize assembly-output */
+#define HAVE_TARGET_PEEPHOLE 1
+
+/* we do not have a mark_eff_ics function, this is used to prevent
+   optimizations on code which can already be implemented by efficient
+   assembly */
+#undef HAVE_TARGET_EFF_IC
+
+/* we only need the standard data types (no bit-types, different pointers
+   etc.) */
+#undef HAVE_EXT_TYPES
+#undef HAVE_TGT_PRINTVAL
+
+/* we do not need extra elements in the IC */
+#undef HAVE_EXT_IC
+
+/* we do not use unsigned int as size_t (but unsigned long, the default) */
+#undef HAVE_INT_SIZET
+
+/* we have register-pairs */
+#define HAVE_REGPAIRS 1
+
+#define JUMP_TABLE_DENSITY 0.8
+#define JUMP_TABLE_LENGTH 12
+
+/* We use builtin libcalls for some operations */
+#define HAVE_LIBCALLS 1
diff -Naur vbcc/machines/bi386/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.c
--- vbcc/machines/bi386/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.c	Thu Jan  1 00:00:00 1970
@@ -1,1446 +0,0 @@
-/*  Code generator for Intel 80386 or higher.			*/
-
-#include "supp.h"
-
-/* Was gehoert hier hin? */
-#define N_SO 128
-#define N_LSYM 128
-#define N_FUN 36
-#define N_PSYM 128
-
-static char FILE_[]=__FILE__;
-
-/*  Public data that MUST be there.				*/
-
-/* Name and copyright. */
-char cg_copyright[]="vbcc code-generator for i386/BE V0.1 (c) in 1997 by Volker Barthelmann";
-
-/*  Commandline-flags the code-generator accepts		*/
-int g_flags[MAXGF]={VALFLAG,VALFLAG,0,0,
-		    0,0,0,0,
-                    0};
-char *g_flags_name[MAXGF]={"cpu","fpu","no-delayed-popping","const-in-data",
-			   "merge-constants","elf","longalign","use-framepointer",
-                           "g"};
-union ppi g_flags_val[MAXGF];
-
-/*  Alignment-requirements for all types in bytes.		*/
-zlong align[16];
-
-/*  Alignment that is sufficient for every object.		*/
-zlong maxalign;
-
-/*  CHAR_BIT of the target machine.				*/
-zlong char_bit;
-
-/*  Sizes of all elementary types in bytes.			*/
-zlong sizetab[16];
-
-/*  Minimum and Maximum values each type can have.		*/
-/*  Must be initialized in init_cg().                           */
-zlong t_min[32];
-zulong t_max[32];
-
-/*  Names of all registers.					*/
-char *regnames[MAXR+1]={"noreg","%eax","%ecx","%edx","%ebx",
-				"%esi","%edi","%ebp","%esp",
-				"%st(0)","%st(1)","%st(2)","%st(3)",
-				"%st(4)","%st(5)","%st(6)","%st(7)"};
-
-/*  The Size of each register in bytes. 			*/
-zlong regsize[MAXR+1];
-
-/*  regsa[reg]!=0 if a certain register is allocated and should */
-/*  not be used by the compiler pass.				*/
-int regsa[MAXR+1];
-
-/*  Specifies which registers may be scratched by functions.	*/
-int regscratch[MAXR+1]={0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1};
-
-
-/****************************************/
-/*  Some private data and functions.	*/
-/****************************************/
-
-static long malign[16]={1,1,2,2,2,2,2,2,2,2,2,2,2,2,2};
-static long msizetab[16]={0,1,2,4,4,4,8,0,4,0,0,0,4,0};
-
-
-#define DATA 0
-#define BSS 1
-#define CODE 2
-
-static int section=-1,newobj;
-static char *codename="\t.text\n",*dataname="\t.data\n",*bssname="";
-static int is_const(struct Typ *);
-static const int ax=1,cx=2,dx=3,bx=4,si=5,di=6,bp=7,sp=8;
-static char x_t[]={'?','b','w','l','l','s','l','v','l','a','s','u','e','f','?','?'};
-static int is_const(struct Typ *);
-static void pr(FILE *,struct IC *);
-static void function_top(FILE *,struct Var *,long);
-static void function_bottom(FILE *f,struct Var *,long);
-
-#define isreg(x) ((p->x.flags&(REG|DREFOBJ))==REG)
-
-static long loff,stackoffset,notpopped,dontpop;
-
-static char *ccs[]={"z","nz","l","ge","le","g","mp"};
-static char *ccu[]={"z","nz","b","ae","be","a","mp"};
-static char *logicals[]={"or","xor","and"};
-static char *arithmetics[]={"sal","sar","add","sub","imul","div","mod"};
-static char *farithmetics[]={"f?","f?","fadd","fsub","fmul","fdiv","fsubr","fdivr"};
-static char *dct[]={"","byte","short","long","long","long","long","long","long"};
-static pushedsize,pushorder=2;
-static int fst[8];
-static int cxl,dil,sil;
-static char *idprefix="_",*labprefix="l";
-
-static struct fpconstlist {
-    struct fpconstlist *next;
-    int label,typ;
-    union atyps val;
-} *firstfpc;
-
-static int addfpconst(struct obj *o,int t)
-{
-    struct fpconstlist *p=firstfpc;
-    t&=NQ;
-    if(g_flags[4]&USEDFLAG){
-	for(p=firstfpc;p;p=p->next){
-	    if(t==p->typ){
-		eval_const(&p->val,t);
-		if(t==FLOAT&&zdeqto(vdouble,zf2zd(o->val.vfloat))) return(p->label);
-		if(t==DOUBLE&&zdeqto(vdouble,o->val.vdouble)) return(p->label);
-	    }
-	}
-    }
-    p=mymalloc(sizeof(struct fpconstlist));
-    p->next=firstfpc;
-    p->label=++label;
-    p->typ=t;
-    p->val=o->val;
-    firstfpc=p;
-    return(p->label);
-}
-
-void title(FILE *f)
-{
-  static int done;
-  extern char *inname; /*grmpf*/
-  if(!done&&f){
-    done=1;
-    emit(f,"\t.file\t\"%s\"\n",inname);
-  }
-} 
-
-static void probj2(FILE *f,struct obj *p,int t)
-/*  Gibt Objekt auf Bildschirm aus			*/
-{
-    if((p->flags&(DREFOBJ|REG))==(DREFOBJ|REG)) fprintf(f,"(");
-    if(p->flags&VARADR) fprintf(f,"$");
-    if((p->flags&VAR)&&!(p->flags&REG)) {
-	if(p->v->storage_class==AUTO||p->v->storage_class==REGISTER){
-	    if(p->v->offset<0) fprintf(f,"%ld(%%esp)",(long)(loff-zl2l(p->v->offset)+zl2l(p->val.vlong))-stackoffset+pushedsize);
-		else	       fprintf(f,"%ld(%%esp)",(long)(zl2l(p->v->offset)+zl2l(p->val.vlong)-stackoffset));
-	}else{
-	    if(!zleqto(l2zl(0L),p->val.vlong)){printval(f,&p->val,LONG,0);fprintf(f,"+");}
-	    if(p->v->storage_class==STATIC&&(p->v->vtyp->flags&NQ)!=FUNKT){
-		fprintf(f,"%s%ld",labprefix,zl2l(p->v->offset));
-	    }else{
-		fprintf(f,"%s%s",idprefix,p->v->identifier);
-	    }
-	}
-    }
-    if(p->flags&REG){
-	if(p->reg>8){
-	    int i;
-	    for(i=0;i<8;i++){
-		if(fst[i]==p->reg)
-		    fprintf(f,"%s",regnames[i+9]);
-	    }
-	}else{
-	    fprintf(f,"%s",regnames[p->reg]);
-	}
-    }
-    if(p->flags&KONST){
-	if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-	    fprintf(f,"%s%d",labprefix,addfpconst(p,t));
-	}else{
-	    fprintf(f,"$");printval(f,&p->val,t&NU,0);
-	}
-    }
-    if((p->flags&(DREFOBJ|REG))==(DREFOBJ|REG)) fprintf(f,")");
-}
-static void fxch(FILE *f,int i)
-{
-    int m;
-    fprintf(f,"\tfxch\t%s\n",regnames[i+9]);
-    m=fst[0];fst[0]=fst[i];fst[i]=m;
-}
-static int freest(void)
-{
-    int i;
-    for(i=0;i<8;i++){
-	if(fst[i]<0) return(i);
-    }
-    for(i=0;i<8;i++){
-	if(fst[i]==0) return(i);
-    }
-    ierror(0);
-}
-static void fpush(FILE *f)
-{
-    int i;
-    if(fst[7]>0){
-	i=freest();
-	if(fst[i]==0) fprintf(f,"\tffree\t%s\n",regnames[i+9]);
-	fxch(f,i);fxch(f,7);
-    }
-    for(i=7;i>0;i--)
-	fst[i]=fst[i-1];
-    fst[0]=-1;
-}
-static void fpop(void)
-{
-    int i;
-/*    if(fst[0]>0&&regs[fst[0]]) ierror(0);*/
-    for(i=0;i<7;i++)
-	fst[i]=fst[i+1];
-    fst[7]=-1;
-}
-static void fload(FILE *f,struct obj *o,int t)
-{
-    fprintf(f,"\tfld");
-    if((o->flags&(REG|DREFOBJ))==REG) fprintf(f,"\t");
-	else fprintf(f,"%c\t",x_t[t&NQ]);
-    probj2(f,o,t);fprintf(f,"\n");
-    fpush(f);
-}
-static void fstore(FILE *f,struct obj *o,int t)
-{
-    int i;
-    if((o->flags&(REG|DREFOBJ))==REG){
-	for(i=0;i<8;i++)
-	    if(fst[i]==o->reg) fst[i]=-1;
-	fst[0]=o->reg;
-    }else{
-	fprintf(f,"\tfstp%c\t",x_t[t&NQ]);probj2(f,o,t);
-	fpop();fprintf(f,"\n");
-    }
-}
-static void prfst(FILE *f,char *s)
-{
-    int i;
-    if(DEBUG==0) return;
-    fprintf(f,"*\t%s\t",s);
-    for(i=0;i<8;i++){
-	if(fst[i]>=0){
-	    if(fst[i]==0) fprintf(f,"+++ ");
-	      else	  fprintf(f,"%s ",regnames[fst[i]]+3);
-	}else{
-	    fprintf(f,"--- ");
-	}
-    }
-    fprintf(f,"\n");
-}
-static void finit(void)
-{
-    int i;
-    for(i=0;i<8;i++){
-	if(regs[i+9])
-	    fst[i]=i+9;
-	else
-	    fst[i]=-1;
-    }
-}
-static void forder(FILE *f)
-{
-    int i,m,unordered;
-    prfst(f,"forder");
-    for(i=0;i<8;i++){
-	if(fst[i]==0){fprintf(f,"\tffree\t%s\n",regnames[i+9]);fst[i]=-1;}
-    }
-oloop:
-    unordered=0;
-    for(i=0;i<8;i++){
-	if(fst[i]>0&&fst[i]!=i+9&&regs[fst[i]]){unordered=1;break;}
-    }
-    if(!unordered) return;
-    if(fst[0]>=0&&regs[fst[0]]){
-	if(fst[0]!=9){
-	    fxch(f,fst[0]-9);
-	    goto oloop;
-	}else{
-	    fxch(f,freest());
-	}
-    }
-    for(i=1;i<8;i++){
-	if(fst[i]>=0&&fst[i]!=i+9&&regs[fst[i]]&&fst[i]!=9){
-	    fxch(f,i);
-	    goto oloop;
-	}
-    }
-    if(regs[9]){
-	for(i=1;i<8;i++){
-	    if(fst[i]==9){ fxch(f,i);return;}
-	}
-    }
-}
-static void pr(FILE *f,struct IC *p)
-{
-    int i;
-    for(;pushorder>2;pushorder>>=1){
-	for(i=1;i<=8;i++){
-	    if(regs[i]&pushorder){
-		fprintf(f,"\tpopl\t%s\n",regnames[i]);
-		stackoffset+=4;regs[i]&=~pushorder;
-	    }
-	}
-    }
-    for(i=1;i<=8;i++)
-	if(regs[i]&2) regs[i]&=~2;
-}
-
-/*ADA*/
-static int local_debug_line_count;
-static int local_debug_func_count;
-static char * debug_offset_func = NULL;
-
-static void emitdebugline (FILE *f, int line)
-{
-  if(g_flags[8]&USEDFLAG){
-    if (debug_offset_func && line)
-      {
-	/*
-	  Tell GDB that a new line starts here.
-	  
-	  Format: 68,0,<line>,<offset>
-	  
-	  <line> is the current line number
-	  <offset> is the offset to the current function.
-	  */
-	fprintf (f, ".stabn 68,0,%d,%sM%d-%s\n", line, labprefix, local_debug_line_count, debug_offset_func);
-	fprintf (f, "%sM%d:\n", labprefix, local_debug_line_count);
-	local_debug_line_count ++;
-    }
-  }
-}
-
-#ifndef PATH_MAX
-#   define PATH_MAX  1024
-#endif
-
-static int next_free_typeid = 32;
-
-static void begin_file (FILE *f, char *name)
-{
-    char * ptr;
-    char path[PATH_MAX];
-    int len1, len2, t;
-
-    ptr = strrchr (name, '/');
-    if (!ptr)
-	ptr = name-1;
-
-    /* Filename without path */
-    fprintf (f, "\t.file\t\"%s\"\n", ptr+1);
-    fprintf (f, "\t.version\t\"01.01\"\n");
-
-    getcwd (path, sizeof(path));
-    strcat (path, "/");
-    if (ptr != name-1)
-    {
-	len1 = strlen(path);
-	len2 = ptr-name;
-	strncpy (path+len1, name, len2);
-	path[len1+len2] = 0;
-	strcat (path, "/");
-    }
-
-    /* Emit absolute path to source file and the filename with any
-	path the user gave to the frontend */
-    fprintf (f, "\t.stabs \"%s\",%d,0,0,%stext0\n", path, N_SO, labprefix);
-    fprintf (f, "\t.stabs \"%s\",%d,0,0,%stext0\n", name, N_SO, labprefix);
-    fprintf (f, ".text\n%stext0:\n",labprefix);
-    fprintf (f, "\t.stabs  \"vbcc_compiled.\", 0x3c, 0, 0, 0\n");
-
-    /* Emit types. Format is:
-
-	"<name>:<t#1>=<r#2;min;max;>",128,0,0,0
-
-	128,0,0,0 tells GDB this is a type definition
-	<name> is the name of the symbol.
-	<t#1> is the name of the type and its number
-        <r#2;min;max;> is a range. The min and max values are in the format
-               of the type #2. min and max values for this type can be
-               omitted.
-        void is defined by <t#1=#1>.
-      */
-    for (t=CHAR; t<=LONG; t++)
-      {
-	fprintf (f, ".stabs \"%s:t%d=r%d;%ld;%ld;\",%d,0,0,0\n", typname[t],t,t==CHAR ? CHAR:INT,
-		 zl2l(t_min[t]),zl2l(t_max[t]),N_LSYM);
-	fprintf (f, ".stabs \"unsigned %s:t%d=r%d;%lu;%lu;\",%d,0,0,0\n", typname[t],
-		 t|UNSIGNED, INT,
-		 zul2ul(t_min[t|UNSIGNED]),zul2ul(t_max[t|UNSIGNED]), N_LSYM);
-      }
- 
-    fprintf (f, ".stabs \"float:t%d=r%d;%ld;0;\",%d,0,0,0\n",
-	     FLOAT,INT,zl2l(sizetab[FLOAT]),N_LSYM);
-    fprintf (f, ".stabs \"double:t%d=r%d;%ld;0;\",%d,0,0,0\n",
-	     DOUBLE,INT,zl2l(sizetab[DOUBLE]),N_LSYM);
-    fprintf (f, ".stabs \"void:t%d=r%d\",%d,0,0,0\n",
-	     VOID,VOID,N_LSYM);
-	     
- 
-    /*
-      fprintf (f, ".stabs \"char:t2=r2;0;127;\",128,0,0,0\n");
-      fprintf (f, ".stabs \"int:t1=r1;-2147483648;2147483647;\",128,0,0,0\n");
-      fprintf (f, ".stabs \"long int:t3=r1;-2147483648;2147483647;\",128,0,0,0\n");
-      fprintf (f, ".stabs \"unsigned int:t4=r1;0;-1;\",128,0,0,0\n");
-      fprintf (f, ".stabs \"long unsigned int:t5=r1;0;-1;\",128,0,0,0\n");
-      fprintf (f, ".stabs \"void:t19=19\",128,0,0,0\n");
-      */
-}
-
-static void debug_print_stab_type (FILE *f, struct Typ *typ)
-{
-  int t = typ->flags & NU;
-  
-  if (t <= VOID)
-    fprintf (f, "%d", t);
-  else if (t == ARRAY || t == POINTER)
-    {
-      fprintf (f, "%d=*", next_free_typeid++);
-      debug_print_stab_type (f, typ->next);
-    }
-  else
-    {
-      ierror(t);
-    }
-}
-
-
-static void function_top(FILE *f,struct Var *v,long offset)
-/*  erzeugt Funktionskopf			*/
-{
-    int i;
-    struct struct_declaration *p;
-
-    if(section!=CODE){fprintf(f,codename);section=CODE;}
-
-    /*ADA*/
-    if(g_flags[8]&USEDFLAG){ /*vb*/
-      fprintf (f, "\t.align\t16\n");
-      /* Tell GDB that a new function starts here.
-	 
-	 Format: "<name>:F<type>",36,0,<line>,<symname>
-	 
-	 <name> Is the name of the function
-	 <type> is the return type (only the number as defined above, ie.
-	        if int is t1, then this is 1).
-	 <line> The line in the source
-	 <symname> The name of the symbol as it appears in the object file.
-
-	 Right now, all functions return void.
-	 */
-
-      fprintf (f, ".stabs \"%s:F", v->identifier);
-      debug_print_stab_type (f, v->vtyp->next);
-      fprintf (f, "\",%d,0,%d,%s%s\n", N_FUN, fline, idprefix,v->identifier);
-  
-      p=v->vtyp->exact;
-      for (i=0; i<p->count; i++)
-	{
-	  if((*p->sl)[i].styp->flags==VOID) break;
-	  fprintf (f, ".stabs \"%s:p", (*p->sl)[i].identifier);
-	  debug_print_stab_type (f, (*p->sl)[i].styp);
-	  /* TODO i*4+4 is a crude method to find the offset of a parameter on
-	     the stack */
-	  fprintf (f, "\",%d,0,0,%d\n", N_PSYM, i*4+4);
-	}
-    }
-
-    if(v->storage_class==EXTERN) fprintf(f,"\t.globl\t%s%s\n",idprefix,v->identifier);
-    fprintf(f,"%s%s:\n",idprefix,v->identifier);
-
-    /*ADA*/
-    debug_offset_func=v->identifier;
-
-    for(pushedsize=0,i=1;i<sp;i++){
-	if(regused[i]&&!regscratch[i]){
-	    fprintf(f,"\tpushl\t%s\n",regnames[i]);
-	    pushedsize+=4;
-	}
-    }
-
-    if(offset) fprintf(f,"\tsubl\t$%ld,%%esp\n",offset);
-    if(g_flags[7]&USEDFLAG) fprintf(f,"\tmovl\t%s,%s\n",regnames[sp],regnames[7]);
-    if(g_flags[8]&USEDFLAG){
-      /* Tell GDB that the code of the function starts here */
-      emitdebugline (f,fline);
-      local_debug_func_count ++;
-      fprintf (f, "%sBB%d:\n", labprefix, local_debug_func_count);
-    }
-}
-static void function_bottom(FILE *f,struct Var *v,long offset)
-/*  erzeugt Funktionsende			*/
-{
-    int i;
-    forder(f);
-
-    if(g_flags[8]&USEDFLAG){
-      emitdebugline (f,fline);
-      fprintf (f, "%sBE%d:\n", labprefix, local_debug_func_count);
-    }
-
-    if(offset) fprintf(f,"\taddl\t$%ld,%%esp\n",offset);
-    for(i=sp-1;i>0;i--){
-	if(regused[i]&&!regscratch[i]){
-	    fprintf(f,"\tpopl\t%s\n",regnames[i]);
-	}
-    }
-    fprintf(f,"\tret\n");
-    
-    if(g_flags[8]&USEDFLAG){
-      fprintf (f, "%sfe%d:\n\t.size\t%s,%sfe%d-%s%s\n", labprefix, local_debug_func_count, v->identifier, labprefix, local_debug_func_count, idprefix,v->identifier);
-      /* Tell GDB the real size of the function */
-      fprintf (f, ".stabn 192,0,0,%sBB%d-%s%s\n",labprefix,local_debug_func_count, idprefix,v->identifier);
-      fprintf (f, ".stabn 224,0,0,%sBE%d-%s%s\n", labprefix, local_debug_func_count, idprefix,v->identifier);
-    }
-}
-static int is_const(struct Typ *t)
-/*  Tests if a type can be placed in the code-section.	*/
-{
-    if(!(t->flags&(CONST|STRINGCONST))){
-	do{
-	    if(t->flags&(CONST|STRINGCONST)) return(1);
-	    if((t->flags&NQ)!=ARRAY) return(0);
-	    t=t->next;
-	}while(1);
-    }else return(1);
-}
-static int compare_objects(struct obj *o1,struct obj *o2)
-{
-    if(o1->flags==o2->flags&&o1->am==o2->am){
-	if(!(o1->flags&VAR)||(o1->v==o2->v&&zleqto(o1->val.vlong,o2->val.vlong))){
-	    if(!(o1->flags&REG)||o1->reg==o2->reg){
-		return(1);
-	    }
-	}
-    }
-    return(0);
-}
-static int get_reg(FILE *f,struct IC *p)
-{
-    int i;
-    /*	If we can use a register which was already used by the compiler */
-    /*	or it is a sratch register then we can use it without problems. */
-    for(i=1;i<=8;i++){
-	if(!regs[i]&&(regused[i]||regscratch[i])){
-	    regs[i]=2;
-	    return(i);
-	}
-    }
-    /*	Otherwise we have to save this register.			*/
-    /*	We may not use a register which is used in this IC.		*/
-    for(i=1;i<=8;i++){
-	if(regs[i]<2
-	    &&(!(p->q1.flags&REG)||p->q1.reg!=i)
-	    &&(!(p->q2.flags&REG)||p->q2.reg!=i)
-	    &&(!(p->z.flags&REG)||p->z.reg!=i) ){
-
-	    fprintf(f,"\tpushl\t%s\n",regnames[i]);
-	    /*	Mark register as pushed (taking care of the order). */
-	    pushorder<<=1; regs[i]|=pushorder;
-	    stackoffset-=4;
-	    return(i);
-	}
-    }
-    ierror(0);
-}
-static void move(FILE *f,struct obj *q,int qr,struct obj *z,int zr,int t)
-/*  Generates code to move object q (or register qr) into object z (or  */
-/*  register zr).							*/
-{
-    if(q&&(q->flags&(REG|DREFOBJ))==REG) qr=q->reg;
-    if(z&&(z->flags&(REG|DREFOBJ))==REG) zr=z->reg;
-    if(qr&&zr){
-	if(qr!=zr)
-	    fprintf(f,"\tmovl\t%s,%s\n",regnames[qr],regnames[zr]);
-	return;
-    }
-    if(zr&&(q->flags&KONST)){
-	eval_const(&q->val,t);
-	if(zleqto(vlong,l2zl(0L))&&zuleqto(vulong,ul2zul(0UL))&&zdeqto(vdouble,d2zd(0.0))){
-	    fprintf(f,"\txorl\t%s,%s\n",regnames[zr],regnames[zr]);
-	    return;
-	}
-    }
-    fprintf(f,"\tmov%c\t",x_t[t&NQ]);
-    if(qr) fprintf(f,"%s",regnames[qr]); else probj2(f,q,t);
-    fprintf(f,",");
-    if(zr) fprintf(f,"%s",regnames[zr]); else probj2(f,z,t);
-    fprintf(f,"\n");
-}
-static long pof2(zulong x)
-/*  Yields log2(x)+1 oder 0. */
-{
-    zulong p;int ln=1;
-    p=ul2zul(1L);
-    while(zulleq(p,x)){
-	if(zuleqto(x,p)) return(ln);
-	ln++;p=zuladd(p,p);
-    }
-    return(0);
-}
-
-/****************************************/
-/*  End of private fata and functions.	*/
-/****************************************/
-
-
-int init_cg(void)
-/*  Does necessary initializations for the code-generator. Gets called	*/
-/*  once at the beginning and should return 0 in case of problems.	*/
-{
-    int i;
-
-    /*	Initialize some values which cannot be statically initialized	*/
-    /*	because they are stored in the target's arithmetic.             */
-    maxalign=l2zl(4L);
-    char_bit=l2zl(8L);
-    if(g_flags[6]&USEDFLAG){
-	for(i=SHORT;i<16;i++) malign[i]=4;
-    }
-    for(i=0;i<16;i++){
-	sizetab[i]=l2zl(msizetab[i]);
-	align[i]=l2zl(malign[i]);
-    }
-    for(i=1;i<= 8;i++) regsize[i]=l2zl(4L);
-    for(i=9;i<=16;i++) regsize[i]=l2zl(8L);
-
-    /*	Initialize the min/max-settings. Note that the types of the	*/
-    /*	host system may be different from the target system and you may */
-    /*	only use the smallest maximum values ANSI guarantees if you	*/
-    /*	want to be portable.						*/
-    /*	That's the reason for the subtraction in t_min[INT]. Long could */
-    /*	be unable to represent -2147483648 on the host system.		*/
-    t_min[UNSIGNED|CHAR]=t_min[UNSIGNED|SHORT]=t_min[UNSIGNED|INT]=t_min[UNSIGNED|LONG]=l2zl(0L);
-    t_min[CHAR]=l2zl(-128L);
-    t_min[SHORT]=l2zl(-32768L);
-    t_min[LONG]=zlsub(l2zl(-2147483647L),l2zl(1L));
-    t_min[INT]=t_min[LONG];
-    t_max[CHAR]=ul2zul(127L);
-    t_max[SHORT]=ul2zul(32767UL);
-    t_max[LONG]=ul2zul(2147483647UL);
-    t_max[INT]=t_max[LONG];
-    t_max[UNSIGNED|CHAR]=ul2zul(255UL);
-    t_max[UNSIGNED|SHORT]=ul2zul(65535UL);
-    t_max[UNSIGNED|LONG]=ul2zul(4294967295UL);
-    t_max[UNSIGNED|INT]=t_max[UNSIGNED|LONG];
-    /*	Reserve a few registers for use by the code-generator.	    */
-    /*	We only reserve the stack-pointer here. 		    */
-    regsa[sp]=1;
-    /*  If we are to use a framepointer also reserve %ebp.          */
-    if(g_flags[7]&USEDFLAG) regsa[7]=1;
-    /*	We need at least one free slot in the flaoting point stack  */
-    regsa[16]=1;regscratch[16]=0;
-    /*	Use l%d as labels and _%s as identifiers by default. If     */
-    /*	-elf is specified we use .l%d and %s instead.		    */
-    if(g_flags[5]&USEDFLAG) {labprefix=".L";idprefix="";}
-    return(1);
-}
-
-int freturn(struct Typ *t)
-/*  Returns the register in which variables of type t are returned. */
-/*  If the value cannot be returned in a register returns 0.	    */
-{
-    if((t->flags&NQ)==FLOAT||(t->flags&NQ)==DOUBLE) return 9;
-    if((t->flags&NQ)<=POINTER) return 1;
-    return 0;
-}
-
-int regok(int r,int t,int mode)
-/*  Returns 0 if register r cannot store variables of	*/
-/*  type t. If t==POINTER and mode!=0 then it returns	*/
-/*  non-zero only if the register can store a pointer	*/
-/*  and dereference a pointer to mode.			*/
-{
-    if(r==0) return(0);
-    t&=NQ;
-    if(r>8){
-	if(t==FLOAT||t==DOUBLE) return(1);
-	    else		return(0);
-    }
-    if(t==CHAR&&(r==si||r==di||r==bp)) return(0);
-    if(t<=LONG) return(1);
-    if(t==POINTER) return(1);
-    return(0);
-}
-
-int dangerous_IC(struct IC *p)
-/*  Returns zero if the IC p can be safely executed	*/
-/*  without danger of exceptions or similar things.	*/
-/*  vbcc may generate code in which non-dangerous ICs	*/
-/*  are sometimes executed although control-flow may	*/
-/*  never reach them (mainly when moving computations   */
-/*  out of loops).					*/
-/*  Typical ICs that generate exceptions on some	*/
-/*  machines are:					*/
-/*	- accesses via pointers 			*/
-/*	- division/modulo				*/
-/*	- overflow on signed integer/floats		*/
-{
-    int c=p->code;
-    if((p->q1.flags&DREFOBJ)||(p->q2.flags&DREFOBJ)||(p->z.flags&DREFOBJ))
-	return(0);
-    if((c==DIV||c==MOD)&&!(p->q2.flags&KONST))
-	return(1);
-    return(0);
-}
-
-int must_convert(np p,int t)
-/*  Returns zero if code for converting np to type t	*/
-/*  can be omitted.					*/
-/*  In this generic 32bit RISC cpu pointers and 32bit	*/
-/*  integers have the same representation and can use	*/
-/*  the same registers. 				*/
-{
-    int o=p->ntyp->flags,op=o&NQ,tp=t&NQ;
-    if(tp==POINTER&&op==POINTER) return(0);
-    if((t&UNSIGNED)&&(o&UNSIGNED)&&zleqto(sizetab[tp],sizetab[op])) return(0);
-    if((tp==INT&&op==LONG)||(tp==LONG&&op==INT)) return(0);
-
-    return(1);
-}
-
-void gen_ds(FILE *f,zlong size,struct Typ *t)
-/*  This function has to create <size> bytes of storage */
-/*  initialized with zero.				*/
-{
-  title(f);
-  if(newobj) fprintf(f,"%ld\n",zl2l(size));
-  else fprintf(f,"\t.space\t%ld\n",zl2l(size));
-  newobj=0;
-}
-
-void gen_align(FILE *f,zlong align)
-/*  This function has to make sure the next data is	*/
-/*  aligned to multiples of <align> bytes.		*/
-{
-  title(f);
-  if(!zlleq(align,l2zl(1L))) fprintf(f,"\t.align\t2\n");
-}
-
-void gen_var_head(FILE *f,struct Var *v)
-/*  This function has to create the head of a variable	*/
-/*  definition, i.e. the label and information for	*/
-/*  linkage etc.					*/
-{
-  int constflag;
-  title(f);
-  if(v->clist) constflag=is_const(v->vtyp);
-  if(v->storage_class==STATIC){
-	if((v->vtyp->flags&NQ)==FUNKT) return;
-	if(v->clist&&(!constflag||(g_flags[3]&USEDFLAG))&&section!=DATA){fprintf(f,dataname);section=DATA;}
-	if(v->clist&&constflag&&!(g_flags[3]&USEDFLAG)&&section!=CODE){fprintf(f,codename);section=CODE;}
-	if(!v->clist&&section!=BSS){fprintf(f,bssname);section=BSS;}
-	if(section!=BSS) fprintf(f,"\t.align\t2\n%s%ld:\n",labprefix,zl2l(v->offset));
-	    else fprintf(f,"\t.lcomm\t%s%ld,",labprefix,zl2l(v->offset));
-	newobj=1;
-    }
-    if(v->storage_class==EXTERN){
-	fprintf(f,"\t.globl\t%s%s\n",idprefix,v->identifier);
-	if(v->flags&(DEFINED|TENTATIVE)){
-	    if(v->clist&&(!constflag||(g_flags[3]&USEDFLAG))&&section!=DATA){fprintf(f,dataname);section=DATA;}
-	    if(v->clist&&constflag&&!(g_flags[3]&USEDFLAG)&&section!=CODE){fprintf(f,codename);section=CODE;}
-	    if(!v->clist&&section!=BSS){fprintf(f,bssname);section=BSS;}
-	    if(section!=BSS) fprintf(f,"\t.align\t2\n%s%s:\n",idprefix,v->identifier);
-		else fprintf(f,"\t.comm\t%s%s,",idprefix,v->identifier);
-	    newobj=1;
-	}
-    }
-}
-
-void gen_dc(FILE *f,int t,struct const_list *p)
-/*  This function has to create static storage		*/
-/*  initialized with const-list p.			*/
-{
-    title(f);
-    fprintf(f,"\t.%s\t",dct[t&NQ]);
-    if(!p->tree){
-	if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-	/*  auch wieder nicht sehr schoen und IEEE noetig   */
-	    unsigned char *ip;
-	    ip=(unsigned char *)&p->val.vdouble;
-	    fprintf(f,"0x%02x%02x%02x%02x",ip[3],ip[2],ip[1],ip[0]);
-	    if((t&NQ)==DOUBLE){
-		fprintf(f,",0x%02x%02x%02x%02x",ip[7],ip[6],ip[5],ip[4]);
-	    }
-	}else{
-	    printval(f,&p->val,t&NU,0);
-	}
-    }else{
-	int m=p->tree->o.flags;
-	p->tree->o.flags&=~VARADR;
-	probj2(f,&p->tree->o,t&NU);
-	p->tree->o.flags=m;
-    }
-    fprintf(f,"\n");newobj=0;
-}
-
-/*  The main code-generation routine.			*/
-/*  f is the stream the code should be written to.	*/
-/*  p is a pointer to a doubly linked list of ICs	*/
-/*  containing the function body to generate code for.	*/
-/*  v is a pointer to the function.			*/
-/*  offset is the size of the stackframe the function	*/
-/*  needs for local variables.				*/
-void gen_code(FILE *f,struct IC *p,struct Var *v,zlong offset)
-{
-    int c,t,lastcomp=0,reg;
-    int lastline=-1;
-
-    if(DEBUG&1) printf("gen_code()\n");
-    for(c=1;c<=15;c++) regs[c]=regsa[c];
-    regs[16]=0;
-    loff=((zl2l(offset)+1)/2)*2;
-    title(f);
-    function_top(f,v,loff);
-    stackoffset=notpopped=dontpop=0;
-    finit();
-    for(;p;pr(f,p),p=p->next){
-	c=p->code;t=p->typf;
-	if(c==NOP) continue;
-
-/*ADA*/
-if (lastline != p->line)
-{
-    emitdebugline(f,p->line);
-    lastline = p->line;
-}
-
-	if(c==SUBPFP) c=SUB;
-	if(c==SUBIFP) c=SUB;
-	if(c==ADDI2P) c=ADD;
-	if(c==ALLOCREG){
-	    regs[p->q1.reg]=1;
-	    continue;
-	}
-	if(c==FREEREG){
-	    if(p->q1.reg>=9){
-		for(c=0;c<8;c++)
-		    if(fst[c]==p->q1.reg) fst[c]=0;
-	    }
-	    regs[p->q1.reg]=0;
-	    continue;
-	}
-	if(notpopped&&!dontpop){
-	    int flag=0;
-	    if(c==LABEL||c==COMPARE||c==TEST||c==BRA){
-		fprintf(f,"\taddl\t$%ld,%%esp\n",notpopped);
-		stackoffset+=notpopped;notpopped=0;
-	    }
-	}
-	if(c==LABEL) {forder(f);fprintf(f,"%s%d:\n",labprefix,t);continue;}
-	if(c>=BEQ&&c<=BRA){
-	    forder(f);
-	    if(lastcomp&UNSIGNED) fprintf(f,"\tj%s\t%s%d\n",ccu[c-BEQ],labprefix,t);
-		else		  fprintf(f,"\tj%s\t%s%d\n",ccs[c-BEQ],labprefix,t);
-	    continue;
-	}
-	if(c==MOVETOREG){
-	    if(p->z.reg>8){
-		for(c=0;c<8;c++){
-		    if(fst[c]==p->z.reg) fst[c]=0;
-		}
-		fload(f,&p->q1,DOUBLE);
-		fst[0]=p->z.reg;
-		continue;
-	    }
-	    move(f,&p->q1,0,0,p->z.reg,LONG);
-	    continue;
-	}
-	if(c==MOVEFROMREG){
-	    if(p->q1.reg>8){
-		if(fst[0]!=p->q1.reg){
-		    for(c=0,reg=-1;c<8;c++){
-			if(fst[c]==p->q1.reg) reg=c;
-		    }
-		    if(reg<0) ierror(0);
-		    fxch(f,reg);
-		}
-		fprintf(f,"\tfstpl\t");probj2(f,&p->z,DOUBLE);
-		fprintf(f,"\n");fpop();
-		continue;
-	    }
-	    move(f,0,p->q1.reg,&p->z,0,LONG);
-	    continue;
-	}
-	if((p->q1.flags&(DREFOBJ|REG))==DREFOBJ){
-	    reg=get_reg(f,p);
-	    move(f,&p->q1,0,0,reg,LONG);
-	    p->q1.flags|=REG;p->q1.reg=reg;
-	}
-	if((p->q2.flags&(DREFOBJ|REG))==DREFOBJ){
-	    reg=get_reg(f,p);
-	    move(f,&p->q2,0,0,reg,LONG);
-	    p->q2.flags|=REG;p->q2.reg=reg;
-	}
-	if((p->z.flags&(DREFOBJ|REG))==DREFOBJ){
-	    reg=get_reg(f,p);
-	    move(f,&p->z,0,0,reg,LONG);
-	    p->z.flags|=REG;p->z.reg=reg;
-	}
-	if(c>=CONVCHAR&&c<=CONVULONG){
-	    int to;
-	    if(c==CONVCHAR) to=CHAR;
-	    if(c==CONVUCHAR) to=(UNSIGNED|CHAR);
-	    if(c==CONVSHORT) to=SHORT;
-	    if(c==CONVUSHORT) to=(UNSIGNED|SHORT);
-	    if(c==CONVINT) to=INT;
-	    if(c==CONVUINT) to=(UNSIGNED|INT);
-	    if(c==CONVLONG) to=INT;
-	    if(c==CONVULONG) to=(UNSIGNED|INT);
-	    if(c==CONVFLOAT) to=FLOAT;
-	    if(c==CONVDOUBLE) to=DOUBLE;
-	    if(c==CONVPOINTER) to=(UNSIGNED|INT);
-	    if((t&NU)==LONG) t=INT;
-	    if((t&NU)==(UNSIGNED|LONG)||(t&NU)==POINTER) t=(UNSIGNED|INT);
-	    if((to&NQ)<=INT&&(t&NQ)<=INT){
-		if(isreg(z)) reg=p->z.reg;
-		else if(isreg(q1)) reg=p->q1.reg;
-		else reg=get_reg(f,p);
-		if((to&NQ)<=SHORT){
-		    fprintf(f,"\tmov%c%cl\t",(to&UNSIGNED)?'z':'s',x_t[to&NQ]);
-		    if(isreg(q1)){
-			if((to&NQ)==SHORT){
-			    fprintf(f,"%%%s",regnames[p->q1.reg]+2);
-			}else{
-			    fprintf(f,"%%%cl",regnames[p->q1.reg][2]);
-			}
-		    }else probj2(f,&p->q1,to);
-		    fprintf(f,",%s\n",regnames[reg]);
-		}else{
-		    move(f,&p->q1,0,0,reg,to);
-		}
-		move(f,0,reg,&p->z,0,t);
-		continue;
-	    }
-	    if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-		if((to&NQ)==FLOAT||(to&NQ)==DOUBLE){
-		    if(isreg(q1)&&fst[0]==p->q1.reg){
-			if(isreg(z)){
-			    if(p->z.reg==fst[0]) continue;
-			    for(reg=0,c=7;c>=0;c--){
-				if(fst[c]==p->z.reg){reg=c;break;}
-				if(fst[c]<0) reg=c;
-			    }
-			    fst[reg]=p->z.reg;
-			}
-			fprintf(f,"\tfst%c\t",x_t[t&NQ]);
-			probj2(f,&p->z,t);fprintf(f,"\n");
-			continue;
-		    }
-		    fload(f,&p->q1,to);
-		    fstore(f,&p->z,t);
-		    continue;
-		}
-		if((to&NQ)<=SHORT){
-		    if(isreg(q1)){
-			reg=p->q1.reg;
-			if(to&UNSIGNED){
-			    fprintf(f,"\tandl\t$%ld,%s\n",(to&NQ)==CHAR?255L:65535L,regnames[reg]);
-			}else{
-/*			      fprintf(f,"\tc%ctl\t%s\n",x_t[to&NQ],regnames[reg]);*/
-			    if((to&NQ)==SHORT){
-				fprintf(f,"\tmovswl\t%%%s,%s\n",regnames[reg]+2,regnames[reg]);
-			    }else{
-				fprintf(f,"\tmovsbl\t%%%cl,%s\n",regnames[reg][2],regnames[reg]);
-			    }
-			}
-		    }else{
-			reg=get_reg(f,p);
-			if(to&UNSIGNED){
-			    fprintf(f,"\tmovz%cl\t",x_t[to&NQ]);
-			}else{
-			    fprintf(f,"\tmovs%cl\t",x_t[to&NQ]);
-			}
-			probj2(f,&p->q1,to);fprintf(f,",%s\n",regnames[reg]);
-		    }
-		    fprintf(f,"\tpushl\t%s\n",regnames[reg]);
-		    fprintf(f,"\tfildl\t(%s)\n\taddl\t$4,%s\n",regnames[sp],regnames[sp]);
-		}else{
-		    if(to&UNSIGNED){
-			fprintf(f,"\tpushl\t$0\n\tpushl\t");stackoffset-=4;
-			probj2(f,&p->q1,to);
-			fprintf(f,"\n\tfildq\t(%s)\n\taddl\t$8,%s\n",regnames[sp],regnames[sp]);
-			stackoffset+=4;
-		    }else{
-			if(isreg(q1)){
-			    fprintf(f,"\tpushl\t%s\n\tfildl\t(%s)\n\taddl\t$4,%s\n",regnames[p->q1.reg],regnames[sp],regnames[sp]);
-			}else{
-			    fprintf(f,"\tfildl\t");probj2(f,&p->q1,t);
-			    fprintf(f,"\n");
-			}
-		    }
-		}
-		fpush(f);
-		fstore(f,&p->z,t);
-		continue;
-	    }
-	    if((to&NQ)==FLOAT||(to&NQ)==DOUBLE){
-		if(isreg(q1)&&fst[0]==p->q1.reg){
-		    if((t&NQ)==CHAR){
-			if(isreg(z)) reg=p->z.reg; else reg=get_reg(f,p);
-			fprintf(f,"\tsubl\t$4,%s\n\tfistl\t(%s)\n\tmovsbl\t(%s),%s\n\taddl\t$4,%s\n",regnames[sp],regnames[sp],regnames[sp],regnames[reg],regnames[sp]);
-			move(f,0,reg,&p->z,0,t);
-		    }else{
-		      if(isreg(z)){
-			fprintf(f,"\tsubl\t$4,%s\n\tfistl\t(%s)\n\tmov%c\t(%s),",regnames[sp],regnames[sp],x_t[t&NQ],regnames[sp]);
-			stackoffset-=4;
-			probj2(f,&p->z,t);fprintf(f,"\n\taddl\t$4,%s\n",regnames[sp]);
-			stackoffset+=4;
-		      }else{
-			fprintf(f,"\tfist%c\t",x_t[t&NQ]);
-			probj2(f,&p->z,t);fprintf(f,"\n");
-		      }
-		    }
-		}else{
-		    fload(f,&p->q1,to);
-		    if((t&NQ)==CHAR){
-			if(isreg(z)) reg=p->z.reg; else reg=get_reg(f,p);
-			fprintf(f,"\tsubl\t$4,%s\n\tfistpl\t(%s)\n\tmovsbl\t(%s),%s\n\taddl\t$4,%s\n",regnames[sp],regnames[sp],regnames[sp],regnames[reg],regnames[sp]);
-			fpop(); move(f,0,reg,&p->z,0,t);
-		    }else{
-		      if(isreg(z)){
-			fprintf(f,"\tsubl\t$4,%s\n\tfistpl\t(%s)\n\tmov%c\t(%s),",regnames[sp],regnames[sp],x_t[t&NQ],regnames[sp]);
-			stackoffset-=4;
-			probj2(f,&p->z,t);fprintf(f,"\n\taddl\t$4,%s\n",regnames[sp]);
-			stackoffset+=4;fpop();
-		      }else{
-			fprintf(f,"\tfistp%c\t",x_t[t&NQ]);
-			probj2(f,&p->z,t);fprintf(f,"\n");fpop();
-		      }
-		    }
-		}
-		continue;
-	    }
-	    ierror(0);
-	}
-	if(c==MINUS||c==KOMPLEMENT){
-	    char *s;
-	    if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-		if(isreg(z)&&p->z.reg==9&&isreg(q1)&&p->q1.reg==9){
-		    fprintf(f,"\tfchs\n");
-		    continue;
-		}
-		fload(f,&p->q1,t);
-		fprintf(f,"\tfchs\n");
-		fprintf(f,"\tfstp%c\t",x_t[t&NQ]);
-		probj2(f,&p->z,t);fprintf(f,"\n");
-		fpop();
-		continue;
-	    }
-	    if(c==MINUS) s="neg"; else s="not";
-	    if(compare_objects(&p->q1,&p->q2)){
-		fprintf(f,"\t%s%c\t",s,x_t[t&NQ]);
-		probj2(f,&p->z,t);fprintf(f,"\n");
-		continue;
-	    }
-	    if(isreg(z)) reg=p->z.reg; else reg=get_reg(f,p);
-	    move(f,&p->q1,0,0,reg,t);
-	    fprintf(f,"\t%s%c\t%s\n",s,x_t[t&NQ],regnames[reg]);
-	    move(f,0,reg,&p->z,0,t);
-	    continue;
-	}
-	if(c==SETRETURN){
-	    if(p->z.reg){
-		if(p->z.reg==9){
-		    if(!isreg(q1)||fst[0]!=p->q1.reg)
-			fload(f,&p->q1,t);
-		}else{
-		    move(f,&p->q1,0,0,p->z.reg,t);
-		}
-	    }
-	    continue;
-	}
-	if(c==GETRETURN){
-	    if(p->q1.reg){
-		if(p->q1.reg==9){
-		    if(!isreg(z)||fst[0]!=p->z.reg)
-			fstore(f,&p->z,t);
-		}else{
-		    move(f,0,p->q1.reg,&p->z,0,t);
-		}
-	    }
-	    continue;
-	}
-	if(c==CALL){
-	    int reg;
-	    if(p->q1.flags&DREFOBJ){
-		if(!(p->q1.flags&REG)) ierror(0);
-		fprintf(f,"\tcall\t*%s\n",regnames[p->q1.reg]);
-	    }else{
-		fprintf(f,"\tcall\t");probj2(f,&p->q1,t);
-		fprintf(f,"\n");
-	    }
-	    if(!zleqto(l2zl(0L),p->q2.val.vlong)){
-		notpopped+=zl2l(p->q2.val.vlong);
-		dontpop-=zl2l(p->q2.val.vlong);
-		if(!(g_flags[2]&USEDFLAG)&&stackoffset==-notpopped){
-		/*  Entfernen der Parameter verzoegern	*/
-		}else{
-		    fprintf(f,"\taddl\t$%ld,%%esp\n",zl2l(p->q2.val.vlong));
-		    stackoffset+=zl2l(p->q2.val.vlong);
-		    notpopped-=zl2l(p->q2.val.vlong);
-		}
-	    }
-	    continue;
-	}
-	if(c==ASSIGN||c==PUSH){
-	    if(c==PUSH) dontpop+=zl2l(p->q2.val.vlong);
-	    if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-		if(c==ASSIGN){
-		    prfst(f,"fassign");
-		    fload(f,&p->q1,t);
-		    fstore(f,&p->z,t);
-		    continue;
-		}else if(isreg(q1)){
-		    prfst(f,"fpush");
-		    fprintf(f,"\tsubl\t$%ld,%s\n",zl2l(sizetab[t&NQ]),regnames[sp]);
-		    stackoffset-=zl2l(sizetab[t&NQ]);
-		    if(fst[0]==p->q1.reg){
-			fprintf(f,"\tfst%c\t(%s)\n",x_t[t&NQ],regnames[sp]);
-		    }else{
-			fload(f,&p->q1,t);
-			fprintf(f,"\tfstp%c\t(%s)\n",x_t[t&NQ],regnames[sp]);
-			fpop();
-		    }
-		    continue;
-		}
-	    }
-	    if((t&NQ)>POINTER||!zleqto(p->q2.val.vlong,sizetab[t&NQ])||!zlleq(p->q2.val.vlong,l2zl(4L))){
-		int mdi=di,msi=si,m=0;long l;
-		l=zl2l(p->q2.val.vlong);
-		if(regs[cx]){m|=1;if(!cxl)cxl=++label;fprintf(f,"\tmovl\t%s,%s%d\n",regnames[cx],labprefix,cxl);}
-		if(regs[msi]||!regused[msi]){m|=2;if(!sil)sil=++label;fprintf(f,"\tmovl\t%s,%s%d\n",regnames[msi],labprefix,sil);}
-		if(regs[mdi]||!regused[mdi]){m|=4;if(!dil)dil=++label;fprintf(f,"\tmovl\t%s,%s%d\n",regnames[mdi],labprefix,dil);}
-		if((p->z.flags&REG)&&p->z.reg==msi&&(p->q1.flags&REG)&&p->q1.reg==mdi){
-		    msi=di;mdi=si;
-		    m|=8;
-		}
-		if(!(p->z.flags&REG)||p->z.reg!=msi){
-		    fprintf(f,"\tleal\t");probj2(f,&p->q1,t);
-		    fprintf(f,",%s\n",regnames[msi]);
-		}
-		if(c==PUSH){
-		    fprintf(f,"\tsubl\t$%ld,%s\n\tmovl\t%s,%s\n",l,regnames[sp],regnames[sp],regnames[mdi]);
-		    stackoffset-=l;
-		}else{
-		    fprintf(f,"\tleal\t");probj2(f,&p->z,t);
-		    fprintf(f,",%s\n",regnames[mdi]);
-		}
-		if((p->z.flags&REG)&&p->z.reg==msi){
-		    fprintf(f,"\tleal\t");probj2(f,&p->q1,t);
-		    fprintf(f,",%s\n",regnames[msi]);
-		}
-		if(m&8){
-		    msi=si;mdi=di;
-		    fprintf(f,"\txch\t%s,%s\n",regnames[msi],regnames[mdi]);
-		}
-		if((t&NQ)==ARRAY||(t&NQ)==CHAR||l<4){
-		    fprintf(f,"\tmovl\t$%ld,%s\n\trep\n\tmovsb\n",l,regnames[cx]);
-		}else{
-		    if(l>=8)
-			fprintf(f,"\tmovl\t$%ld,%s\n\trep\n",l/4,regnames[cx]);
-		    fprintf(f,"\tmovsl\n");
-		    if(l%2) fprintf(f,"\tmovsw\n");
-		    if(l%1) fprintf(f,"\tmovsb\n");
-		}
-		if(m&4) fprintf(f,"\tmovl\t%s%d,%s\n",labprefix,dil,regnames[mdi]);
-		if(m&2) fprintf(f,"\tmovl\t%s%d,%s\n",labprefix,sil,regnames[msi]);
-		if(m&1) fprintf(f,"\tmovl\t%s%d,%s\n",labprefix,cxl,regnames[cx]);
-		continue;
-	    }
-	    if(t==FLOAT) t=LONG;
-	    if(c==PUSH){
-		fprintf(f,"\tpush%c\t",x_t[t&NQ]);
-		probj2(f,&p->q1,t);fprintf(f,"\n");
-		stackoffset-=zl2l(p->q2.val.vlong);
-		continue;
-	    }
-	    if(c==ASSIGN){
-		if(p->q1.flags&KONST){
-		    move(f,&p->q1,0,&p->z,0,t);
-		    continue;
-		}
-		if(isreg(z)) reg=p->z.reg;
-		else if(isreg(q1)) reg=p->q1.reg;
-		else reg=get_reg(f,p);
-		move(f,&p->q1,0,0,reg,t);
-		move(f,0,reg,&p->z,0,t);
-		continue;
-	    }
-	    ierror(0);
-	}
-	if(c==ADDRESS){
-	    if(isreg(z)) reg=p->z.reg; else reg=get_reg(f,p);
-	    fprintf(f,"\tleal\t");probj2(f,&p->q1,t);
-	    fprintf(f,",%s\n",regnames[reg]);
-	    move(f,0,reg,&p->z,0,POINTER);
-	    continue;
-	}
-	if(c==TEST){
-	    lastcomp=t;
-	    if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-		if(isreg(q1)&&fst[0]==p->q1.reg){
-		    fprintf(f,"\tftst\n");lastcomp|=UNSIGNED;
-		    continue;
-		}else{
-		    p->code=c=COMPARE;
-		    p->q2.flags=KONST;
-		    p->q2.val.vdouble=d2zd(0.0);
-		    if((t&NQ)==FLOAT) p->q2.val.vfloat=zd2zf(p->q2.val.vdouble);
-		    /*	fall through to COMPARE */
-		}
-	    }else{
-		fprintf(f,"\tcmp%c\t$0,",x_t[t&NQ]);
-		probj2(f,&p->q1,t);fprintf(f,"\n");
-		continue;
-	    }
-	}
-	if(c==COMPARE){
-	    lastcomp=t;
-	    if(isreg(q2)||(p->q1.flags&KONST)){
-		struct IC *b=p->next;
-		struct obj o;
-		o=p->q1;p->q1=p->q2;p->q2=o;
-		while(b&&b->code==FREEREG) b=b->next;
-		if(!b) ierror(0);
-		if(b->code==BLT) b->code=BGT;
-		else if(b->code==BLE) b->code=BGE;
-		else if(b->code==BGT) b->code=BLT;
-		else if(b->code==BGE) b->code=BLE;
-	    }
-	    if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-		prfst(f,"fcomp");
-		if(isreg(q1)&&p->q1.reg==fst[0]){
-		    fprintf(f,"\tfcom%c\t",x_t[t&NQ]);
-		    probj2(f,&p->q2,t);fprintf(f,"\n");
-		}else{
-		    fload(f,&p->q1,t);
-		    fprintf(f,"\tfcomp%c\t",x_t[t&NQ]);
-		    probj2(f,&p->q2,t);fprintf(f,"\n");
-		    fpop();
-		}
-		fprintf(f,"\tfstsw\n\tsahf\n");
-		lastcomp|=UNSIGNED;
-		continue;
-	    }
-	    if(!isreg(q1)){
-		if(!isreg(q2)){
-		    reg=get_reg(f,p);
-		    move(f,&p->q1,0,0,reg,t);
-		    p->q1.flags=REG;
-		    p->q1.reg=reg;
-		}
-	    }
-	    fprintf(f,"\tcmp%c\t",x_t[t&NQ]);
-	    probj2(f,&p->q2,t);fprintf(f,",");
-	    probj2(f,&p->q1,t);fprintf(f,"\n");
-	    continue;
-	}
-	if((t&NQ)==FLOAT||(t&NQ)==DOUBLE){
-	    char s[2];
-	    prfst(f,"fmath");
-	    if(isreg(q2)) s[0]=0; else {s[0]=x_t[t&NQ];s[1]=0;}
-	    if(isreg(z)&&isreg(q1)&&p->q1.reg==fst[0]&&p->z.reg==fst[0]){
-		fprintf(f,"\t%s%s\t",farithmetics[c-LSHIFT],s);
-		probj2(f,&p->q2,t); fprintf(f,"\n");continue;
-	    }
-	    fload(f,&p->q1,t);
-	    fprintf(f,"\t%s%s\t",farithmetics[c-LSHIFT],s);
-	    probj2(f,&p->q2,t); fprintf(f,"\n");
-	    fstore(f,&p->z,t); continue;
-	}
-	if((c==MULT||c==DIV||(c==MOD&&(p->typf&UNSIGNED)))&&(p->q2.flags&KONST)){
-	    long ln;
-	    eval_const(&p->q2.val,t);
-	    if(zlleq(l2zl(0L),vlong)&&zulleq(ul2zul(0UL),vulong)){
-		if(ln=pof2(vulong)){
-		    if(c==MOD){
-			vlong=zlsub(vlong,l2zl(1L));
-			p->code=AND;
-		    }else{
-			vlong=l2zl(ln-1);
-			if(c==DIV) p->code=RSHIFT; else p->code=LSHIFT;
-		    }
-		    c=p->code;
-		    if((t&NU)==CHAR) p->q2.val.vchar=zl2zc(vlong);
-		    if((t&NU)==SHORT) p->q2.val.vshort=zl2zs(vlong);
-		    if((t&NU)==INT) p->q2.val.vint=zl2zi(vlong);
-		    if((t&NU)==LONG) p->q2.val.vlong=vlong;
-		    vulong=zl2zul(vlong);
-		    if((t&NU)==(UNSIGNED|CHAR)) p->q2.val.vuchar=zul2zuc(vulong);
-		    if((t&NU)==(UNSIGNED|SHORT)) p->q2.val.vushort=zul2zus(vulong);
-		    if((t&NU)==(UNSIGNED|INT))  p->q2.val.vuint=zul2zui(vulong);
-		    if((t&NU)==(UNSIGNED|LONG)) p->q2.val.vulong=vulong;
-		}
-	    }
-	}
-	if(c==MOD||c==DIV){
-	    int m=0;
-	    if(regs[ax]&&(!isreg(z)||p->z.reg!=ax)){
-		fprintf(f,"\tpushl\t%s\n",regnames[ax]);
-		stackoffset-=4;m|=1;
-	    }
-	    if(regs[dx]&&(!isreg(z)||p->z.reg!=dx)){
-		fprintf(f,"\tpushl\t%s\n",regnames[dx]);
-		stackoffset-=4;m|=2;
-	    }
-	    if((p->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&(p->q2.reg==ax||p->q2.reg==dx)){
-		move(f,&p->q2,0,0,dx,t);
-		fprintf(f,"\tpushl\t%s\n",regnames[dx]);
-		m|=8;stackoffset-=4;
-	    }
-	    move(f,&p->q1,0,0,ax,t);
-	    if(p->q2.flags&KONST){
-		fprintf(f,"\tpush%c\t",x_t[t&NQ]);probj2(f,&p->q2,t);
-		fprintf(f,"\n");m|=4;stackoffset-=4;
-	    }
-	    if(t&UNSIGNED) fprintf(f,"\txorl\t%s,%s\n\tdivl\t",regnames[dx],regnames[dx]);
-		else	   fprintf(f,"\tcltd\n\tidivl\t");
-	    if((m&12)||(isreg(q2)&&p->q2.reg==dx)){
-		fprintf(f,"(%s)",regnames[sp]);
-	    }else if(isreg(q2)&&p->q2.reg==ax){
-		fprintf(f,"%s(%s)",(m&2)?"4":"",regnames[sp]);
-	    }else{
-		probj2(f,&p->q2,t);
-	    }
-	    fprintf(f,"\n");
-	    if(c==DIV) move(f,0,ax,&p->z,0,t);
-		else   move(f,0,dx,&p->z,0,t);
-	    if(m&4){ fprintf(f,"\taddl\t$%ld,%s\n",zl2l(sizetab[t&NQ]),regnames[sp]);stackoffset+=4;}
-	    if(m&8){ fprintf(f,"\tpopl\t%s\n",regnames[dx]);stackoffset+=4;}
-	    if(m&2){ fprintf(f,"\tpopl\t%s\n",regnames[dx]);stackoffset+=4;}
-	    if(m&1){ fprintf(f,"\tpopl\t%s\n",regnames[ax]);stackoffset+=4;}
-	    continue;
-	}
-	if(!(p->q2.flags&KONST)&&(c==LSHIFT||c==RSHIFT)){
-	    char *s=arithmetics[c-LSHIFT];
-	    int fl=0;
-	    if(c==RSHIFT&&(t&UNSIGNED)) s="shr";
-	    if(((p->q1.flags&REG)&&p->q1.reg==cx)||((p->z.flags&REG)&&p->z.reg==cx)
-	       ||(!compare_objects(&p->q1,&p->z)&&!isreg(q1))){
-		reg=get_reg(f,p);
-		move(f,&p->q1,0,0,reg,t);
-		move(f,&p->q2,0,0,cx,t);
-		fprintf(f,"\t%s%c\t%%cl,%s\n",s,x_t[t&NQ],regnames[reg]);
-		move(f,0,reg,&p->z,0,t);
-		continue;
-	    }else{
-		if(!isreg(q2)||p->q2.reg!=cx){
-		    if(regs[cx]){fprintf(f,"\tpushl\t%s\n",regnames[cx]);fl=1;}
-		    move(f,&p->q2,0,0,cx,t);
-		}
-		if(compare_objects(&p->q1,&p->z)){
-		    fprintf(f,"\t%s%c\t%%cl,",s,x_t[t&NQ]);
-		    probj2(f,&p->z,t);fprintf(f,"\n");
-		}else{
-		    move(f,0,p->q1.reg,&p->z,0,t);
-		    fprintf(f,"\t%s%c\t%%cl,",s,x_t[t&NQ]);
-		    probj2(f,&p->z,t);fprintf(f,"\n");
-		}
-		if(fl) fprintf(f,"\tpopl\t%s\n",regnames[cx]);
-		continue;
-	    }
-	}
-	if((c>=LSHIFT&&c<=MOD)||(c>=OR&&c<=AND)){
-	    char *s;
-	    if(c>=OR&&c<=AND) s=logicals[c-OR];
-		else s=arithmetics[c-LSHIFT];
-	    if(c==RSHIFT&&(t&UNSIGNED)) s="shr";
-	    if(c!=MULT&&compare_objects(&p->q1,&p->z)){
-		if(isreg(z)||isreg(q1)||(p->q2.flags&KONST)){
-		    if((p->q2.flags&KONST)&&(c==ADD||c==SUB)){
-			eval_const(&p->q2.val,t);
-			if(zleqto(vlong,l2zl(1L))&&zuleqto(vulong,ul2zul(1UL))&&zdeqto(vdouble,d2zd(1.0))){
-			    if(c==ADD) s="inc"; else s="dec";
-			    fprintf(f,"\t%s%c\t",s,x_t[t&NQ]);
-			    probj2(f,&p->z,t);fprintf(f,"\n");
-			    continue;
-			}
-		    }
-		    fprintf(f,"\t%s%c\t",s,x_t[t&NQ]);
-		    probj2(f,&p->q2,t);fprintf(f,",");
-		    probj2(f,&p->z,t);fprintf(f,"\n");
-		    continue;
-		}else{
-		    if(isreg(q2)) reg=p->q2.reg; else reg=get_reg(f,p);
-		    move(f,&p->q2,0,0,reg,t);
-		    fprintf(f,"\t%s%c\t%s",s,x_t[t&NQ],regnames[reg]);
-		    fprintf(f,","); probj2(f,&p->z,t);fprintf(f,"\n");
-		    continue;
-		}
-	    }
-	    if(isreg(z)) reg=p->z.reg; else reg=get_reg(f,p);
-	    move(f,&p->q1,0,0,reg,t);
-	    if((p->q2.flags&KONST)&&(c==ADD||c==SUB)){
-		eval_const(&p->q2.val,t);
-		if(zleqto(vlong,l2zl(1L))&&zuleqto(vulong,ul2zul(1UL))&&zdeqto(vdouble,d2zd(1.0))){
-		    if(c==ADD) s="inc"; else s="dec";
-		    fprintf(f,"\t%s%c\t%s\n",s,x_t[t&NQ],regnames[reg]);
-		}else{
-		    fprintf(f,"\t%s%c\t",s,x_t[t&NQ]);
-		    probj2(f,&p->q2,t);fprintf(f,",%s\n",regnames[reg]);
-		}
-	    }else{
-		fprintf(f,"\t%s%c\t",s,x_t[t&NQ]);
-		probj2(f,&p->q2,t);fprintf(f,",%s\n",regnames[reg]);
-	    }
-	    move(f,0,reg,&p->z,0,t);
-	    continue;
-	}
-	ierror(0);
-    }
-    if(notpopped){
-	fprintf(f,"\taddl\t$%ld,%%esp\n",notpopped);
-	stackoffset+=notpopped;notpopped=0;
-    }
-    function_bottom(f,v,loff);
-}
-
-int shortcut(int code,int typ)
-{
-    return(0);
-}
-
-void cleanup_cg(FILE *f)
-{
-    struct fpconstlist *p;
-    unsigned char *ip;
-
-    title(f);
-    while(p=firstfpc){
-	if(f){
-	    if(section!=CODE){fprintf(f,codename);section=CODE;}
-	    fprintf(f,"%s%d:\n\t.long\t",labprefix,p->label);
-	    ip=(unsigned char *)&p->val.vdouble;
-	    fprintf(f,"0x%02x%02x%02x%02x",ip[3],ip[2],ip[1],ip[0]);
-	    if((p->typ&NQ)==DOUBLE){
-		fprintf(f,",0x%02x%02x%02x%02x",ip[7],ip[6],ip[5],ip[4]);
-	    }
-	    fprintf(f,"\n");
-	}
-	firstfpc=p->next;
-	free(p);
-    }
-    if(f){
-	if(section!=BSS){fprintf(f,bssname);section=BSS;}
-	if(cxl) fprintf(f,"\t.lcomm\t%s%d,4\n",labprefix,cxl);
-	if(sil) fprintf(f,"\t.lcomm\t%s%d,4\n",labprefix,sil);
-	if(dil) fprintf(f,"\t.lcomm\t%s%d,4\n",labprefix,dil);
-    }
-}
diff -Naur vbcc/machines/bi386/machine.dt /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.dt
--- vbcc/machines/bi386/machine.dt	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.dt	Thu Jan  1 00:00:00 1970
@@ -1,13 +0,0 @@
-S8BS
-S8BU
-S16BSBE S16BSLE
-S16BUBE S16BULE
-S32BSBE S32BSLE
-S32BUBE S32BULE
-S32BSBE S32BSLE
-S32BUBE S32BULE
-S32BIEEEBE
-S64BIEEEBE
-S32BUBE S32BULE
-
-
diff -Naur vbcc/machines/bi386/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.h
--- vbcc/machines/bi386/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/bi386/machine.h	Thu Jan  1 00:00:00 1970
@@ -1,59 +0,0 @@
-/*  Example of a code-generator for an Intel 386 or higher.         */
-
-#include "dt.h"
-
-#define BEI386
-
-/*  This struct can be used to implement machine-specific           */
-/*  addressing-modes.                                               */
-/*  Not used in this code-generrator.                               */
-struct AddressingMode{
-    int never_used;
-};
-
-/*  The number of registers of the target machine.                  */
-#define MAXR 16
-
-/*  Number of commandline-options the code-generator accepts.       */
-#define MAXGF 10
-
-/*  If this is set to zero vbcc will not generate ICs where the     */
-/*  target operand is the same as the 2nd source operand.           */
-/*  This can sometimes simplify the code-generator, but usually     */
-/*  the code is better if the code-generator allows it.             */
-#define USEQ2ASZ 0
-
-/*  This specifies the smallest integer type that can be added to a */
-/*  pointer.                                                        */
-#define MINADDI2P INT
-
-/*  If the bytes of an integer are ordered most significant byte    */
-/*  byte first and then decreasing set BIGENDIAN to 1.              */
-#ifdef BEI386
-#define BIGENDIAN 1
-#else
-#define BIGENDIAN 0
-#endif
-
-/*  If the bytes of an integer are ordered lest significant byte    */
-/*  byte first and then increasing set LITTLEENDIAN to 1.           */
-#ifdef BEI386
-#define LITTLEENDIAN 0
-#else
-#define LITTLEENDIAN 1
-#endif
-
-/*  Note that BIGENDIAN and LITTLEENDIAN are mutually exclusive.    */
-
-/*  If switch-statements should be generated as a sequence of       */
-/*  SUB,TST,BEQ ICs rather than COMPARE,BEQ ICs set this to 1.      */
-/*  This can yield better code on some machines.                    */
-#define SWITCHSUBS 0
-
-/*  In optimizing compilation certain library memcpy/strcpy-calls   */
-/*  with length known at compile-time will be inlined using an      */
-/*  ASSIGN-IC if the size is less or equal to INLINEMEMCPY.         */
-/*  The type used for the ASSIGN-IC will be UNSIGNED|CHAR.          */
-#define INLINEMEMCPY 1024
-
-
diff -Naur vbcc/machines/c16x/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/c16x/machine.c
--- vbcc/machines/c16x/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/c16x/machine.c	Tue Sep 22 04:18:49 2015
@@ -192,7 +192,7 @@
 		    "(void)","dw","dsptr","dsptr"};
 static char *vdct[]={"",".bit",".byte",".short",".short",".short",".short",".short",".short",".short",
 		    "(void)",".short",".long",".long"};
-static int pushedsize,pushorder=2;
+static pushedsize,pushorder=2;
 static char *idprefix="_",*labprefix="l";
 static int ti2_used;
 static struct rpair qp;
@@ -1406,52 +1406,6 @@
   nvar.storage_class=STATIC;
   fvar.storage_class=STATIC;
 
-
-  /* TODO: set argument registers */
-  declare_builtin("__mulint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__addint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__subint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__andint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__orint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__eorint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__negint64",LLONG,LLONG,0,0,0,1,0);
-  declare_builtin("__lslint64",LLONG,LLONG,0,INT,0,1,0);
-
-  declare_builtin("__divsint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__divuint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__modsint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__moduint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__lsrsint64",LLONG,LLONG,0,INT,0,1,0);
-  declare_builtin("__lsruint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,INT,0,1,0);
-  declare_builtin("__cmpsint64",INT,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__cmpuint64",INT,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__sint64toflt32",FLOAT,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt32",FLOAT,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__sint64toflt64",DOUBLE,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt64",DOUBLE,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__flt32tosint64",LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt32touint64",UNSIGNED|LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64tosint64",LLONG,DOUBLE,0,0,0,1,0);
-  declare_builtin("__flt64touint64",UNSIGNED|LLONG,DOUBLE,0,0,0,1,0);
-
-  declare_builtin("__flt32toflt64",DOUBLE,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64toflt32",FLOAT,DOUBLE,0,0,0,1,0);
-
-
-  declare_builtin("__addflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__subflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__mulflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__divflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__negflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__cmpflt32",INT,FLOAT,0,FLOAT,0,1,0);
-
-  declare_builtin("__addflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__subflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__mulflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__divflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__negflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__cmpflt64",INT,DOUBLE,0,DOUBLE,0,1,0);
-
   return 1;
 }
 
@@ -2731,7 +2685,7 @@
       int reg,jmp=0;long csstack=0,custack=0;
       cc=0;
       if((p->q1.flags&(VAR|DREFOBJ))==VAR&&!strcmp("__va_start",p->q1.v->identifier)){
-	long va_off=loff-usrstackoffset+pushedsize+zm2l(va_offset(v));
+	long va_off=loff-usrstackoffset+pushedsize;
 	emit(f,"\tmov\t%s,%s\n",regnames[r4],regnames[sp]);
 	if(va_off)
 	  emit(f,"\tadd\t%s,#%ld\n",regnames[r4],va_off);
@@ -3678,51 +3632,58 @@
 {
 }
 
-char *use_libcall(int c,int t,int t2)
+char *use_libcall(np p)
 {
   static char fname[16];
   char *ret=0,*tt;
-
-  if(c==COMPARE){
-    if((t&NQ)==LLONG||ISFLOAT(t)){
-      sprintf(fname,"__cmp%s%s%ld",(t&UNSIGNED)?"u":"s",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
+  int f;
+  if(p->flags>=EQUAL&&p->flags<=GREATEREQ){
+    extern struct Typ *arith_typ();
+    struct Typ *t=arith_typ(p->left->ntyp,p->right->ntyp);
+    f=t->flags&NU;
+    freetyp(t);
+    if((f&NQ)==LLONG){
+      sprintf(fname,"__cmp%s%sll",ename[p->flags],(f&UNSIGNED)&&p->flags!=EQUAL&&p->flags!=INEQUAL?"u":"");
+      ret=fname;
+    }else if((f&NQ)==FLOAT){
+      sprintf(fname,"__cmp%s%sf",ename[p->flags],(f&UNSIGNED)&&p->flags!=EQUAL&&p->flags!=INEQUAL?"u":"");
+      ret=fname;
+    }else if((f&NQ)==DOUBLE||(f&NQ)==LDOUBLE){
+      sprintf(fname,"__cmp%s%sd",ename[p->flags],(f&UNSIGNED)&&p->flags!=EQUAL&&p->flags!=INEQUAL?"u":"");
       ret=fname;
     }
   }else{
-    t&=NU;
-    t2&=NU;
-    if(t==LDOUBLE) t=DOUBLE;
-    if(t2==LDOUBLE) t2=DOUBLE;
-    if(c==CONVERT){
-      if(t==t2) return 0;
-      if(t==FLOAT&&t2==DOUBLE) return "__flt64toflt32";
-      if(t==DOUBLE&&t2==FLOAT) return "__flt32toflt64";
-
-      if(ISFLOAT(t)){
-        sprintf(fname,"__%cint%ldtoflt%d",(t2&UNSIGNED)?'u':'s',zm2l(sizetab[t2&NQ])*8,(t==FLOAT)?32:64);
-        ret=fname;
-      }
-      if(ISFLOAT(t2)&&(t&NU)==LLONG){
-        sprintf(fname,"__flt%dto%cint%ld",((t2&NU)==FLOAT)?32:64,(t&UNSIGNED)?'u':'s',zm2l(sizetab[t&NQ])*8);
-        ret=fname;
-      }
-    }
-    if((t&NQ)==LLONG||ISFLOAT(t)){
-      if((c>=LSHIFT&&c<=MOD)||(c>=OR&&c<=AND)||c==KOMPLEMENT||c==MINUS){
-	if(t==(UNSIGNED|LLONG)&&(c==DIV||c==MOD||c==RSHIFT)){
-	  sprintf(fname,"__%suint64",ename[c]);
-	  ret=fname;
-	}else if((t&NQ)==LLONG){
-          sprintf(fname,"__%sint64",ename[c]);
+    f=p->ntyp->flags&NU;
+    if((f&NQ)==LLONG||ISFLOAT(f)){
+      if((p->flags>=LSHIFT&&p->flags<=MOD)||(p->flags>=OR&&p->flags<=AND)||p->flags==PMULT||(p->flags>=EQUAL&&p->flags<=GREATEREQ)){
+        if(f==(UNSIGNED|LLONG)&&(p->flags==DIV||p->flags==MOD||p->flags==RSHIFT)){
+          sprintf(fname,"__%sull",ename[p->flags]);
           ret=fname;
-        }else{
-	  sprintf(fname,"__%s%s%s%ld",ename[c],(t&UNSIGNED)?"u":"",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
+        }else if((f&NQ)==LLONG){
+          sprintf(fname,"__%sll",ename[p->flags]);
           ret=fname;
-	}
+        }else if((f&NQ)==FLOAT){
+          sprintf(fname,"__%sf",ename[p->flags]);
+          ret=fname;
+        }else if((f&NQ)==DOUBLE||(f&NQ)==LDOUBLE){
+          sprintf(fname,"__%sd",ename[p->flags]);
+          ret=fname;
+        }else printf("un %d\n",p->flags);
       }
     }
   }
-
-
+  if(ret){
+    /* declare function if necessary */
+    struct struct_declaration *sd;struct Typ *t;struct Var *v;
+    if(!find_ext_var(ret)){
+      sd=mymalloc(sizeof(*sd));
+      sd->count=0;
+      t=new_typ();
+      t->flags=FUNKT;
+      t->exact=add_sd(sd,FUNKT);
+      t->next=clone_typ(p->ntyp);
+      add_var(ret,t,EXTERN,0);
+    }
+  }
   return ret;
 }
diff -Naur vbcc/machines/c16x/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/c16x/machine.h
--- vbcc/machines/c16x/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/c16x/machine.h	Tue Sep 22 04:18:49 2015
@@ -36,7 +36,6 @@
 #undef UNION
 #undef ENUM
 #undef FUNKT
-#undef BOOL
 #undef MAXINT
 #undef MAX_TYPE
 
@@ -58,9 +57,8 @@
 #define UNION 16
 #define ENUM 17
 #define FUNKT 18
-#define BOOL 19
 
-#define MAXINT 20
+#define MAXINT 19
 
 #define MAX_TYPE MAXINT
 
diff -Naur vbcc/machines/hc12/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/hc12/machine.c
--- vbcc/machines/hc12/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/hc12/machine.c	Tue Sep 22 04:18:49 2015
@@ -1071,81 +1071,6 @@
 
   target_macros=marray;
 
-
-  /* TODO: set argument registers */
-  declare_builtin("__mulint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__addint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__subint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__andint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__orint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__eorint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__negint32",LONG,LONG,0,0,0,1,0);
-  declare_builtin("__lslint32",LONG,LONG,0,INT,0,1,0);
-
-  declare_builtin("__divsint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__divuint32",UNSIGNED|LONG,UNSIGNED|LONG,0,UNSIGNED|LONG,0,1,0);
-  declare_builtin("__modsint32",LONG,LONG,0,LONG,0,1,0);
-  declare_builtin("__moduint32",UNSIGNED|LONG,UNSIGNED|LONG,0,UNSIGNED|LONG,0,1,0);
-  declare_builtin("__lsrsint32",LONG,LONG,0,INT,0,1,0);
-  declare_builtin("__lsruint32",UNSIGNED|LONG,UNSIGNED|LONG,0,INT,0,1,0);
-  declare_builtin("__cmpsint32",INT,LONG,0,LONG,0,1,0);
-  declare_builtin("__cmpuint32",INT,UNSIGNED|LONG,0,UNSIGNED|LONG,0,1,0);
-  declare_builtin("__sint32toflt32",FLOAT,LONG,0,0,0,1,0);
-  declare_builtin("__uint32toflt32",FLOAT,UNSIGNED|LONG,0,0,0,1,0);
-  declare_builtin("__sint32toflt64",DOUBLE,LONG,0,0,0,1,0);
-  declare_builtin("__uint32toflt64",DOUBLE,UNSIGNED|LONG,0,0,0,1,0);
-  declare_builtin("__flt32tosint32",LONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt32touint32",UNSIGNED|LONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64tosint32",LONG,DOUBLE,0,0,0,1,0);
-  declare_builtin("__flt64touint32",UNSIGNED|LONG,DOUBLE,0,0,0,1,0);
-
-
-
-  declare_builtin("__mulint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__addint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__subint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__andint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__orint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__eorint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__negint64",LLONG,LLONG,0,0,0,1,0);
-  declare_builtin("__lslint64",LLONG,LLONG,0,INT,0,1,0);
-
-  declare_builtin("__divsint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__divuint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__modsint64",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__moduint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__lsrsint64",LLONG,LLONG,0,INT,0,1,0);
-  declare_builtin("__lsruint64",UNSIGNED|LLONG,UNSIGNED|LLONG,0,INT,0,1,0);
-  declare_builtin("__cmpsint64",INT,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__cmpuint64",INT,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__sint64toflt32",FLOAT,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt32",FLOAT,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__sint64toflt64",DOUBLE,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt64",DOUBLE,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__flt32tosint64",LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt32touint64",UNSIGNED|LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64tosint64",LLONG,DOUBLE,0,0,0,1,0);
-  declare_builtin("__flt64touint64",UNSIGNED|LLONG,DOUBLE,0,0,0,1,0);
-
-  declare_builtin("__flt32toflt64",DOUBLE,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64toflt32",FLOAT,DOUBLE,0,0,0,1,0);
-
-
-  declare_builtin("__addflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__subflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__mulflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__divflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__negflt32",FLOAT,FLOAT,0,FLOAT,0,1,0);
-  declare_builtin("__cmpflt32",INT,FLOAT,0,FLOAT,0,1,0);
-
-  declare_builtin("__addflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__subflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__mulflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__divflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__negflt64",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-  declare_builtin("__cmpflt64",INT,DOUBLE,0,DOUBLE,0,1,0);
-
-
   return 1;
 }
 
@@ -1261,57 +1186,46 @@
 
 /* Return name of library function, if this node should be
    implemented via libcall. */
-char *use_libcall(int c,int t,int t2)
+char *use_libcall(np p)
 {
   static char fname[16];
   char *ret=0;
-
-  if(c==COMPARE){
-    if((t&NQ)==LONG||(t&NQ)==LLONG||ISFLOAT(t)){
-      sprintf(fname,"__cmp%s%s%ld",(t&UNSIGNED)?"u":"s",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
+  if((p->flags>=LSHIFT&&p->flags<=MOD)||(p->flags>=OR&&p->flags<=AND)||p->flags==PMULT){
+    int f=p->ntyp->flags&NU;
+    if(f==FLOAT){
+      sprintf(fname,"__%sfs",ename[p->flags]);
+      ret=fname;
+    }else if(f==DOUBLE||f==LDOUBLE){
+      sprintf(fname,"__%sfd",ename[p->flags]);
+      ret=fname;
+    }else if(f==(UNSIGNED|LONG)&&(p->flags==DIV||p->flags==MOD)){
+      sprintf(fname,"__%sul",ename[p->flags]);
+      ret=fname;
+    }else if(f==(UNSIGNED|LLONG)&&(p->flags==DIV||p->flags==MOD)){
+      sprintf(fname,"__%sull",ename[p->flags]);
+      ret=fname;
+    }else if((f&NQ)==LONG){
+      sprintf(fname,"__%sl",ename[p->flags]);
+      ret=fname;
+    }else if((f&NQ)==LLONG){
+      sprintf(fname,"__%sll",ename[p->flags]);
       ret=fname;
-    }
-  }else{
-    t&=NU;
-    t2&=NU;
-    if(t==LDOUBLE) t=DOUBLE;
-    if(t2==LDOUBLE) t2=DOUBLE;
-    if(c==CONVERT){
-      if(t==t2) return 0;
-      if(t==FLOAT&&t2==DOUBLE) return "__flt64toflt32";
-      if(t==DOUBLE&&t2==FLOAT) return "__flt32toflt64";
-
-      if(ISFLOAT(t)){
-        sprintf(fname,"__%cint%ldtoflt%d",(t2&UNSIGNED)?'u':'s',zm2l(sizetab[t2&NQ])*8,(t==FLOAT)?32:64);
-        ret=fname;
-      }
-      if(ISFLOAT(t2)){
-        sprintf(fname,"__flt%dto%cint%ld",((t2&NU)==FLOAT)?32:64,(t&UNSIGNED)?'u':'s',zm2l(sizetab[t&NQ])*8);
-        ret=fname;
-      }
-    }
-    if((t&NQ)==LONG||(t&NQ)==LLONG||ISFLOAT(t)){
-      if((c>=LSHIFT&&c<=MOD)||(c>=OR&&c<=AND)||c==KOMPLEMENT||c==MINUS){
-	if(t==(UNSIGNED|LLONG)&&(c==DIV||c==MOD||c==RSHIFT)){
-	  sprintf(fname,"__%suint64",ename[c]);
-	  ret=fname;
-	}else if((t&NQ)==LLONG){
-          sprintf(fname,"__%sint64",ename[c]);
-          ret=fname;
-	}else if(t==(UNSIGNED|LONG)&&(c==DIV||c==MOD||c==RSHIFT)){
-	  sprintf(fname,"__%suint32",ename[c]);
-	  ret=fname;
-	}else if((t&NQ)==LONG){
-          sprintf(fname,"__%sint32",ename[c]);
-          ret=fname;
-        }else{
-	  sprintf(fname,"__%s%s%s%ld",ename[c],(t&UNSIGNED)?"u":"",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
-          ret=fname;
-	}
-      }
     }
   }
 
+  if(ret){
+    /* declare function if necessary */
+    struct struct_declaration *sd;struct Typ *t;struct Var *v;
+    if(!find_ext_var(ret)){
+      sd=mymalloc(sizeof(*sd));
+      sd->count=0;
+      t=new_typ();
+      t->flags=FUNKT;
+      t->exact=add_sd(sd,FUNKT);
+      t->next=clone_typ(p->ntyp);
+      add_var(ret,t,EXTERN,0);  
+    }
+  }
   return ret;
 }
 
diff -Naur vbcc/machines/i386/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/i386/machine.c
--- vbcc/machines/i386/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/i386/machine.c	Tue Sep 22 04:18:49 2015
@@ -675,33 +675,6 @@
   /*  -elf is specified we use .l%d and %s instead.               */
   if(g_flags[5]&USEDFLAG) labprefix=".l"; else idprefix="_";
   target_macros=marray;
-
-  declare_builtin("__mulll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__addll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__subll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__andll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__orll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__eorll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__negll",LLONG,LLONG,0,0,0,1,0);
-  declare_builtin("__lslll",LLONG,LLONG,0,INT,0,1,0);
-
-  declare_builtin("__divll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__divull",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__modll",LLONG,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__modull",UNSIGNED|LLONG,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__lsrll",LLONG,LLONG,0,INT,0,1,0);
-  declare_builtin("__lsrull",UNSIGNED|LLONG,UNSIGNED|LLONG,0,INT,0,1,0);
-  declare_builtin("__cmpll",INT,LLONG,0,LLONG,0,1,0);
-  declare_builtin("__cmpull",INT,UNSIGNED|LLONG,0,UNSIGNED|LLONG,0,1,0);
-  declare_builtin("__sint64toflt32",FLOAT,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt32",FLOAT,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__sint64toflt64",DOUBLE,LLONG,0,0,0,1,0);
-  declare_builtin("__uint64toflt64",DOUBLE,UNSIGNED|LLONG,0,0,0,1,0);
-  declare_builtin("__flt32tosint64",LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt32touint64",UNSIGNED|LLONG,FLOAT,0,0,0,1,0);
-  declare_builtin("__flt64tosint64",LLONG,DOUBLE,0,0,0,1,0);
-  declare_builtin("__flt64touint64",UNSIGNED|LLONG,DOUBLE,0,0,0,1,0);
-
   return 1;
 }
 
@@ -798,38 +771,45 @@
 
 /* Return name of library function, if this node should be
    implemented via libcall. */
-char *use_libcall(int c,int t,int t2)
+char *use_libcall(np p)
 {
   static char fname[16];
   char *ret=0;
-
-  if(c==COMPARE){
-    if((t&NQ)==LLONG){
-      sprintf(fname,"__cmp%sll",(t&UNSIGNED)?"u":"");
+  int f;
+  if(p->flags>=EQUAL&&p->flags<=GREATEREQ){
+    extern struct Typ *arith_typ();
+    struct Typ *t=arith_typ(p->left->ntyp,p->right->ntyp);
+    f=t->flags&NU;
+    freetyp(t);
+    if((f&NQ)==LLONG){
+      sprintf(fname,"__cmp%s%sll",ename[p->flags],(f&UNSIGNED)&&p->flags!=EQUAL&&p->flags!=INEQUAL?"u":"");
       ret=fname;
     }
   }else{
-    t&=NU;
-    if(c==CONVERT){
-      if(ISFLOAT(t)&&(t2&NU)==LLONG){
-	sprintf(fname,"__%cint64toflt%d",(t2&UNSIGNED)?'u':'s',(t==FLOAT)?32:64);
-	ret=fname;
-      }
-      if(ISFLOAT(t2)&&(t&NU)==LLONG){
-	sprintf(fname,"__flt%dto%cint64",((t2&NU)==FLOAT)?32:64,(t&UNSIGNED)?'u':'s');
-	ret=fname;
-      }
-    }
-    if((t&NQ)==LLONG){
-      if((c>=LSHIFT&&c<=MOD)||(c>=OR&&c<=AND)||c==PMULT||(c>=EQUAL&&c<=GREATEREQ)||c==KOMPLEMENT||c==MINUS){
-	if(t==(UNSIGNED|LLONG)&&(c==DIV||c==MOD||c==RSHIFT)){
-	  sprintf(fname,"__%sull",ename[c]);
+    f=p->ntyp->flags&NU;
+    if((f&NQ)==LLONG){
+      if((p->flags>=LSHIFT&&p->flags<=MOD)||(p->flags>=OR&&p->flags<=AND)||p->flags==PMULT||(p->flags>=EQUAL&&p->flags<=GREATEREQ)||p->flags==KOMPLEMENT||p->flags==MINUS){
+	if(f==(UNSIGNED|LLONG)&&(p->flags==DIV||p->flags==MOD||p->flags==RSHIFT)){
+	  sprintf(fname,"__%sull",ename[p->flags]);
 	  ret=fname;
-	}else if((t&NQ)==LLONG){
-	  sprintf(fname,"__%sll",ename[c]);
+	}else if((f&NQ)==LLONG){
+	  sprintf(fname,"__%sll",ename[p->flags]);
 	  ret=fname;
-	}else printf("un %d\n",c);
+	}else printf("un %d\n",p->flags);
       }
+    }
+  }
+  if(ret){
+    /* declare function if necessary */
+    struct struct_declaration *sd;struct Typ *t;struct Var *v;
+    if(!find_ext_var(ret)){
+      sd=mymalloc(sizeof(*sd));
+      sd->count=0;
+      t=new_typ();
+      t->flags=FUNKT;
+      t->exact=add_sd(sd,FUNKT);
+      t->next=clone_typ(p->ntyp);
+      add_var(ret,t,EXTERN,0);  
     }
   }
   return ret;
diff -Naur vbcc/machines/m68k/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/m68k/machine.c
--- vbcc/machines/m68k/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/m68k/machine.c	Tue Sep 22 04:18:49 2015
@@ -1,11 +1,9 @@
 /*  Code generator for Motorola 680x0 CPUs. Supports 68000-68060+68881/2    */
 /*  and ColdFire.                                                           */
-/*  vasm, PhxAss and the GNU assembler is supported.                        */
+/*  Vasm, PhxAss and the GNU assembler is supported.                        */
 
 #include "supp.h"
 
-#define NEW_RET 0
-
 static char FILE_[]=__FILE__;
 
 #include "dwarf2.c"
@@ -13,16 +11,16 @@
 /*  Public data that MUST be there.                             */
 
 /* Name and copyright. */
-char cg_copyright[]="vbcc code-generator for m68k/ColdFire V1.10 (c) in 1995-2014 by Volker Barthelmann";
+char cg_copyright[]="vbcc code-generator for m68k/ColdFire V1.8 (c) in 1995-2010 by Volker Barthelmann";
 
 /*  Commandline-flags the code-generator accepts                */
-int g_flags[MAXGF]={VALFLAG,VALFLAG,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+int g_flags[MAXGF]={VALFLAG,VALFLAG,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
 char *g_flags_name[MAXGF]={
     "cpu","fpu","d2scratch","noa4","sc","sd","prof","const-in-data",
     "use-framepointer","no-peephole","no-delayed-popping",
     "gas","branch-opt","no-fp-return","no-mreg-return","hunkdebug",
     "no-intz","old-peephole","conservative-sr","elf","use-commons",
-    "a2scratch","old-softfloat","amiga-softfloat","fastcall","fp2scratch"
+    "a2scratch"
 };
 
 union ppi g_flags_val[MAXGF];
@@ -74,8 +72,6 @@
 
 int reg_prio[MAXR+1]={0,4,4,3,3,3,3,3,0,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0};
 
-struct reg_handle empty_reg_handle={0,0,0};
-
 /* Names of target-specific variable attributes.                */
 char *g_attr_name[]={"__far","__near","__chip","__saveds",
                      "__interrupt","__amigainterrupt","__stdargs",0};
@@ -114,10 +110,6 @@
 #define ELF             (g_flags[19]&USEDFLAG)
 #define USE_COMMONS     (g_flags[20]&USEDFLAG)
 #define A2SCRATCH       (g_flags[21]&USEDFLAG)
-#define OLD_SOFTFLOAT   (g_flags[22]&USEDFLAG)
-#define AMI_SOFTFLOAT   (g_flags[23]&USEDFLAG)
-#define FASTCALL        (g_flags[24]&USEDFLAG)
-#define FP2SCRATCH      (g_flags[25]&USEDFLAG)
 
 
 static int use_sd;
@@ -189,7 +181,6 @@
 static int comptyp;
 static int pushflag;
 static int geta4;
-static int dscratch=1,ascratch=1,fscratch=1;
 
 #define D16OFF 1024
 
@@ -218,8 +209,6 @@
   }
   if(D2SCRATCH) BSET(regs_modified,d2);
   if(A2SCRATCH) BSET(regs_modified,a2);
-  if(FP2SCRATCH) BSET(regs_modified,fp2);
-
 }
 
 static long pof2(zumax x)
@@ -255,7 +244,6 @@
 static struct obj *cc_set,*cc_set_tst;
 static int cc_typ,cc_typ_tst;
 static int missing,savedemit,savedalloc;
-static int lastpush,unorderedpush,pushoff[MAXR+1];
 
 static int special_section(FILE *f,struct Var *v)
 {
@@ -402,20 +390,13 @@
 	}
       }
       regs[i]+=4;
-      if(i<lastpush){
-	unorderedpush=1;
-	/*printf("%s %s\n",mregnames[lastpush],mregnames[i]);*/
-      }
       if(i<fp0){
 	emit(f,"\tmove.l\t%s,-(%s)\n",mregnames[i],mregnames[sp]);
 	push(4);
-	pushoff[i]=pushoff[lastpush]+4;
       }else{
 	emit(f,"\tfmove.x\t%s,-(%s)\n",mregnames[i],mregnames[sp]);
 	push(12);
-	pushoff[i]=pushoff[lastpush]+12;
       }
-      lastpush=i;
       if(i<d0)
 	pushedreg|=2;
       else if(i<fp0)
@@ -601,31 +582,20 @@
     if(regs[i]&4){
       regs[i]&=~4;
       if(i>=1&&i<=d7){
-	if(unorderedpush)
-	  emit(f,"\tmove%s.l\t%d(%s),%s\n",s,pushoff[lastpush]-pushoff[i],mregnames[sp],mregnames[i]);
-	else{
-	  if(cf&&*s=='m'){
-	    emit(f,"\tmove%s.l\t(%s),%s\n\taddq.l\t#4,%s\n",s,mregnames[sp],mregnames[i],mregnames[sp]);
-	  }else{
-	    emit(f,"\tmove%s.l\t(%s)+,%s\n",s,mregnames[sp],mregnames[i]);
-	  }
+	if(cf&&*s=='m'){
+	  emit(f,"\tmove%s.l\t(%s),%s\n\taddq.l\t#4,%s\n",s,mregnames[sp],mregnames[i],mregnames[sp]);
+	}else{
+	  emit(f,"\tmove%s.l\t(%s)+,%s\n",s,mregnames[sp],mregnames[i]);
 	}
 	pop(4);size+=4;
       }else if(i>=fp0&&i<=fp7){
-	if(unorderedpush)
-	  emit(f,"\tfmove%s.x\t%d(%s),%s\n",s,pushoff[lastpush]-pushoff[i],mregnames[sp],mregnames[i]);
-	else
-	  emit(f,"\tfmove%s.x\t(%s)+,%s\n",s,mregnames[sp],mregnames[i]);
+	emit(f,"\tfmove%s.x\t(%s)+,%s\n",s,mregnames[sp],mregnames[i]);
 	pop(12);size+=12;
       }else if(i>=25&&i<=28){
-	if(unorderedpush)
-	  emit(f,"\tmovem.l\t%d(%s),%s\n",pushoff[lastpush]-pushoff[i],mregnames[sp],mregnames[i]);
-	else{
-	  if(cf)
-	    emit(f,"\tmovem.l\t(%s),%s\n\taddq.l\t#8,%s\n",mregnames[sp],mregnames[i],mregnames[sp]);
-	  else
-	    emit(f,"\tmovem.l\t(%s)+,%s\n",mregnames[sp],mregnames[i]);
-	}
+	if(cf)
+	  emit(f,"\tmovem.l\t(%s),%s\n\taddq.l\t#8,%s\n",mregnames[sp],mregnames[i],mregnames[sp]);
+	else
+	  emit(f,"\tmovem.l\t(%s)+,%s\n",mregnames[sp],mregnames[i]);
 	pop(8);size+=8;
       }else
 	ierror(0);
@@ -639,10 +609,6 @@
   if((pushedreg&12)&&(p->code==TEST||p->code==COMPARE))
     emit(f,"\ttst.b\t-%d(%s)\n",size+2,mregnames[sp]);
 #endif
-  if(unorderedpush)
-    emit(f,"\tadd%s.%c\t#%d,%s\n",pushoff[lastpush]<=8?"q":"",cf?'l':'w',pushoff[lastpush],mregnames[sp]);
-  lastpush=0;
-  unorderedpush=0;
 }
 static void emit_obj(FILE *f,struct obj *p,int t)
 /*  Write object.   */
@@ -924,7 +890,7 @@
     if(cf){
       if(GAS){
         if(popval)
-	  emit(f,"\t.equ\t%s%d,%u\n\tmovem.l\t(%s),#%u\n\tadd.l\t#%s%d%s,%s\n",labprefix,reglabel,pushval,mregnames[sp],popval,labprefix,offlabel,pushflag?"-4":"",mregnames[sp]);
+	  emit(f,"\t.equ\t%s%d,%u\n\tmovem.l\t(%s),#%u\n\tadd.l\t#%s%d,%s\n",labprefix,reglabel,pushval,mregnames[sp],popval,labprefix,offlabel,mregnames[sp]);
         else
 	  emit(f,"\t.equ\t%s%d,0\n",labprefix,reglabel);
       }else{
@@ -933,7 +899,7 @@
 	else
 	  emit(f,"%s%d\treg\n",labprefix,reglabel);
 	if(*popreglist)
-	  emit(f,"\tmovem.l\t(%s),%s\n\tadd.l\t#%s%d%s,%s\n",mregnames[sp],popreglist,labprefix,offlabel,pushflag?"-4":"",mregnames[sp]);
+	  emit(f,"\tmovem.l\t(%s),%s\n\tadd.l\t#%s%d,%s\n",mregnames[sp],popreglist,labprefix,offlabel,mregnames[sp]);
       }
     }else{
       if(GAS){
@@ -1238,26 +1204,6 @@
   }
 #endif
 }
-/* return non-zero if IC is implemented by a function call */
-static int islibcall(struct IC *p)
-{
-  int c=p->code,t=p->typf/NQ;
-  if((c==DIV||c==MOD)&&CPU<68020)
-    return 1;
-  if(t==LLONG&&c!=ADD&&c!=SUB&&c!=OR&&c!=AND&&c!=XOR&&c!=COMPARE)
-    return 1;
-  if(ISFLOAT(t)&&FPU<=68000)
-    return 1;
-  if(c==CONVERT){
-    if(t==LLONG||ISFLOAT(t)) 
-      return 1;
-    t=p->typf2&NQ;
-    if(t==LLONG||ISFLOAT(t))
-      return 1;
-  }
-  return 0;
-}
-
 static int new_peephole(struct IC *first)
 {
   int localused=0,c,r,t,c2;long sz;
@@ -1284,7 +1230,7 @@
 	  c2=p2->code;
 	  if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r&&(!(p2->q2.flags&REG)||p2->q2.reg!=r)&&(!(p2->z.flags&REG)||p2->z.reg!=r)&&(c2!=CONVERT||(q1typ(p2)&NQ)<=(ztyp(p2)&NQ))){
 	    t=(q1typ(p2)&NQ);
-	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q1typ(p2)&NQ],l2zm(sz))&&!islibcall(p2)){
+	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q1typ(p2)&NQ],l2zm(sz))){
 	      p2->q1.am=am=mymalloc(sizeof(*am));
 	      p2->q1.val.vmax=l2zm(0L);
 	      am->basereg=r;
@@ -1298,7 +1244,7 @@
 	  }
 	  if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r&&(!(p2->q1.flags&REG)||p2->q1.reg!=r)&&(!(p2->z.flags&REG)||p2->z.reg!=r)){
 	    t=(q2typ(p2)&NQ);
-	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q2typ(p2)&NQ],l2zm(sz))&&!islibcall(p2)){
+	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q2typ(p2)&NQ],l2zm(sz))){
 	      p2->q2.am=am=mymalloc(sizeof(*am));
 	      p2->q2.val.vmax=l2zm(0L);
 	      am->basereg=r;
@@ -1312,7 +1258,7 @@
 	  }
 	  if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r&&(!(p2->q2.flags&REG)||p2->q2.reg!=r)&&(!(p2->q1.flags&REG)||p2->q1.reg!=r)){
 	    t=(ztyp(p2)&NQ);
-	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[ztyp(p2)&NQ],l2zm(sz))&&!islibcall(p2)){
+	    if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[ztyp(p2)&NQ],l2zm(sz))){
 	      p2->z.am=am=mymalloc(sizeof(*am));
 	      p2->z.val.vmax=l2zm(0L);
 	      am->basereg=r;
@@ -1339,7 +1285,7 @@
       if((sz==1||sz==2||sz==4||sz==8)&&(ISINT(t)||ISPOINTER(t))&&t!=LLONG&&(!(p->q2.flags&REG)||p->q2.reg!=r)&&(!(p->z.flags&REG)||p->z.reg!=r)){
 	for(p2=p->next;p2;p2=p2->next){
 	  c2=p2->code;
-	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST&&!islibcall(p)){
+	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
 	    eval_const(&p2->q2.val,q2typ(p2));
 	    if(zmeqto(vmax,l2zm(sz))){
 	      p->q1.am=am=mymalloc(sizeof(*am));
@@ -1368,7 +1314,7 @@
       if((sz==1||sz==2||sz==4||sz==8)&&(ISINT(t)||ISPOINTER(t))&&t!=LLONG&&(!(p->q1.flags&REG)||p->q1.reg!=r)&&(!(p->z.flags&REG)||p->z.reg!=r)){
 	for(p2=p->next;p2;p2=p2->next){
 	  c2=p2->code;
-	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST&&!islibcall(p)){
+	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
 	    eval_const(&p2->q2.val,q2typ(p2));
 	    if(zmeqto(vmax,l2zm(sz))){
 	      p->q2.am=am=mymalloc(sizeof(*am));
@@ -1397,7 +1343,7 @@
       if((sz==1||sz==2||sz==4||sz==8)&&(ISINT(t)||ISPOINTER(t))&&t!=LLONG&&(!(p->q1.flags&REG)||p->q1.reg!=r)&&(!(p->q2.flags&REG)||p->q2.reg!=r)){
 	for(p2=p->next;p2;p2=p2->next){
 	  c2=p2->code;
-	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST&&!islibcall(p)){
+	  if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
 	    eval_const(&p2->q2.val,q2typ(p2));
 	    if(zmeqto(vmax,l2zm(sz))){
 	      p->z.am=am=mymalloc(sizeof(*am));
@@ -1500,7 +1446,6 @@
 		if(free_base) move_IC(use,free_base);
 		if(idx_ic){
 		  am->dreg=idx;
-		  if(ISHWORD(idx_ic->typf)) am->dreg|=128;
 		  if(free_idx) move_IC(use,free_idx);
 		  idx_ic->code=NOP;
 		  idx_ic->q1.flags=idx_ic->q2.flags=idx_ic->z.flags=0;
@@ -1593,9 +1538,6 @@
           else
             m=p2->z.reg;
           if(m==r){
-	    /* do not use addressing mode for libcalls */
-	    if(FPU<=68000&&o&&o==&use->z&&(ISFLOAT(use->typf)||ISFLOAT(use->typf2))&&use->code!=ASSIGN)
-	      break;
             if(o){
               o->am=am=mymalloc(sizeof(*am));
 	      o->val.vmax=l2zm(0L);
@@ -2043,7 +1985,7 @@
 {
     /*  wenn es keine Variable ist, kann man nichts aussagen    */
     long os;
-    if((o->flags&(DREFOBJ|VAR))!=VAR||o->am) return -1;
+    if((o->flags&(DREFOBJ|VAR))!=VAR||o->am) return 0;
     if(!o->v) ierror(0);
     os=zm2l(o->val.vmax);
     if(o->v->storage_class==AUTO||o->v->storage_class==REGISTER){
@@ -2065,7 +2007,7 @@
     emit(f,"\tmove.l\t%s,%s\n",mregnames[d0],mregnames[rp.r1]);
     emit(f,"\tmove.l\t%s,%s\n",mregnames[10],mregnames[rp.r2]);
   }else{
-    if(cf&&(o->flags&(REG|DREFOBJ))!=(REG|DREFOBJ)){
+    if(cf){
       emit(f,"\tmove.l\t%s,",mregnames[d0]);
       emit_obj(f,o,t);
       emit(f,"\n");
@@ -2300,7 +2242,6 @@
     }
     a1=alignment(q);
     if(c!=PUSH)  a2=alignment(z); else a2=0;
-    if(a1<0||a2<0) {a1=1;a2=2;}
     if((c==PUSH||(scratch&1))&&(q->flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&q->reg>=1&&q->reg<=8&&!q->am){
       qreg=q->reg;
       if(c==PUSH&&(a1&1)==0&&(a2&1)==0)
@@ -2542,7 +2483,6 @@
     if(ISPOINTER(told)) told=UNSIGNED|LONG;
     if(ISPOINTER(tnew)) tnew=UNSIGNED|LONG;
     if(ISFLOAT(told)){
-      if(!OLD_SOFTFLOAT) ierror(0);
       saveregs(f,p);
       assign(f,p,&p->q1,0,PUSH,msizetab[told&NQ],told);
       scratch_modified();
@@ -2725,7 +2665,7 @@
       return 1;
     }
     if(!isreg(z)&&compare_objects(&p->q1,&p->z)){
-      if(isreg(q2)||(isconst(q2)&&(c==ADD||c==SUB)&&!cf)){
+      if(isreg(q2)||(isconst(q2)&&(c==ADD||c==SUB))){
 	if(!r) r=get_reg(f,1,p);
 	emit(f,"\t%s\t",sl);
 	emit_lword(f,&p->q2);
@@ -2956,16 +2896,6 @@
   return 1;
 }
 
-/* generate inlines for Amiga IEEE softcalls */
-static char *ami_ieee(char *base,int off)
-{
-  char *s;
-  if(cf) ierror(0);
-  s=mymalloc(128);
-  sprintf(s,"\tmove.l\t%s,-(%s)\n\tmove.l\t%sMathIeee%sBase,%s\n\tjsr\t%d(%s)\n\tmove.l\t(%s)+,%s",mregnames[a6],mregnames[sp],idprefix,base,mregnames[a6],off,mregnames[a6],mregnames[sp],mregnames[a6]);
-  return s;
-}
-
 /****************************************/
 /*  End of private fata and functions.  */
 /****************************************/
@@ -3015,11 +2945,8 @@
     /*  no FPU by default       */
     if(!(g_flags[1]&USEDFLAG)) FPU=0;
     if(FPU<=68000) {x_t[FLOAT]='l';}
-    if(D2SCRATCH){regscratch[d2]=1;dscratch++;}
-    if(A2SCRATCH) {regscratch[a2]=1;ascratch++;}
-    if(FP2SCRATCH) {regscratch[fp2]=1;fscratch++;}
-
-
+    if(D2SCRATCH) regscratch[11]=1;
+    if(A2SCRATCH) regscratch[3]=1;
     if(NOA4) regsa[5]=1;
     if(GAS){
         codename="\t.text\n";
@@ -3110,118 +3037,6 @@
     marray[5]=0;
     target_macros=marray;
 
-    if(AMI_SOFTFLOAT&&!optsize){
-      declare_builtin("_ieeeaddl",FLOAT,FLOAT,d0,FLOAT,d1,1,ami_ieee("SingBas",-66));
-      declare_builtin("_ieeesubl",FLOAT,FLOAT,d0,FLOAT,d1,1,ami_ieee("SingBas",-72));
-      declare_builtin("_ieeemull",FLOAT,FLOAT,d0,FLOAT,d1,1,ami_ieee("SingBas",-78));
-      declare_builtin("_ieeedivl",FLOAT,FLOAT,d0,FLOAT,d1,1,ami_ieee("SingBas",-84));
-      declare_builtin("_ieeenegl",FLOAT,FLOAT,d0,0,0,1,ami_ieee("SingBas",-60));
-      declare_builtin("_ieeeaddd",DOUBLE,DOUBLE,d0d1,DOUBLE,d2d3,1,ami_ieee("DoubBas",-66));
-      declare_builtin("_ieeesubd",DOUBLE,DOUBLE,d0d1,DOUBLE,d2d3,1,ami_ieee("DoubBas",-72));
-      declare_builtin("_ieeemuld",DOUBLE,DOUBLE,d0d1,DOUBLE,d2d3,1,ami_ieee("DoubBas",-78));
-      declare_builtin("_ieeedivd",DOUBLE,DOUBLE,d0d1,DOUBLE,d2d3,1,ami_ieee("DoubBas",-84));
-      declare_builtin("_ieeenegd",DOUBLE,DOUBLE,d0d1,0,0,1,ami_ieee("DoubBas",-60));
-      declare_builtin("_ieees2d",DOUBLE,FLOAT,d0,0,0,1,ami_ieee("DoubTrans",-108));
-      declare_builtin("_ieeed2s",FLOAT,DOUBLE,d0d1,0,0,1,ami_ieee("DoubTrans",-102));
-      declare_builtin("_ieeefltsl",FLOAT,LONG,d0,0,0,1,ami_ieee("SingBas",-36));
-      declare_builtin("_ieeefltsd",DOUBLE,LONG,d0,0,0,1,ami_ieee("DoubBas",-36));
-      declare_builtin("_ieeefltul",FLOAT,UNSIGNED|LONG,0,0,0,1,0);
-      declare_builtin("_ieeefltud",DOUBLE,UNSIGNED|LONG,0,0,0,1,0);
-      declare_builtin("_ieeefixlsl",LONG,FLOAT,d0,0,0,1,ami_ieee("SingBas",-30));
-      declare_builtin("_ieeefixlsw",SHORT,FLOAT,d0,0,0,1,ami_ieee("SingBas",-30));
-      declare_builtin("_ieeefixlsb",CHAR,FLOAT,d0,0,0,1,ami_ieee("SingBas",-30));
-      declare_builtin("_ieeefixdsl",LONG,DOUBLE,d0d1,0,0,1,ami_ieee("DoubBas",-30));
-      declare_builtin("_ieeefixdsw",SHORT,DOUBLE,d0d1,0,0,1,ami_ieee("DoubBas",-30));
-      declare_builtin("_ieeefixdsb",CHAR,DOUBLE,d0d1,0,0,1,ami_ieee("DoubBas",-30));
-      declare_builtin("_ieeefixlul",UNSIGNED|LONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixluw",UNSIGNED|SHORT,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixlub",UNSIGNED|CHAR,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixdul",UNSIGNED|LONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixduw",UNSIGNED|SHORT,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixdub",UNSIGNED|CHAR,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeecmpl",INT,FLOAT,d0,FLOAT,d1,1,ami_ieee("SingBas",-42));
-      declare_builtin("_ieeecmpd",INT,DOUBLE,d0d1,DOUBLE,d2d3,1,ami_ieee("DoubBas",-42));
-#if 0
-      declare_builtin("_ieeecmpllt",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplle",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplgt",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplge",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmpleq",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplneq",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmpdlt",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdle",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdgt",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdge",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdeq",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdneq",INT,DOUBLE,0,DOUBLE,0,1,0);
-#endif
-      declare_builtin("_ieeetstl",INT,FLOAT,d0,0,0,1,ami_ieee("SingBas",-48));
-      declare_builtin("_ieeetstd",INT,DOUBLE,d0d1,0,0,1,ami_ieee("DoubBas",-48));
-      declare_builtin("_flt32tosint64",LLONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_flt64tosint64",LLONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_flt32touint64",UNSIGNED|LLONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_flt64touint64",UNSIGNED|LLONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_sint64toflt32",FLOAT,LLONG,0,0,0,1,0);
-      declare_builtin("_sint64toflt64",DOUBLE,LLONG,0,0,0,1,0);
-      declare_builtin("_uint64toflt32",FLOAT,UNSIGNED|LLONG,0,0,0,1,0);
-      declare_builtin("_uint64toflt64",DOUBLE,UNSIGNED|LLONG,0,0,0,1,0);
-    }else{
-      declare_builtin("_ieeeaddl",FLOAT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeesubl",FLOAT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeemull",FLOAT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeedivl",FLOAT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeenegl",FLOAT,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeeaddd",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeesubd",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeemuld",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeedivd",DOUBLE,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeenegd",DOUBLE,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieees2d",DOUBLE,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeed2s",FLOAT,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefltsl",FLOAT,LONG,0,0,0,1,0);
-      declare_builtin("_ieeefltsd",DOUBLE,LONG,0,0,0,1,0);
-      declare_builtin("_ieeefltul",FLOAT,UNSIGNED|LONG,0,0,0,1,0);
-      declare_builtin("_ieeefltud",DOUBLE,UNSIGNED|LONG,0,0,0,1,0);
-      declare_builtin("_ieeefixlsl",LONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixlsw",SHORT,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixlsb",CHAR,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixdsl",LONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixdsw",SHORT,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixdsb",CHAR,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixlul",UNSIGNED|LONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixluw",UNSIGNED|SHORT,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixlub",UNSIGNED|CHAR,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeefixdul",UNSIGNED|LONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixduw",UNSIGNED|SHORT,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixdub",UNSIGNED|CHAR,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeefixdub",UNSIGNED|CHAR,DOUBLE,0,0,0,1,0);
-      declare_builtin("_ieeecmpl",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmpd",INT,DOUBLE,0,DOUBLE,0,1,0);
-#if 0
-      declare_builtin("_ieeecmpllt",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplle",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplgt",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplge",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmpleq",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmplneq",INT,FLOAT,0,FLOAT,0,1,0);
-      declare_builtin("_ieeecmpdlt",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdle",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdgt",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdge",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdeq",INT,DOUBLE,0,DOUBLE,0,1,0);
-      declare_builtin("_ieeecmpdneq",INT,DOUBLE,0,DOUBLE,0,1,0);
-#endif
-      declare_builtin("_ieeetstl",INT,FLOAT,0,0,0,1,0);
-      declare_builtin("_ieeetstd",INT,DOUBLE,0,0,0,1,0);
-      declare_builtin("_flt32tosint64",LLONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_flt64tosint64",LLONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_flt32touint64",UNSIGNED|LLONG,FLOAT,0,0,0,1,0);
-      declare_builtin("_flt64touint64",UNSIGNED|LLONG,DOUBLE,0,0,0,1,0);
-      declare_builtin("_sint64toflt32",FLOAT,LLONG,0,0,0,1,0);
-      declare_builtin("_sint64toflt64",DOUBLE,LLONG,0,0,0,1,0);
-      declare_builtin("_uint64toflt32",FLOAT,UNSIGNED|LLONG,0,0,0,1,0);
-      declare_builtin("_uint64toflt64",DOUBLE,UNSIGNED|LLONG,0,0,0,1,0);
-    }
 
     return 1;
 }
@@ -3237,35 +3052,23 @@
         else
             return d0;
     }
-    if(tu==DOUBLE||tu==LDOUBLE){
+    if(tu==DOUBLE){
         if(FPU>68000&&!NOFPRETURN){
             return fp0;
         }else{
             if(NOMREGRETURN) return 0;
-#if NEW_RET
-            return d0d1;
-#else
-	    return d0;
-#endif
+            return d0;
         }
     }
     if(tu==STRUCT||tu==UNION){
         if(!NOMREGRETURN){
             l=zm2l(szof(t));
-#if NEW_RET
-	    if(l==4) return d0;
-	    if(l==8) return d0d1;
-	    /* alte Variante; unschoen */
-	    if(l==12) return d0;
-	    if(l==16) return d0;
-#else
             if(l==4||l==8||l==12||l==16) return d0;
-#endif
         }
         return 0;
     }
     if(tu==LLONG)
-      return d0d1;
+      return 25;
     if(zmleq(szof(t),l2zm(4L))) return d0; else return 0;
 }
 int cost_savings(struct IC *p,int r,struct obj *o)
@@ -3916,7 +3719,7 @@
 #endif
       if(ISFLOAT(t)||ISFLOAT(to)){
 	if(FPU>68000){
-	  int zreg=0,freg=0;
+	  int zreg=0;
 	  if(ISFLOAT(t)&&ISFLOAT(to)){
 	    if(isreg(q1)&&isreg(z)){
 	      if(p->q1.reg!=p->z.reg)
@@ -3930,8 +3733,8 @@
 	    if(!zreg&&(t&UNSIGNED)&&!ISHWORD(t))
 	      zreg=p->q1.reg; 
 	    else 
-	      zreg=freg=get_reg(f,2,p);}
-	  if(!zreg) zreg=freg=get_reg(f,2,p);
+	      zreg=get_reg(f,2,p);}
+	  if(!zreg) zreg=get_reg(f,2,p);
 	  if((to&UNSIGNED)&&x_t[to&NQ]!='l'){
 	    int dreg=get_reg(f,1,p);
 	    emit(f,"\tmoveq\t#0,%s\n",mregnames[dreg]);
@@ -3953,13 +3756,6 @@
 		dreg1=get_reg(f,1,p);
 	      if(FPU==68040)
 		dreg2=get_reg(f,1,p);
-	      if(!freg){
-		if(!(isreg(q1)&&p->next&&p->next->code==FREEREG&&p->next->q1.reg==zreg)){
-		  freg=get_reg(f,2,p);
-		  emit(f,"\tfmove.x\t%s,%s\n",mregnames[zreg],mregnames[freg]);
-		  zreg=freg;
-		}		
-	      }
 	      emit(f,"\tfcmp.d\t#%s41e0000000000000,%s\n",s,mregnames[zreg]);
 	      emit(f,"\tfbge\t%s%d\n",labprefix,l1);
 	      if(FPU==68040){
@@ -4060,8 +3856,6 @@
 	    continue;
 	  }
 	  if((to&NQ)==FLOAT&&((t&NQ)==DOUBLE||(t&NQ)==LDOUBLE)){
-	    if(!OLD_SOFTFLOAT)
-	      ierror(0);
 	    saveregs(f,p);
 	    assign(f,p,&p->q1,0,PUSH,msizetab[FLOAT],FLOAT);
 	    scratch_modified();
@@ -4077,7 +3871,6 @@
 	    continue;
 	  }
 	  if(((to&NQ)==DOUBLE||(to&NQ)==LDOUBLE)&&(t&NQ)==FLOAT){
-	    if(!OLD_SOFTFLOAT) ierror(0);
 	    saveregs(f,p);
 	    assign(f,p,&p->q1,0,PUSH,msizetab[DOUBLE],DOUBLE);
 	    scratch_modified();
@@ -4094,7 +3887,6 @@
 	  }
 	  if(ISFLOAT(to)){
 	    int uns;
-	    if(!OLD_SOFTFLOAT) ierror(0);
 	    saveregs(f,p);
 	    if(t&UNSIGNED) uns='u'; else uns='s';
 	    assign(f,p,&p->q1,0,PUSH,sizetab[to&NQ],to);
@@ -4111,7 +3903,6 @@
 	    continue;
 	  }else{
 	    int uns,xt=x_t[to&NQ];
-	    if(!OLD_SOFTFLOAT) ierror(0);
 	    saveregs(f,p);
 	    if(to&UNSIGNED) uns='u'; else uns='s';
 	    if(xt!='l'){
@@ -4156,20 +3947,11 @@
 	    emit(f,"\tand.%c\t#%lu,%s\n",cf?'l':x_t[t&NQ],l,mregnames[zreg]);
 	    continue;
 	  }
-	  if((to&UNSIGNED)&&p->q1.am&&(zreg==p->q1.am->basereg||zreg==(p->q1.am->dreg&127))){
-	    /*  aufpassen, falls unsigned und Ziel im am  */
-	    unsigned long l;
-	    if((to&NQ)==CHAR) l=0xff; else l=0xffff;
-	    move(f,&p->q1,0,0,zreg,to);
-	    emit(f,"\tand.%c\t#%lu,%s\n",cf?'l':x_t[t&NQ],l,mregnames[zreg]);
-	  }else{
-	    if(to&UNSIGNED)
-	      emit(f,"\tmoveq\t#0,%s\n",mregnames[zreg]);
-	    move(f,&p->q1,0,0,zreg,to);
-	  }
+	  if(to&UNSIGNED) emit(f,"\tmoveq\t#0,%s\n",mregnames[zreg]);
+	  move(f,&p->q1,0,0,zreg,to);
 	  if(!(to&UNSIGNED)){
 #ifdef M68K_16BIT_INT
-	    if((to&NQ)==CHAR&&((t&NQ)==SHORT||(t&NQ)==INT)) emit(f,"\text.w\t%s\n",mregnames[zreg]);
+	    if((to&NQ)==CHAR&&((to&NQ)==SHORT||(t&NQ)==INT)) emit(f,"\text.w\t%s\n",mregnames[zreg]);
 	    if(((to&NQ)==SHORT||(to&NQ)==INT)&&msizetab[t&NQ]==4) emit(f,"\text.l\t%s\n",mregnames[zreg]);
 #else
 	    if((to&NQ)==CHAR&&(t&NQ)==SHORT) emit(f,"\text.w\t%s\n",mregnames[zreg]);
@@ -4220,7 +4002,6 @@
 	  }
 	  continue;
 	}else{
-	  if(!OLD_SOFTFLOAT) ierror(0);
 	  saveregs(f,p);
 	  assign(f,p,&p->q1,0,PUSH,msizetab[t&NQ],t);
 	  scratch_modified();
@@ -4299,7 +4080,7 @@
     }
     if(c==GETRETURN){
       /*  Returnwert holen - q2.val.vmax==size, q1.reg==Returnregister     */
-      if(((t&NQ)==DOUBLE||(t&NQ)==LDOUBLE)&&(p->q1.reg==d0||p->q1.reg==d0d1)){
+      if(((t&NQ)==DOUBLE||(t&NQ)==LDOUBLE)&&p->q1.reg==d0){
 	if(isreg(z)&&p->z.reg>=fp0&&p->z.reg<=fp7){
 	  emit(f,"\tmovem.l\t%s,-(%s)\n\tfmove.d\t(%s)+,%s\n",mregnames[d0d1],mregnames[sp],mregnames[sp],mregnames[p->z.reg]);
 	}else{
@@ -4327,19 +4108,6 @@
       continue;
     }
     if(c==CALL){
-      if((p->q1.flags&(VAR|DREFOBJ))==VAR&&!strcmp("__va_start",p->q1.v->identifier)){
-	int sr=(USEFRAMEPOINTER||vlas)?fbp:sp;
-	long va_off=0;
-	if(USEFRAMEPOINTER||vlas){
-	  emit(f,"\tmove.l\t%s,%s\n",mregnames[fbp],mregnames[d0]);
-	  emit(f,"\tadd.l\t#%ld,%s\n",(long)(8+zm2l(va_offset(v)))+(PROFILER?16:0),mregnames[d0]);
-	}else{
-	  emit(f,"\tmove.l\t%s,%s\n",mregnames[sp],mregnames[d0]);
-	  emit(f,"\tadd.l\t#%s%d+%ld,%s\n",labprefix,offlabel,(long)(4+zm2l(va_offset(v)))+loff+(PROFILER?16:0),mregnames[d0]);
-	}
-	BSET(regs_modified,d0);
-	continue;
-      }
       if((p->q1.flags&VAR)&&p->q1.v->fi&&p->q1.v->fi->inline_asm){
 	emit_inline_asm(f,p->q1.v->fi->inline_asm);
 	if(stack_valid&&(p->q1.flags&(VAR|DREFOBJ))==VAR&&p->q1.v->fi&&(p->q1.v->fi->flags&ALL_STACK))
@@ -4424,7 +4192,6 @@
       if(ISFLOAT(t)&&FPU<=68000){
 	/*  nicht sehr schoen   */
 	int result=get_reg(f,1,p);
-	if(!OLD_SOFTFLOAT) ierror(0);
 	saveregs(f,p);
 	assign(f,p,&p->q1,0,PUSH,msizetab[t&NQ],t);
 	scratch_modified();
@@ -4511,7 +4278,6 @@
 	}else{
 	  /*  nicht sehr schoen   */
 	  int result=get_reg(f,1,p);
-	  if(!OLD_SOFTFLOAT) ierror(0);
 	  saveregs(f,p);
 	  assign(f,p,&p->q2,0,PUSH,msizetab[t&NQ],t);
 	  assign(f,p,&p->q1,0,PUSH,msizetab[t&NQ],t);
@@ -4729,7 +4495,6 @@
 	  }
 	  continue;
 	}else{
-	  if(!OLD_SOFTFLOAT) ierror(0);
 	  saveregs(f,p);
 	  assign(f,p,&p->q2,0,PUSH,msizetab[t&NQ],t);
 	  assign(f,p,&p->q1,0,PUSH,msizetab[t&NQ],t);
@@ -5066,6 +4831,8 @@
   int entries,i,r1,r2,r3,r4;
   char *asmline[EMIT_BUF_DEPTH],c1,c2,c3,c4,e;
 
+  return 0;
+  
   if(OLDPEEPHOLE) return 0;
   i=emit_l;
   if(emit_f==0)
@@ -5080,20 +4847,19 @@
     if(sscanf(asmline[1],"\tmove.l\t(a7)+,%c%d\n%c",&c1,&r1,&e)==2&&
        sscanf(asmline[0],"\tmove.l\t%c%d,-(a7%c",&c2,&r2,&e)==3&&
        c1==c2&&r1==r2&&(c1=='a'||c1=='d')&&r1>=0&&r1<=7&&e==')'){
-      sprintf(asmline[1],"\tmove.l\t(a7),%c%d\n",c1,r1);
       remove_asm();
-      savedemit++;
+      remove_asm();
+      savedemit+=2;
       return 1;
     }
     if(sscanf(asmline[1],"\tmovem.l\t(a7)+,%c%d\n%c",&c1,&r1,&e)==2&&
        sscanf(asmline[0],"\tmove.l\t%c%d,-(a7%c",&c2,&r2,&e)==3&&
        c1==c2&&r1==r2&&(c1=='a'||c1=='d')&&r1>=0&&r1<=7&&e==')'){
-      sprintf(asmline[1],"\tmove.l\t(a7),%c%d\n",c1,r1);
       remove_asm();
-      savedemit++;
+      remove_asm();
+      savedemit+=2;
       return 1;
     }
-
     if(sscanf(asmline[1],"\tmove.l\t%c%d,%c%d\n%c",&c1,&r1,&c2,&r2,&e)==4&&
        sscanf(asmline[0],"\tmove.l\t%c%d,%c%d\n%c",&c3,&r3,&c4,&r4,&e)==4&&
        c1==c4&&r1==r4&&c2==c3&&r2==r3&&r1>=0&&r1<=7&&r2>=0&&r2<=7&&
@@ -5104,88 +4870,4 @@
     }
   }
   return 0;
-}
-
-char *use_libcall(int c,int t,int t2)
-{
-  static char fname[32];
-  char *ret=0;
-  int f;
-
-  if(FPU>68000){
-    if(c!=CONVERT) return 0;
-    if((!ISFLOAT(t)||(t2&NQ)!=LLONG)&&
-       (!ISFLOAT(t2)||(t&NQ)!=LLONG))
-      return 0;
-  }
-  if(OLD_SOFTFLOAT) return 0;
-  t&=NU;
-  t2&=NU;
-  if(t==LDOUBLE) t=DOUBLE;
-  if(t2==LDOUBLE) t2=DOUBLE;
-
-  if(c==COMPARE){
-    if(ISFLOAT(t)){
-      sprintf(fname,"_ieeecmp%c",x_t[t]);
-      ret=fname;
-    }
-  }else if(c==CONVERT){
-    if(t2==INT) t2=(sizetab[INT]==4?LONG:SHORT);
-    if(t2==(UNSIGNED|INT)) t2=(sizetab[INT]==4?(UNSIGNED|LONG):(UNSIGNED|SHORT));
-    if(t==FLOAT&&t2==DOUBLE) return "_ieeed2s";
-    if(t==DOUBLE&&t2==FLOAT) return "_ieees2d";
-    if(t==DOUBLE&&t2==DOUBLE) return 0;
-    if(t==FLOAT||t==DOUBLE){
-      if((t2&NQ)==LLONG)
-	sprintf(fname,"_%cint64toflt%s",(t2&UNSIGNED)?'u':'s',t==FLOAT?"32":"64");
-      else
-	sprintf(fname,"_ieeeflt%c%c",(t2&UNSIGNED)?'u':'s',x_t[t]);
-      ret=fname;
-    }
-    if(t2==FLOAT||t2==DOUBLE){
-      if((t&NQ)==LLONG)
-	sprintf(fname,"_flt%sto%cint64",t2==FLOAT?"32":"64",(t&UNSIGNED)?'u':'s');
-      else
-	sprintf(fname,"_ieeefix%c%c%c",x_t[t2],(t2&UNSIGNED)?'u':'s',x_t[t&NQ]);
-      ret=fname;
-    }
-  }else if(ISFLOAT(t)){
-    if(c==MINUS){
-      sprintf(fname,"_ieeeneg%c",x_t[t&NQ]);
-      ret=fname;
-    }else if(c>=ADD&&c<=DIV){
-      sprintf(fname,"_ieee%s%c",ename[c],x_t[t&NQ]);
-      ret=fname;
-    }
-    if(c==TEST){
-      sprintf(fname,"_ieeetst%c",x_t[t&NQ]);
-      ret=fname;
-    }
-  }
-  return ret;
-}
-
-int reg_parm(struct reg_handle *p,struct Typ *t,int mode,struct Typ *fkt)
-{
-  int f;
-  if(!FASTCALL) return 0;
-  f=t->flags&NQ;
-  if(mode||f==LLONG||!ISSCALAR(f))
-    return 0;
-  if(ISPOINTER(f)){
-    if(p->ar>ascratch)
-      return 0;
-    else
-      return a0+p->ar++;
-  }
-  if(ISFLOAT(f)){
-    if(FPU<=68000||p->fr>fscratch)
-      return 0;
-    else
-      return fp0+p->fr++;
-  }
-  if(p->dr>dscratch)
-    return 0;
-  else
-    return d0+p->dr++;
 }
diff -Naur vbcc/machines/m68k/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/m68k/machine.h
--- vbcc/machines/m68k/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/m68k/machine.h	Tue Sep 22 04:18:49 2015
@@ -77,13 +77,6 @@
 /* we have register-pairs */
 #define HAVE_REGPAIRS 1
 
-#define HAVE_REGPARMS 1
-
-struct reg_handle {
-  int dr,ar,fr;
-};
-
-
 #define JUMP_TABLE_DENSITY 0.8
 #define JUMP_TABLE_LENGTH 8
 
@@ -95,6 +88,3 @@
 #define FREEVLA_INLINEASM "\tmove.l\t(a7),a7\n\tsubq.l\t#4,a7"
 #define OLDSPVLA_INLINEASM "\tmove.l\ta7,d0"
 #define FPVLA_REG 6
-
-/* We use builtin libcalls for some operations */
-#define HAVE_LIBCALLS 1
diff -Naur vbcc/machines/ppc/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/ppc/machine.c
--- vbcc/machines/ppc/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/ppc/machine.c	Tue Sep 22 04:18:49 2015
@@ -21,7 +21,7 @@
                            "elf","amiga-align","no-regnames","no-peephole","setccs",
                            "use-lmw","poweropen","sc","madd","eabi","gas",
 			   "no-align-args","conservative-sr","use-commons",
-                           "baserel32os4","baserel32mos","oldlibcalls"};
+                           "baserel32os4","baserel32mos"};
 union ppi g_flags_val[MAXGF];
 
 /*  Alignment-requirements for all types in bytes.              */
@@ -115,7 +115,6 @@
 #define USE_COMMONS (g_flags[19]&USEDFLAG)
 #define BASERELOS4 (g_flags[20]&USEDFLAG)
 #define BASERELMOS (g_flags[21]&USEDFLAG)
-#define OLDLIBCALLS (g_flags[22]&USEDFLAG)
 
 
 static char *mregnames[MAXR+1];
@@ -134,9 +133,6 @@
 		       "__interrupt=__rfi __saveall",
 		       0};
 
-const int r4=5,r5=6,r6=7,r3r4=74,r5r6=75;
-
-
 static int r0=1;                   /*  special register                    */
 static int r2=3;                   /*  reserved or toc                     */
 static int r3=4;                   /*  return value                        */
@@ -427,7 +423,7 @@
       if(l)
 	emit(f,"\taddi\t%s,%s,%ld\n",mregnames[r],mregnames[r],l);
     }else{
-      emit(f,"\tli\t%s,%ld\n",mregnames[r],lo(vmax));
+      emit(f,"\tli\t%s,%ld\n",mregnames[r],zm2l(vmax));
     }
     return;
   }
@@ -1622,8 +1618,8 @@
 
 static int handle_llong(FILE *f,struct IC *p)
 {
+  const int r3=4,r4=5,r5=6,r6=7,r3r4=74,r5r6=75;
   int c=p->code,t,savemask=0;char *libfuncname;
-  int msp;long mtmpoff;
 
   t=(ztyp(p)&NU);
 
@@ -2079,20 +2075,12 @@
 
   create_loadable(f,&p->q1,t1);
 
-  if(tmpoff>=32768&&(regs[r3]||regs[r4]||regs[r5]||regs[r6])){
-    emit(f,"\taddis\t%s,%s,%ld\n",mregnames[t2],mregnames[sp],hi(tmpoff));
-    if(lo(tmpoff)) emit(f,"\taddi\t%s,%s,%ld\n",mregnames[t2],mregnames[t2],lo(tmpoff));
-    msp=t2;
-    mtmpoff=0;
-  }else{
-    msp=sp;
-    mtmpoff=tmpoff;
-  }
+  if(tmpoff>=32768) ierror(0);
 
-  if(regs[r3]){ emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r3],mtmpoff-4,mregnames[msp]);savemask|=1;}
-  if(regs[r4]){ emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r4],mtmpoff-8,mregnames[msp]);savemask|=2;}
-  if(regs[r5]) {emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r5],mtmpoff-12,mregnames[msp]);savemask|=4;}
-  if(regs[r6]) {emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r6],mtmpoff-16,mregnames[msp]);savemask|=8;}
+  if(regs[r3]){ emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r3],tmpoff-4,mregnames[sp]);savemask|=1;}
+  if(regs[r4]){ emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r4],tmpoff-8,mregnames[sp]);savemask|=2;}
+  if(regs[r5]) {emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r5],tmpoff-12,mregnames[sp]);savemask|=4;}
+  if(regs[r6]) {emit(f,"\tstw\t%s,%ld(%s)\n",mregnames[r6],tmpoff-16,mregnames[sp]);savemask|=8;}
 
   if((p->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p->q1.reg>=r3&&p->q1.reg<=r6){
     emit(f,"\tmr\t%s,%s\n",mregnames[t1],mregnames[p->q1.reg]);
@@ -2122,8 +2110,8 @@
     create_loadable(f,&p->q2,t2);
     if((q2typ(p)&NQ)==LLONG){
       if(isreg(q2)&&p->q2.reg==r3r4){
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],mtmpoff-4,mregnames[msp]);
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r6],mtmpoff-8,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],tmpoff-4,mregnames[sp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r6],tmpoff-8,mregnames[sp]);
       }else{
 	if(p->q2.am&&p->q2.am->base==r5){
 	  if(p->q2.am->flags==REG_IND&&p->q2.am->offset==r6) ierror(0);
@@ -2138,7 +2126,7 @@
     }else{
       if((q2typ(p)&NQ)>=LLONG) ierror(0);
       if(isreg(q2)&&p->q2.reg==r3){
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],mtmpoff-4,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],tmpoff-4,mregnames[sp]);
       }else{
 	load_reg(f,r5,&p->q2,q2typ(p),0);
       }      
@@ -2184,13 +2172,13 @@
        (p->z.reg==r5&&(savemask&4))||
        (p->z.reg==r6&&(savemask&8))){
       if(p->z.reg==r3)
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],mtmpoff-4,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],tmpoff-4,mregnames[sp]);
       else if(p->z.reg==r4)
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],mtmpoff-8,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],tmpoff-8,mregnames[sp]);
       else if(p->z.reg==r5)
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],mtmpoff-12,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],tmpoff-12,mregnames[sp]);
       else if(p->z.reg==r6)
-	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],mtmpoff-16,mregnames[msp]);
+	emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[t1],tmpoff-16,mregnames[sp]);
       else
 	ierror(0);
       p->z.reg=t1;
@@ -2221,13 +2209,13 @@
   }
 
   if(savemask&1)
-    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r3],mtmpoff-4,mregnames[msp]);
+    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r3],tmpoff-4,mregnames[sp]);
   if(savemask&2)
-    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r4],mtmpoff-8,mregnames[msp]);
+    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r4],tmpoff-8,mregnames[sp]);
   if(savemask&4)
-    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],mtmpoff-12,mregnames[msp]);
+    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r5],tmpoff-12,mregnames[sp]);
   if(savemask&8)
-    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r6],mtmpoff-16,mregnames[msp]);
+    emit(f,"\tlwz\t%s,%ld(%s)\n",mregnames[r6],tmpoff-16,mregnames[sp]);
   
   return 1;
 }
@@ -2339,15 +2327,6 @@
 
   target_macros=marray;
 
-  declare_builtin("__mulint64",LLONG,LLONG,r3r4,LLONG,r5r6,1,0);
-  declare_builtin("__divsint64",LLONG,LLONG,r3r4,LLONG,r5r6,1,0);
-  declare_builtin("__divuint64",UNSIGNED|LLONG,UNSIGNED|LLONG,r3r4,UNSIGNED|LLONG,r5r6,1,0);
-  declare_builtin("__modsint64",LLONG,LLONG,r3r4,LLONG,r5r6,1,0);
-  declare_builtin("__moduint64",UNSIGNED|LLONG,UNSIGNED|LLONG,r3r4,UNSIGNED|LLONG,r5r6,1,0);
-  declare_builtin("__lshint64",LLONG,LLONG,r3r4,INT,r5,1,0);
-  declare_builtin("__rshsint64",LLONG,LLONG,r3r4,INT,r5,1,0);
-  declare_builtin("__rshuint64",LLONG,UNSIGNED|LLONG,r3r4,INT,r5,1,0);
-
   return 1;
 }
 
@@ -3337,7 +3316,7 @@
       }else{
         if((p->q1.flags&(VAR|DREFOBJ))==VAR){
           if(!strcmp("__va_start",p->q1.v->identifier)){
-            emit(f,"\taddi\t%s,%s,%lu\n",mregnames[r3],mregnames[sp],framesize+minframe+zm2l(va_offset(v))/*+vparmos*/);
+            emit(f,"\taddi\t%s,%s,%lu\n",mregnames[r3],mregnames[sp],framesize+minframe+zm2l(va_offset(v))+vparmos);
             BSET(regs_modified,r3);continue;
           }
           if(!strcmp("__va_regbase",p->q1.v->identifier)){
@@ -3789,33 +3768,6 @@
       p->flags&=~EFF_IC;
   }
 }
-
-char *use_libcall(int c,int t,int t2)
-{
-  static char fname[32];
-  char *ret=0;
-
-  if(OLDLIBCALLS) return 0;
-
-  if((t&NQ)==LLONG){
-    ret=fname;
-    if(c==MULT)
-      sprintf(fname,"__mulint64");
-    else if(c==DIV)
-      sprintf(fname,"__div%cint64",(t&UNSIGNED)?'u':'s');
-    else if(c==MOD)
-      sprintf(fname,"__mod%cint64",(t&UNSIGNED)?'u':'s');
-    else if(c==RSHIFT)
-      sprintf(fname,"__rsh%cint64",(t&UNSIGNED)?'u':'s');
-    else if(c==LSHIFT)
-      sprintf(fname,"__lshint64");
-    else
-      ret=0;
-  }
-  return ret;
-}
-
-
 
 #if HAVE_OSEK
 /* removed */
diff -Naur vbcc/machines/ppc/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/ppc/machine.h
--- vbcc/machines/ppc/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/ppc/machine.h	Tue Sep 22 04:18:49 2015
@@ -106,9 +106,6 @@
 /* OSEK support */
 #define HAVE_OSEK 1
 
-/* We use builtin libcalls for some operations */
-#define HAVE_LIBCALLS 1
-
 /* support for variable-length arrays */
 #define ALLOCVLA_REG 4
 #if 0
diff -Naur vbcc/machines/vidcore/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.c
--- vbcc/machines/vidcore/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.c	Thu Jan  1 00:00:00 1970
@@ -1,1774 +0,0 @@
-/*  Backend for VideoCore IV
-    (c) in 2013 by Volker Barthelmann
-*/
-
-/* TODO:
-   - extended registers
-   - floating point
-   - long long
-   - memcpy
-   - addcmp
-   - bcc reg
-   - cond. ins
-   - vector
-   - non-pc addressing
-*/
-
-#include "supp.h"
-
-static char FILE_[]=__FILE__;
-
-/*  Public data that MUST be there.                             */
-
-/* Name and copyright. */
-char cg_copyright[]="vbcc VideoCore IV code-generator V0.1 (c) in 2013 by Volker Barthelmann";
-
-/* the flag-name, do not use names beginning with l, L, I, D or U, because
-   they collide with the frontend */
-char *g_flags_name[MAXGF]={"use-commons","use-framepointer",
-			   "short-double","one-section",
-			   "no-delayed-popping"};
-
-int g_flags[MAXGF]={0,0,
-		    0};
-
-/* the results of parsing the command-line-flags will be stored here */
-union ppi g_flags_val[MAXGF];
-
-/*  Alignment-requirements for all types in bytes.              */
-zmax align[MAX_TYPE+1];
-
-/*  Alignment that is sufficient for every object.              */
-zmax maxalign;
-
-/*  CHAR_BIT for the target machine.                            */
-zmax char_bit;
-
-/*  sizes of the basic types (in bytes) */
-zmax sizetab[MAX_TYPE+1];
-
-/*  Minimum and Maximum values each type can have.              */
-/*  Must be initialized in init_cg().                           */
-zmax t_min[MAX_TYPE+1];
-zumax t_max[MAX_TYPE+1];
-zumax tu_max[MAX_TYPE+1];
-
-/*  Names of all registers. will be initialized in init_cg(),
-    register number 0 is invalid, valid registers start at 1 */
-char *regnames[MAXR+1];
-
-/*  The Size of each register in bytes.                         */
-zmax regsize[MAXR+1];
-
-/*  a type which can store each register. */
-struct Typ *regtype[MAXR+1];
-
-/*  regsa[reg]!=0 if a certain register is allocated and should */
-/*  not be used by the compiler pass.                           */
-int regsa[MAXR+1];
-
-/*  Specifies which registers may be scratched by functions.    */
-int regscratch[MAXR+1];
-
-/* specifies the priority for the register-allocator, if the same
-   estimated cost-saving can be obtained by several registers, the
-   one with the highest priority will be used */
-int reg_prio[MAXR+1];
-
-/* an empty reg-handle representing initial state */
-struct reg_handle empty_reg_handle={0};
-
-/* Names of target-specific variable attributes.                */
-char *g_attr_name[]={"__interrupt",0};
-
-
-/****************************************/
-/*  Private data and functions.         */
-/****************************************/
-
-/* addressing modes */
-#define AM_IMM_IND 1
-#define AM_GPR_IND 2
-#define AM_POSTINC 3
-#define AM_PREDEC  4
-
-#define USE_COMMONS (g_flags[0]&USEDFLAG)
-#define USE_FP      (g_flags[1]&USEDFLAG)
-#define SHORT_DOUBLE (g_flags[2]&USEDFLAG)
-#define ONESEC      (g_flags[3]&USEDFLAG)
-#define NODELAYEDPOP (g_flags[4]&USEDFLAG)
-
-
-/* alignment of basic data-types, used to initialize align[] */
-static long malign[MAX_TYPE+1]=  {1,1,2,4,4,4,4,8,8,1,4,1,1,1,4,1};
-/* sizes of basic data-types, used to initialize sizetab[] */
-static long msizetab[MAX_TYPE+1]={1,1,2,4,4,8,4,8,8,0,4,0,0,0,4,0};
-
-/* used to initialize regtyp[] */
-static struct Typ ltyp={LONG},ldbl={DOUBLE},lchar={CHAR};
-
-/* macros defined by the backend */
-static char *marray[]={"__section(x)=__vattr(\"section(\"#x\")\")",
-		       "__VIDEOCORE__",
-		       0, /* __SHORT_DOUBLE__ */
-		       0};
-
-/* special registers */
-enum{
-  r0=1,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,
-  r16,r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31,
-  r0r1,r2r3,r4r5,r6r7,r8r9,r10r11,r12r13,r14r15,
-  r16r17,r18r19,r20r21,r22r23,r24r25,r26r27,r28r29,r30r31
-};
-
-static int sd=r24;
-static int sp=r25;
-static int lr=r26;
-static int sr=r30;
-static int pc=r31;
-static int t1=r15;
-static int t2=r14;
-
-static int last_saved;
-
-#define dt(t) (((t)&UNSIGNED)?udt[(t)&NQ]:sdt[(t)&NQ])
-#define sdt(t) (udt[(t)&NQ])
-static char *sdt[MAX_TYPE+1]={"??","b","hs","","","ll","","d","ld","v",""};
-static char *udt[MAX_TYPE+1]={"??","b","h","","","ull","","d","ld","v",""};
-
-static char *dct[]={"","byte","2byte","4byte","4byte","4byte","4byte","4byte","4byte"};
-
-static int no_suffix;
-
-/* sections */
-#define DATA 0
-#define BSS 1
-#define CODE 2
-#define RODATA 3
-#define SPECIAL 4
-
-static long stack;
-static int stack_valid;
-static int section=-1,newobj;
-static char *codename="\t.text\n",
-  *dataname="\t.data\n",
-  *bssname="",
-  *rodataname="\t.section\t.rodata\n";
-
-/* conditional execution */
-static char *cc;
-
-/* return-instruction */
-static char *ret;
-
-/* label at the end of the function (if any) */
-static int exit_label;
-
-/* assembly-prefixes for labels and external identifiers */
-static char *labprefix="l",*idprefix="_";
-
-#if 0
-/* variables to calculate the size and partitioning of the stack-frame
-   in the case of FIXED_SP */
-static long frameoffset,pushed,maxpushed,framesize;
-#else
-/* variables to keep track of the current stack-offset in the case of
-   a moving stack-pointer */
-static long notpopped,dontpop,stackoffset,maxpushed;
-#endif
-
-static long localsize,rsavesize,argsize;
-
-static void emit_obj(FILE *f,struct obj *p,int t);
-
-/* calculate the actual current offset of an object relativ to the
-   stack-pointer; we use a layout like this:
-   ------------------------------------------------
-   | arguments to this function                   |
-   ------------------------------------------------
-   | return-address [size=4]                      |
-   ------------------------------------------------
-   | caller-save registers [size=rsavesize]       |
-   ------------------------------------------------
-   | local variables [size=localsize]             |
-   ------------------------------------------------
-   | arguments to called functions [size=argsize] |
-   ------------------------------------------------
-   All sizes will be aligned as necessary.
-   In the case of FIXED_SP, the stack-pointer will be adjusted at
-   function-entry to leave enough space for the arguments and have it
-   aligned to 16 bytes. Therefore, when calling a function, the
-   stack-pointer is always aligned to 16 bytes.
-   For a moving stack-pointer, the stack-pointer will usually point
-   to the bottom of the area for local variables, but will move while
-   arguments are put on the stack.
-
-   This is just an example layout. Other layouts are also possible.
-*/
-
-static void push(long l)
-{
-  stackoffset-=l;
-  if(stackoffset<maxpushed) 
-    maxpushed=stackoffset;
-  if(-maxpushed>stack)
-    stack=-maxpushed;
-}
-
-static void pop(long l)
-{
-  stackoffset+=l;
-}
-
-static long real_offset(struct obj *o)
-{
-  long off=zm2l(o->v->offset);
-  if(off<0){
-    /* function parameter */
-    off=localsize+rsavesize-off-zm2l(maxalign);
-  }
-
-  off-=stackoffset;
-
-  off+=zm2l(o->val.vmax);
-  return off;
-}
-
-/*  Initializes an addressing-mode structure and returns a pointer to
-    that object. Will not survive a second call! */
-static struct obj *cam(int flags,int base,long offset)
-{
-  static struct obj obj;
-  static struct AddressingMode am;
-  obj.am=&am;
-  am.flags=flags;
-  am.base=base;
-  am.offset=offset;
-  return &obj;
-}
-
-/* changes to a special section, used for __section() */
-static int special_section(FILE *f,struct Var *v)
-{
-  char *sec;
-  if(!v->vattr) return 0;
-  sec=strstr(v->vattr,"section(");
-  if(!sec) return 0;
-  sec+=strlen("section(");
-  emit(f,"\t.section\t");
-  while(*sec&&*sec!=')') emit_char(f,*sec++);
-  emit(f,"\n");
-  if(f) section=SPECIAL;
-  return 1;
-}
-
-static unsigned long pushmask;
-
-static int ic_uses_reg(struct IC *p,int r,int onlyuses)
-{
-  if(reg_pair(r,&rp)){
-    return ic_uses_reg(p,rp.r1,onlyuses)||ic_uses_reg(p,rp.r2,onlyuses);
-  }
-  /*FIXME: handle regpairs */
-  if((p->q1.flags&REG)&&p->q1.reg==r) return 1;
-  if((p->q2.flags&REG)&&p->q2.reg==r) return 1;
-  if(onlyuses){
-    if((p->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p->z.reg==r) return 1;
-  }else{
-    if((p->z.flags&REG)&&p->z.reg==r) return 1;
-  }
-  if(p->q1.am){
-    if(p->q1.am->base==r) return 1;
-    if(p->q1.am->flags==AM_GPR_IND&&p->q1.am->offset==r) return 1;
-  }
-  if(p->q2.am){
-    if(p->q2.am->base==r) return 1;
-    if(p->q2.am->flags==AM_GPR_IND&&p->q2.am->offset==r) return 1;
-  }
-  if(p->z.am){
-    if(p->z.am->base==r) return 1;
-    if(p->z.am->flags==AM_GPR_IND&&p->z.am->offset==r) return 1;
-  }
-  return 0;
-}
-
-static int reg_is_scratched(struct IC *p,int r)
-{
-  for(p=p->next;p;p=p->next){
-    int c=p->code;
-    if(c>=LABEL&&c<=BRA)
-      return 0;
-    if(c==FREEREG&&p->q1.reg==r)
-      return 1;
-    if(ic_uses_reg(p,r,1))
-      return 0;
-    if((p->q1.flags&(REG|DREFOBJ))==REG&&p->z.reg==r)
-      return 1;
-  }    
-  return 0;
-}
-
-static int get_reg(FILE *f,struct IC *p)
-{
-  int r;
-  for(r=r0;r<=r31;r++){
-    if(!regs[r]&&regused[r]&&!ic_uses_reg(p,r,0)){
-      regs[r]=1;
-      return r;
-    }
-  }
-  for(r=r0;r<=r31;r++){
-    if(!regs[r]&&!ic_uses_reg(p,r,0)){
-      regs[r]=1;
-      return r;
-    }
-  }
-  for(r=r0;r<=r31;r++){
-    if(!ic_uses_reg(p,r,0))
-      break;
-  }
-  argsize+=4;
-  emit(f,"\tst\t%s,--(%s)\n",regnames[r],regnames[sp]);
-  push(4);
-  pushmask|=(1<<(r-1));
-  regs[r]=1;
-  return r;
-}
-
-static void free_reg(FILE *f,int r)
-{
-  if(pushmask&(1<<(r-1))){
-    emit(f,"\tld\t%s,(%s)++\n",regnames[r],regnames[sp]);
-    pop(4);
-    argsize-=4;
-  }else
-    regs[r]=0;
-  pushmask&=~(1<<(r-1));
-}
-
-/* generate code to load the address of a variable into register r */
-static void load_address(FILE *f,int r,struct obj *o,int type)
-/*  Generates code to load the address of a variable into register r.   */
-{
-  if(!(o->flags&VAR)) ierror(0);
-  if(o->v->storage_class==AUTO||o->v->storage_class==REGISTER){
-    long off=real_offset(o);
-    emit(f,"\tadd%s\t%s,%s,%ld\n",cc,regnames[r],regnames[sp],off);
-  }else{
-    emit(f,"\tlea%s\t%s,",cc,regnames[r]);
-    emit_obj(f,o,type);
-    emit(f,"\n");
-  }
-}
-/* Generates code to load a memory object into register r. tmp is a
-   general purpose register which may be used. tmp can be r. */
-static void load_reg(FILE *f,int r,struct obj *o,int type)
-{
-  type&=NU;
-  if(reg_pair(r,&rp)) ierror(0);
-  if(o->flags&VARADR){
-    load_address(f,r,o,POINTER);
-  }else if(o->flags&KONST){
-    emit(f,"\tmov%s\t%s,",cc,regnames[r]);
-    emit_obj(f,o,type);
-    emit(f,"\n");
-  }else{
-    if((o->flags&(REG|DREFOBJ))==REG){
-      if(o->reg!=r)
-	emit(f,"\tmov%s\t%s,%s\n",cc,regnames[r],regnames[o->reg]);
-    }else{
-      if(SHORT_DOUBLE&&ISFLOAT(type)) type=FLOAT;
-      emit(f,"\tld%s%s\t%s,",dt(type),cc,regnames[r]);
-      emit_obj(f,o,type);
-      emit(f,"\n");
-    }
-  }
-}
-
-/*  Generates code to store register r into memory object o. */
-static void store_reg(FILE *f,int r,struct obj *o,int type)
-{
-  if(reg_pair(r,&rp)) ierror(0);
-  type&=NQ;
-  if(SHORT_DOUBLE&&ISFLOAT(type)) type=FLOAT;
-  emit(f,"\tst%s%s\t%s,",sdt(type),cc,regnames[r]);
-  emit_obj(f,o,type);
-  emit(f,"\n");
-}
-
-/*  Yields log2(x)+1 or 0. */
-static long pof2(zumax x)
-{
-  zumax p;int ln=1;
-  p=ul2zum(1L);
-  while(ln<=32&&zumleq(p,x)){
-    if(zumeqto(x,p)) return ln;
-    ln++;p=zumadd(p,p);
-  }
-  return 0;
-}
-
-static struct IC *preload(FILE *,struct IC *);
-
-static void function_top(FILE *,struct Var *,long);
-static void function_bottom(FILE *f,struct Var *,long);
-
-#define isreg(x) ((p->x.flags&(REG|DREFOBJ))==REG)
-#define isconst(x) ((p->x.flags&(KONST|DREFOBJ))==KONST)
-
-static int q1reg,q2reg,zreg;
-
-static char *ccs[]={"eq","ne","lt","ge","le","gt",""};
-static char *ccu[]={"eq","ne","cs","cc","ls","hi",""};
-static char *logicals[]={"or","eor","and"};
-static char *arithmetics[]={"lsl","asr","add","sub","mul","divs","mod"};
-static char *uarithmetics[]={"lsl","lsr","add","sub","mul","divu","mod"};
-static char *farithmetics[]={"--","--","fadd","fsub","fmul","fdiv","--"};
-
-
-/* Does some pre-processing like fetching operands from memory to
-   registers etc. */
-static struct IC *preload(FILE *f,struct IC *p)
-{
-  int r,load;
-
-  if(isreg(q1))
-    q1reg=p->q1.reg;
-  else
-    q1reg=0;
-
-  if(isreg(q2))
-    q2reg=p->q2.reg;
-  else
-    q2reg=0;
-
-  if(isreg(z)){
-    zreg=p->z.reg;
-  }else{
-    zreg=t1;
-  }
-  
-  if((p->q1.flags&(DREFOBJ|REG))==DREFOBJ&&!p->q1.am){
-    p->q1.flags&=~DREFOBJ;
-    load_reg(f,t1,&p->q1,POINTER);
-    p->q1.reg=t1;
-    p->q1.flags|=(REG|DREFOBJ);
-  }
-  if(p->q1.flags&&!isreg(q1)&&p->code!=ASSIGN&&p->code!=PUSH&&p->code!=SETRETURN/*&&!(p->q1.flags&KONST)*/){
-    q1reg=zreg;
-    load_reg(f,q1reg,&p->q1,q1typ(p));
-    p->q1.reg=q1reg;
-    p->q1.flags=REG;
-  }
-
-  if((p->q2.flags&(DREFOBJ|REG))==DREFOBJ&&!p->q2.am){
-    p->q2.flags&=~DREFOBJ;
-    load_reg(f,t2,&p->q2,POINTER);
-    p->q2.reg=t2;
-    p->q2.flags|=(REG|DREFOBJ);
-  }
-
-  if(p->q2.flags){
-    load=1;
-    if(isreg(q2)) load=0;
-    if((p->q2.flags&KONST)&&!ISFLOAT(p->typf)&&(p->code==ADD||p->code==SUB||p->code==ADDI2P||p->code==COMPARE||p->code==SUBIFP||p->code==SUBPFP))
-      load=0;
-    if(p->code>=OR&&p->code<=MOD&&(p->q2.flags&KONST)&&!ISFLOAT(p->typf)){
-      unsigned long v;
-      eval_const(&p->q2.val,q2typ(p));
-      v=zum2ul(vumax);
-      if(v<=31) load=0;
-    }
-    if(load){
-      q2reg=t2;
-      load_reg(f,q2reg,&p->q2,q2typ(p));
-      p->q2.reg=q2reg;
-      p->q2.flags=REG;
-    }
-  }
-  return p;
-}
-
-/* save the result (in zreg) into p->z */
-void save_result(FILE *f,struct IC *p)
-{
-  if((p->z.flags&(REG|DREFOBJ))==DREFOBJ&&!p->z.am){
-    p->z.flags&=~DREFOBJ;
-    load_reg(f,t2,&p->z,POINTER);
-    p->z.reg=t2;
-    p->z.flags|=(REG|DREFOBJ);
-  }
-  if(isreg(z)){
-    if(p->z.reg!=zreg)
-      emit(f,"\tmov%s\t%s,%s\n",cc,regnames[p->z.reg],regnames[zreg]);
-  }else{
-    store_reg(f,zreg,&p->z,ztyp(p));
-  }
-}
-
-/* prints an object */
-static void emit_obj(FILE *f,struct obj *p,int t)
-{
-  if((p->flags&DREFOBJ)&&p->am){
-    if(p->am->flags==AM_GPR_IND) emit(f,"(%s,%s)",regnames[p->am->base],regnames[p->am->offset]);
-    if(p->am->flags==AM_IMM_IND) emit(f,"%ld(%s)",p->am->offset,regnames[p->am->base]);
-    if(p->am->flags==AM_POSTINC) emit(f,"(%s)++",regnames[p->am->base]);
-    if(p->am->flags==AM_PREDEC) emit(f,"--(%s)",regnames[p->am->base]);
-    return;
-  }
-  if((p->flags&(KONST|DREFOBJ))==(KONST|DREFOBJ)){
-    emitval(f,&p->val,p->dtyp&NU);
-    return;
-  }
-  if(p->flags&DREFOBJ) emit(f,"(");
-  if(p->flags&REG){
-    emit(f,"%s",regnames[p->reg]);
-  }else if(p->flags&VAR) {
-    if(p->v->storage_class==AUTO||p->v->storage_class==REGISTER)
-      emit(f,"%ld(%s)",real_offset(p),regnames[sp]);
-    else{
-      if(!zmeqto(l2zm(0L),p->val.vmax)){emitval(f,&p->val,LONG);emit(f,"+");}
-      if(p->v->storage_class==STATIC){
-        emit(f,"%s%ld",labprefix,zm2l(p->v->offset));
-      }else{
-        emit(f,"%s%s",idprefix,p->v->identifier);
-      }
-      if(!no_suffix)
-	emit(f,"(%s)",regnames[pc]);
-    }
-  }
-  if(p->flags&KONST){
-    if(ISFLOAT(t)){
-      unsigned char *ip;
-      eval_const(&p->val,t);
-      ip=(unsigned char *)&vfloat;
-      emit(f,"0x%02x%02x%02x%02x",ip[0],ip[1],ip[2],ip[3]);
-    }else
-      emitval(f,&p->val,t&NU);
-  }
-  if(p->flags&DREFOBJ) emit(f,")");
-}
-
-/*  Test if there is a sequence of FREEREGs containing FREEREG reg.
-    Used by peephole. */
-static int exists_freereg(struct IC *p,int reg)
-{
-  while(p&&(p->code==FREEREG||p->code==ALLOCREG)){
-    if(p->code==FREEREG&&p->q1.reg==reg) return 1;
-    p=p->next;
-  }
-  return 0;
-}
-
-/* search for possible addressing-modes */
-static void peephole(struct IC *p)
-{
-  int c,c2,r;struct IC *p2;struct AddressingMode *am;
-
-  for(;p;p=p->next){
-    c=p->code;
-    if(c!=FREEREG&&c!=ALLOCREG&&(c!=SETRETURN||!isreg(q1)||p->q1.reg!=p->z.reg)) exit_label=0;
-    if(c==LABEL) exit_label=p->typf;
-
-    /* -(ax) */
-    if(c==SUBIFP&&isreg(q1)&&isreg(z)&&p->q1.reg==p->z.reg&&p->q1.reg<=8&&isconst(q2)){
-      zmax sz;
-      int t;
-      r=p->q1.reg;
-      eval_const(&p->q2.val,q2typ(p));
-      sz=zm2l(vmax);
-      if(sz==1||sz==2||sz==4){
-        for(p2=p->next;p2;p2=p2->next){
-          c2=p2->code;
-          if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r&&(!(p2->q2.flags&REG)||p2->q2.reg!=r)&&(!(p2->z.flags&REG)||p2->z.reg!=r)&&(
-c2!=CONVERT||(q1typ(p2)&NQ)<=(ztyp(p2)&NQ))){
-            t=(q1typ(p2)&NQ);
-            if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q1typ(p2)&NQ],l2zm(sz))){
-              p2->q1.am=am=mymalloc(sizeof(*am));
-              p2->q1.val.vmax=l2zm(0L);
-              am->base=r;
-              am->flags=AM_PREDEC;
-              p->code=NOP;
-              p->q1.flags=p->q2.flags=p->z.flags=0;
-              break;
-            }
-          }
-         if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r&&(!(p2->q1.flags&REG)||p2->q1.reg!=r)&&(!(p2->z.flags&REG)||p2->z.reg!=r)){
-            t=(q2typ(p2)&NQ);
-            if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[q2typ(p2)&NQ],l2zm(sz))){
-              p2->q2.am=am=mymalloc(sizeof(*am));
-              p2->q2.val.vmax=l2zm(0L);
-              am->base=r;
-              am->flags=AM_PREDEC;
-              p->code=NOP;
-              p->q1.flags=p->q2.flags=p->z.flags=0;
-              break;
-            }
-          }
-          if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r&&(!(p2->q2.flags&REG)||p2->q2.reg!=r)&&(!(p2->q1.flags&REG)||p2->q1.reg!=r)){
-            t=(ztyp(p2)&NQ);
-            if((ISINT(t)||ISPOINTER(t))&&t!=LLONG&&zmeqto(sizetab[ztyp(p2)&NQ],l2zm(sz))){
-              p2->z.am=am=mymalloc(sizeof(*am));
-              p2->z.val.vmax=l2zm(0L);
-              am->base=r;
-              am->flags=AM_PREDEC;
-              p->code=NOP;
-              p->q1.flags=p->q2.flags=p->z.flags=0;
-              break;
-            }
-          }
-          if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-          if((p2->q1.flags&REG)&&p2->q1.reg==r) break;
-          if((p2->q2.flags&REG)&&p2->q2.reg==r) break;
-          if((p2->z.flags&REG)&&p2->z.reg==r) break;
-        }
-      }
-    }
-
-    /* (ax)+ in q1 */
-    if(!p->q1.am&&(p->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&(c!=CONVERT||(q1typ(p)&NQ)<=(ztyp(p)&NQ))){
-      int t=(q1typ(p)&NQ);
-      long sz=zm2l(sizetab[t]);
-      r=p->q1.reg;
-      if((sz==1||sz==2||sz==4)&&(ISINT(t)||ISPOINTER(t)||ISFLOAT(t))&&(!(p->q2.flags&REG)||p->q2.reg!=r)&&(!(p->z.flags&REG)||p->z.reg!=r)){
-        for(p2=p->next;p2;p2=p2->next){
-          c2=p2->code;
-          if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
-            eval_const(&p2->q2.val,q2typ(p2));
-            if(zmeqto(vmax,l2zm(sz))){
-              p->q1.am=am=mymalloc(sizeof(*am));
-              p->q1.val.vmax=l2zm(0L);
-	      am->flags=AM_POSTINC;
-              am->base=r;
-              am->offset=0;
-              p2->code=NOP;
-              p2->q1.flags=p2->q2.flags=p2->z.flags=0;
-              break;
-            }
-          }
-          if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-          if((p2->q1.flags&REG)&&p2->q1.reg==r) break;
-          if((p2->q2.flags&REG)&&p2->q2.reg==r) break;
-          if((p2->z.flags&REG)&&p2->z.reg==r) break;
-        }
-      }
-    }
-    /* (ax)+ in q2 */
-    if(!p->q2.am&&(p->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&(c!=CONVERT||(q2typ(p)&NQ)<=(ztyp(p)&NQ))){
-      int t=(q2typ(p)&NQ);
-      long sz=zm2l(sizetab[t]);
-      r=p->q2.reg;
-      if((sz==1||sz==2||sz==4)&&(ISINT(t)||ISPOINTER(t)||ISFLOAT(t))&&(!(p->q1.flags&REG)||p->q1.reg!=r)&&(!(p->z.flags&REG)||p->z.reg!=r)){
-        for(p2=p->next;p2;p2=p2->next){
-          c2=p2->code;
-          if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
-            eval_const(&p2->q2.val,q2typ(p2));
-            if(zmeqto(vmax,l2zm(sz))){
-              p->q2.am=am=mymalloc(sizeof(*am));
-              p->q2.val.vmax=l2zm(0L);
-	      am->flags=AM_POSTINC;
-              am->base=r;
-              am->offset=0;
-              p2->code=NOP;
-              p2->q1.flags=p2->q2.flags=p2->z.flags=0;
-              break;
-            }
-          }
-          if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-          if((p2->q1.flags&REG)&&p2->q1.reg==r) break;
-          if((p2->q2.flags&REG)&&p2->q2.reg==r) break;
-          if((p2->z.flags&REG)&&p2->z.reg==r) break;
-        }
-      }
-    }
-    /* (ax)+ in z */
-    if(!p->z.am&&(p->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p->z.reg<=8&&(c!=CONVERT||(q2typ(p)&NQ)<=(ztyp(p)&NQ))){
-      int t=(ztyp(p)&NQ);
-      long sz=zm2l(sizetab[t]);
-      r=p->z.reg;
-      if((sz==1||sz==2||sz==4)&&(ISINT(t)||ISPOINTER(t)||ISFLOAT(t))&&(!(p->q1.flags&REG)||p->q1.reg!=r)&&(!(p->q2.flags&REG)||p->q2.reg!=r)){
-        for(p2=p->next;p2;p2=p2->next){
-          c2=p2->code;
-          if(c2==ADDI2P&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r&&(p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==r&&(p2->q2.flags&(KONST|DREFOBJ))==KONST){
-            eval_const(&p2->q2.val,q2typ(p2));
-            if(zmeqto(vmax,l2zm(sz))){
-              p->z.am=am=mymalloc(sizeof(*am));
-              p->z.val.vmax=l2zm(0L);
-	      am->flags=AM_POSTINC;
-              am->base=r;
-              am->offset=0;
-              p2->code=NOP;
-              p2->q1.flags=p2->q2.flags=p2->z.flags=0;
-              break;
-            }
-          }
-          if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-          if((p2->q1.flags&REG)&&p2->q1.reg==r) break;
-          if((p2->q2.flags&REG)&&p2->q2.reg==r) break;
-          if((p2->z.flags&REG)&&p2->z.reg==r) break;
-        }
-      }
-    }
-    /* Try const(reg) */
-    if((c==ADDI2P/*||c==SUBIFP*/)&&isreg(z)&&(p->q2.flags&(KONST|DREFOBJ))==KONST){
-      int base;zmax of;struct obj *o;
-      eval_const(&p->q2.val,p->typf);
-      if(c==SUBIFP) of=zmsub(l2zm(0L),vmax); else of=vmax;
-      if(1/*zmleq(l2zm(-32768L),vmax)&&zmleq(vmax,l2zm(32767L))*/){
-	r=p->z.reg;
-	if(isreg(q1)) base=p->q1.reg; else base=r;
-	o=0;
-	for(p2=p->next;p2;p2=p2->next){
-	  c2=p2->code;
-	  if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-	  if(c2!=FREEREG&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r) break;
-	  if(c2!=FREEREG&&(p2->q2.flags&(REG|DREFOBJ))==REG&&p2->q2.reg==r) break;
-	  if((c2==ASSIGN||c2==PUSH)&&(!ISSCALAR(p2->typf)||!zmeqto(p2->q2.val.vmax,sizetab[p2->typf&NQ]))){
-	    if((p->q1.flags&REG)&&p->q1.reg==base)
-	      break;
-	    if((p->z.flags&REG)&&p->z.reg==base)
-	      break;
-	  }
-	  if(c2!=CALL&&(c2<LABEL||c2>BRA)/*&&c2!=ADDRESS*/){
-	    if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r){
-	      if(o) break;
-	      o=&p2->q1;
-	    }
-	    if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r){
-	      if(o) break;
-	      o=&p2->q2;
-	    }
-	    if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r){
-	      if(o) break;
-	      o=&p2->z;
-	    }
-	  }
-	  if(c2==FREEREG||(p2->z.flags&(REG|DREFOBJ))==REG){
-	    int m;
-	    if(c2==FREEREG)
-	      m=p2->q1.reg;
-	    else
-	      m=p2->z.reg;
-	    if(m==r){
-	      if(o){
-		o->am=am=mymalloc(sizeof(*am));
-		am->flags=AM_IMM_IND;
-		am->base=base;
-		am->offset=zm2l(of);
-		if(isreg(q1)){
-		  p->code=c=NOP;p->q1.flags=p->q2.flags=p->z.flags=0;
-		}else{
-		  p->code=c=ASSIGN;p->q2.flags=0;
-		  p->typf=p->typf2;p->q2.val.vmax=sizetab[p->typf2&NQ];
-		}
-	      }
-	      break;
-	    }
-	    if(c2!=FREEREG&&m==base) break;
-	    continue;
-	  }
-        }
-      }
-    }
-    /* Try reg,reg */
-    if(c==ADDI2P&&isreg(q2)&&isreg(z)&&(isreg(q1)||p->q2.reg!=p->z.reg)){
-      int base,idx;struct obj *o;
-      r=p->z.reg;idx=p->q2.reg;
-      if(isreg(q1)) base=p->q1.reg; else base=r;
-      o=0;
-      for(p2=p->next;p2;p2=p2->next){
-        c2=p2->code;
-        if(c2==CALL||c2==LABEL||(c2>=BEQ&&c2<=BRA)) break;
-        if(c2!=FREEREG&&(p2->q1.flags&(REG|DREFOBJ))==REG&&p2->q1.reg==r) break;
-        if(c2!=FREEREG&&(p2->q2.flags&(REG|DREFOBJ))==REG&&p2->q2.reg==r) break;
-        if((p2->z.flags&(REG|DREFOBJ))==REG&&p2->z.reg==idx&&idx!=r) break;
-	
-        if(c2!=CALL&&(c2<LABEL||c2>BRA)/*&&c2!=ADDRESS*/){
-          if(!p2->q1.am&&(p2->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q1.reg==r){
-            if(o||(q1typ(p2)&NQ)!=CHAR) break;
-            o=&p2->q1;
-          }
-          if(!p2->q2.am&&(p2->q2.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->q2.reg==r){
-            if(o||(q2typ(p2)&NQ)!=CHAR) break;
-            o=&p2->q2;
-          }
-          if(!p2->z.am&&(p2->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&p2->z.reg==r){
-            if(o||(ztyp(p2)&NQ)!=CHAR) break;
-            o=&p2->z;
-          }
-        }
-        if(c2==FREEREG||(p2->z.flags&(REG|DREFOBJ))==REG){
-          int m;
-          if(c2==FREEREG)
-            m=p2->q1.reg;
-          else
-            m=p2->z.reg;
-          if(m==r){
-            if(o){
-              o->am=am=mymalloc(sizeof(*am));
-              am->flags=AM_GPR_IND;
-              am->base=base;
-              am->offset=idx;
-	      if(isreg(q1)){
-		p->code=c=NOP;p->q1.flags=p->q2.flags=p->z.flags=0;
-	      }else{
-		p->code=c=ASSIGN;p->q2.flags=0;
-		p->typf=p->typf2;p->q2.val.vmax=sizetab[p->typf2&NQ];
-	      }
-            }
-            break;
-          }
-          if(c2!=FREEREG&&m==base) break;
-          continue;
-        }
-      }
-    }
-  }
-}
-
-/* generates the function entry code */
-static void function_top(FILE *f,struct Var *v,long offset)
-{
-  int i;
-  rsavesize=0;
-  if(!special_section(f,v)&&section!=CODE){emit(f,codename);if(f) section=CODE;} 
-  emit(f,"\t.align\t1\n");
-  if(v->storage_class==EXTERN){
-    if((v->flags&(INLINEFUNC|INLINEEXT))!=INLINEFUNC)
-      emit(f,"\t.global\t%s%s\n",idprefix,v->identifier);
-    emit(f,"%s%s:\n",idprefix,v->identifier);
-  }else
-    emit(f,"%s%ld:\n",labprefix,zm2l(v->offset));
-  last_saved=0;
-  for(i=r6;i<t2;i++){
-    if(regused[i])
-      last_saved=i;
-  }
-  if(last_saved){
-    emit(f,"\tpush\t%s-%s",regnames[r6],regnames[last_saved]);
-    rsavesize=(last_saved-r6+1)*4;
-    if(function_calls){
-      emit(f,",lr");
-      rsavesize+=4;
-    }
-    emit(f,"\n");
-  }else if(function_calls){
-    emit(f,"\tpush\t%s-%s,lr\n",regnames[r6],regnames[r6]);
-    rsavesize+=8;
-  }
-  if(offset){
-    emit(f,"\tsub\t%s,%ld\n",regnames[sp],offset);
-  }
-}
-/* generates the function exit code */
-static void function_bottom(FILE *f,struct Var *v,long offset)
-{
-  if(offset){
-    emit(f,"\tadd\t%s,%ld\n",regnames[sp],offset);
-  }
-  if(last_saved){
-    emit(f,"\tpop\t%s-%s",regnames[r6],regnames[last_saved]);
-    if(function_calls){
-      emit(f,",pc");
-    }
-    emit(f,"\n");
-  }else if(function_calls){
-    emit(f,"\tpop\t%s-%s,pc\n",regnames[r6],regnames[r6]);
-  }  
-  if(!function_calls)
-    emit(f,ret);
-}
-
-/****************************************/
-/*  End of private data and functions.  */
-/****************************************/
-
-/*  Does necessary initializations for the code-generator. Gets called  */
-/*  once at the beginning and should return 0 in case of problems.      */
-int init_cg(void)
-{
-  int i;
-  /*  Initialize some values which cannot be statically initialized   */
-  /*  because they are stored in the target's arithmetic.             */
-  maxalign=l2zm(4L);
-  char_bit=l2zm(8L);
-  stackalign=l2zm(4);
-
-  for(i=0;i<=MAX_TYPE;i++){
-    sizetab[i]=l2zm(msizetab[i]);
-    align[i]=l2zm(malign[i]);
-  }
-
-  if(SHORT_DOUBLE){
-    sizetab[DOUBLE]=sizetab[FLOAT];
-    align[DOUBLE]=align[FLOAT];
-    sizetab[LDOUBLE]=sizetab[FLOAT];
-    align[LDOUBLE]=align[FLOAT];
-  }
-
-  regnames[0]="noreg";
-  for(i=1;i<=32;i++){
-    regnames[i]=mymalloc(10);
-    sprintf(regnames[i],"r%d",i-1);
-    regsize[i]=l2zm(4L);
-    regtype[i]=&ltyp;
-  }
-  for(i=33;i<=48;i++){
-    regnames[i]=mymalloc(10);
-    sprintf(regnames[i],"r%d/r%d",i-33,i-32);
-    regsize[i]=l2zm(8L);
-    regtype[i]=&ldbl;
-  }
-
-  /*  Initialize the min/max-settings. Note that the types of the     */
-  /*  host system may be different from the target system and you may */
-  /*  only use the smallest maximum values ANSI guarantees if you     */
-  /*  want to be portable.                                            */
-  /*  That's the reason for the subtraction in t_min[INT]. Long could */
-  /*  be unable to represent -2147483648 on the host system.          */
-  t_min[CHAR]=l2zm(-128L);
-  t_min[SHORT]=l2zm(-32768L);
-  t_min[INT]=zmsub(l2zm(-2147483647L),l2zm(1L));
-  t_min[LONG]=t_min(INT);
-  t_min[LLONG]=zmlshift(l2zm(1L),l2zm(63L));
-  t_min[MAXINT]=t_min(LLONG);
-  t_max[CHAR]=ul2zum(127L);
-  t_max[SHORT]=ul2zum(32767UL);
-  t_max[INT]=ul2zum(2147483647UL);
-  t_max[LONG]=t_max(INT);
-  t_max[LLONG]=zumrshift(zumkompl(ul2zum(0UL)),ul2zum(1UL));
-  t_max[MAXINT]=t_max(LLONG);
-  tu_max[CHAR]=ul2zum(255UL);
-  tu_max[SHORT]=ul2zum(65535UL);
-  tu_max[INT]=ul2zum(4294967295UL);
-  tu_max[LONG]=t_max(UNSIGNED|INT);
-  tu_max[LLONG]=zumkompl(ul2zum(0UL));
-  tu_max[MAXINT]=t_max(UNSIGNED|LLONG);
-  
-  /*  Reserve a few registers for use by the code-generator.      */
-  /*  This is not optimal but simple.                             */
-  regsa[t1]=regsa[t2]=1;
-  regsa[pc]=regsa[lr]=regsa[sp]=regsa[sr]=1;
-  regscratch[t1]=regscratch[t2]=0;
-  regscratch[pc]=regscratch[lr]=regscratch[sp]=regscratch[sr]=1;
-
-  for(i=r16;i<=r31;i++)
-    regscratch[i]=regsa[i]=1;
-  
-  for(i=1;i<=6;i++)
-    regscratch[i]=1;
-
-  if(ONESEC){
-    bssname=codename;
-    dataname=codename;
-    rodataname=codename;
-  }
-
-  if(SHORT_DOUBLE) marray[2]="__SHORT_DOUBLE__=1";
-  target_macros=marray;
-
-
-  declare_builtin("__mulint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__addint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__subint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__andint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__orint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__eorint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__negint64",LLONG,LLONG,r0r1,0,0,1,0);
-  declare_builtin("__lslint64",LLONG,LLONG,r0r1,INT,r2,1,0);
-
-  declare_builtin("__divsint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__divuint64",UNSIGNED|LLONG,UNSIGNED|LLONG,r0r1,UNSIGNED|LLONG,r2r3,1,0);
-  declare_builtin("__modsint64",LLONG,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__moduint64",UNSIGNED|LLONG,UNSIGNED|LLONG,r0r1,UNSIGNED|LLONG,r2r3,1,0);
-  declare_builtin("__lsrsint64",LLONG,LLONG,r0r1,INT,r2,1,0);
-  declare_builtin("__lsruint64",UNSIGNED|LLONG,UNSIGNED|LLONG,r0r1,INT,r2,1,0);
-  declare_builtin("__cmpsint64",INT,LLONG,r0r1,LLONG,r2r3,1,0);
-  declare_builtin("__cmpuint64",INT,UNSIGNED|LLONG,r0r1,UNSIGNED|LLONG,r2r3,1,0);
-  declare_builtin("__sint64toflt32",FLOAT,LLONG,r0r1,0,0,1,0);
-  declare_builtin("__uint64toflt32",FLOAT,UNSIGNED|LLONG,r0r1,0,0,1,0);
-  declare_builtin("__sint64toflt64",LDOUBLE,LLONG,r0r1,0,0,1,0);
-  declare_builtin("__uint64toflt64",LDOUBLE,UNSIGNED|LLONG,r0r1,0,0,1,0);
-  declare_builtin("__flt32tosint64",LLONG,FLOAT,r0,0,0,1,0);
-  declare_builtin("__flt32touint64",UNSIGNED|LLONG,FLOAT,r0,0,0,1,0);
-  declare_builtin("__flt64tosint64",LLONG,LDOUBLE,r0r1,0,0,1,0);
-  declare_builtin("__flt64touint64",UNSIGNED|LLONG,LDOUBLE,r0r1,0,0,1,0);
-
-  declare_builtin("__flt32toflt64",LDOUBLE,FLOAT,r0,0,0,1,0);
-  declare_builtin("__flt64toflt32",FLOAT,LDOUBLE,r0r1,0,0,1,0);
-
-  declare_builtin("__addflt64",LDOUBLE,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-  declare_builtin("__subflt64",LDOUBLE,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-  declare_builtin("__mulflt64",LDOUBLE,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-  declare_builtin("__divflt64",LDOUBLE,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-  declare_builtin("__negflt64",LDOUBLE,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-  declare_builtin("__cmpflt64",INT,LDOUBLE,r0r1,LDOUBLE,r2r3,1,0);
-
-
-  return 1;
-}
-
-void init_db(FILE *f)
-{
-}
-
-int freturn(struct Typ *t)
-/*  Returns the register in which variables of type t are returned. */
-/*  If the value cannot be returned in a register returns 0.        */
-/*  A pointer MUST be returned in a register. The code-generator    */
-/*  has to simulate a pseudo register if necessary.                 */
-{
-  if(SHORT_DOUBLE&&ISFLOAT(t->flags)) return r0;
-  if(ISSTRUCT(t->flags)||ISUNION(t->flags)) 
-    return 0;
-  if(zmleq(szof(t),l2zm(4L))) 
-    return r0;
-  if(zmeqto(szof(t),l2zm(8L))) 
-    return r0r1;
-  return 0;
-}
-
-int reg_pair(int r,struct rpair *p)
-/* Returns 0 if the register is no register pair. If r  */
-/* is a register pair non-zero will be returned and the */
-/* structure pointed to p will be filled with the two   */
-/* elements.                                            */
-{
-  if(r>=r0r1&&r<=r30r31){
-    p->r1=(r-r0r1)*2+r0;
-    p->r2=(r-r0r1)*2+r1;
-    return 1;
-  }
-  return 0;
-}
-
-/* estimate the cost-saving if object o from IC p is placed in
-   register r */
-int cost_savings(struct IC *p,int r,struct obj *o)
-{
-  int c=p->code;
-  if(o->flags&VKONST){
-    return 0;
-  }
-  if(o->flags&DREFOBJ)
-    return 4;
-  if(c==SETRETURN&&r==p->z.reg&&!(o->flags&DREFOBJ)) return 3;
-  if(c==GETRETURN&&r==p->q1.reg&&!(o->flags&DREFOBJ)) return 3;
-  return 2;
-}
-
-int regok(int r,int t,int mode)
-/*  Returns 0 if register r cannot store variables of   */
-/*  type t. If t==POINTER and mode!=0 then it returns   */
-/*  non-zero only if the register can store a pointer   */
-/*  and dereference a pointer to mode.                  */
-{
-  if(r==0)
-    return 0;
-  t&=NQ;
-  if(ISINT(t)||ISFLOAT(t)||ISPOINTER(t)){
-    if(zmeqto(sizetab[t],l2zm(8L))){
-      if(r>=r0r1&&r<=r30r31)
-	return 1;
-      else
-	return 0;
-    }
-    if(r>=r0&&r<=r31)
-      return 1;
-    else
-      return 0;
-  }
-  return 0;
-}
-
-int dangerous_IC(struct IC *p)
-/*  Returns zero if the IC p can be safely executed     */
-/*  without danger of exceptions or similar things.     */
-/*  vbcc may generate code in which non-dangerous ICs   */
-/*  are sometimes executed although control-flow may    */
-/*  never reach them (mainly when moving computations   */
-/*  out of loops).                                      */
-/*  Typical ICs that generate exceptions on some        */
-/*  machines are:                                       */
-/*      - accesses via pointers                         */
-/*      - division/modulo                               */
-/*      - overflow on signed integer/floats             */
-{
-  int c=p->code;
-  if((p->q1.flags&DREFOBJ)||(p->q2.flags&DREFOBJ)||(p->z.flags&DREFOBJ))
-    return 1;
-  if((c==DIV||c==MOD)&&!isconst(q2))
-    return 1;
-  return 0;
-}
-
-int must_convert(int o,int t,int const_expr)
-/*  Returns zero if code for converting np to type t    */
-/*  can be omitted.                                     */
-/*  On the VideCore IV pointers and 32bit               */
-/*  integers have the same representation and can use   */
-/*  the same registers.                                 */
-{
-  int op=o&NQ,tp=t&NQ;
-  if(SHORT_DOUBLE){
-    if(op==DOUBLE||op==LDOUBLE) op=FLOAT;
-    if(tp==DOUBLE||tp==LDOUBLE) tp=FLOAT;
-  }
-  if((op==INT||op==LONG||op==POINTER)&&(tp==INT||tp==LONG||tp==POINTER))
-    return 0;
-  if(op==FLOAT&&tp==FLOAT) return 0;
-  if(op==DOUBLE&&tp==LDOUBLE) return 0;
-  if(op==LDOUBLE&&tp==DOUBLE) return 0;
-  return 1;
-}
-
-void gen_ds(FILE *f,zmax size,struct Typ *t)
-/*  This function has to create <size> bytes of storage */
-/*  initialized with zero.                              */
-{
-  if(newobj&&!ONESEC&&section!=SPECIAL)
-    emit(f,"%ld\n",zm2l(size));
-  else
-    emit(f,"\t.space\t%ld\n",zm2l(size));
-  newobj=0;
-}
-
-void gen_align(FILE *f,zmax align)
-/*  This function has to make sure the next data is     */
-/*  aligned to multiples of <align> bytes.              */
-{
-  if(zm2l(align)>1) emit(f,"\t.align\t2\n");
-}
-
-void gen_var_head(FILE *f,struct Var *v)
-/*  This function has to create the head of a variable  */
-/*  definition, i.e. the label and information for      */
-/*  linkage etc.                                        */
-{
-  int constflag;char *sec;
-  if(v->clist) constflag=is_const(v->vtyp);
-  if(v->storage_class==STATIC){
-    if(ISFUNC(v->vtyp->flags)) return;
-    if(!special_section(f,v)){
-      if(v->clist&&(!constflag||(g_flags[2]&USEDFLAG))&&section!=DATA){emit(f,dataname);if(f) section=DATA;}
-      if(v->clist&&constflag&&!(g_flags[2]&USEDFLAG)&&section!=RODATA){emit(f,rodataname);if(f) section=RODATA;}
-      if(!v->clist&&section!=BSS){emit(f,bssname);if(f) section=BSS;}
-    }
-    if(v->clist||ONESEC||section==SPECIAL){
-      gen_align(f,falign(v->vtyp));
-      emit(f,"%s%ld:\n",labprefix,zm2l(v->offset));
-    }else
-      emit(f,"\t.lcomm\t%s%ld,",labprefix,zm2l(v->offset));
-    newobj=1;
-  }
-  if(v->storage_class==EXTERN){
-    emit(f,"\t.global\t%s%s\n",idprefix,v->identifier);
-    if(v->flags&(DEFINED|TENTATIVE)){
-      if(!special_section(f,v)){
-	if(v->clist&&(!constflag||(g_flags[2]&USEDFLAG))&&section!=DATA){emit(f,dataname);if(f) section=DATA;}
-	if(v->clist&&constflag&&!(g_flags[2]&USEDFLAG)&&section!=RODATA){emit(f,rodataname);if(f) section=RODATA;}
-	if(!v->clist&&section!=BSS){emit(f,bssname);if(f) section=BSS;}
-      }
-      if(v->clist||ONESEC||section==SPECIAL){
-	gen_align(f,falign(v->vtyp));
-        emit(f,"%s%s:\n",idprefix,v->identifier);
-      }else
-        emit(f,"\t.%scomm\t%s%s,",(USE_COMMONS?"":"l"),idprefix,v->identifier);
-      newobj=1;
-    }
-  }
-}
-
-void gen_dc(FILE *f,int t,struct const_list *p)
-/*  This function has to create static storage          */
-/*  initialized with const-list p.                      */
-{
-  if((t&NQ)==POINTER) t=UNSIGNED|LONG;
-  emit(f,"\t.%s\t",dct[t&NQ]);
-  if(!p->tree){
-    if(ISFLOAT(t)){
-      /*  auch wieder nicht sehr schoen und IEEE noetig   */
-      unsigned char *ip;
-      if(SHORT_DOUBLE){
-	eval_const(&p->val,t);
-	ip=(unsigned char *)&vfloat;
-	t=FLOAT;
-      }else
-	ip=(unsigned char *)&p->val.vdouble;
-      emit(f,"0x%02x%02x%02x%02x",ip[0],ip[1],ip[2],ip[3]);
-      if((t&NQ)!=FLOAT){
-        emit(f,",0x%02x%02x%02x%02x",ip[4],ip[5],ip[6],ip[7]);
-      }
-    }else if((t&NQ)==LLONG){
-      zumax tmp;
-      eval_const(&p->val,t);
-      tmp=vumax;
-      vumax=zumand(zumrshift(vumax,ul2zum(32UL)),ul2zum(0xffffffff)); 
-      gval.vulong=zum2zul(vumax);
-      emitval(f,&gval,UNSIGNED|LONG);
-      emit(f,",");
-      vumax=zumand(tmp,ul2zum(0xffffffff)); 
-      gval.vulong=zum2zul(vumax);
-      emitval(f,&gval,UNSIGNED|LONG);
-    }else{
-      emitval(f,&p->val,t&NU);
-    }
-  }else{
-    no_suffix=1;
-    emit_obj(f,&p->tree->o,t&NU);
-    no_suffix=0;
-  }
-  emit(f,"\n");newobj=0;
-}
-
-
-/*  The main code-generation routine.                   */
-/*  f is the stream the code should be written to.      */
-/*  p is a pointer to a doubly linked list of ICs       */
-/*  containing the function body to generate code for.  */
-/*  v is a pointer to the function.                     */
-/*  offset is the size of the stackframe the function   */
-/*  needs for local variables.                          */
-
-void gen_code(FILE *f,struct IC *p,struct Var *v,zmax offset)
-/*  The main code-generation.                                           */
-{
-  int c,t,i,lastcomp;
-  int q1wasreg,q2wasreg,zwasreg;
-  struct IC *m;
-  argsize=0;
-  if(DEBUG&1) printf("gen_code()\n");
-  for(c=1;c<=MAXR;c++) regs[c]=regsa[c];
-  stackoffset=notpopped=dontpop=maxpushed=0;
-
-
-  /*FIXME*/
-  ret="\trts\n";
-
-  cc="";
-
-  for(m=p;m;m=m->next){
-    c=m->code;t=m->typf&NU;
-    if(c==ALLOCREG) {regs[m->q1.reg]=1;continue;}
-    if(c==FREEREG) {regs[m->q1.reg]=0;continue;}
-
-    if(notpopped&&!dontpop){
-      int flag=0;
-      if(c==LABEL||c==COMPARE||c==TEST||c==BRA){
-        emit(f,"\tadd\t%s,%ld\n",regnames[sp],notpopped);
-        pop(notpopped);notpopped=0;
-      }
-    }
-
-
-    /* convert MULT/DIV/MOD with powers of two */
-    if((t&NQ)<=LONG&&(m->q2.flags&(KONST|DREFOBJ))==KONST&&(t&NQ)<=LONG&&(c==MULT||((c==DIV||c==MOD)&&(t&UNSIGNED)))){
-      eval_const(&m->q2.val,t);
-      i=pof2(vmax);
-      if(i){
-        if(c==MOD){
-          vmax=zmsub(vmax,l2zm(1L));
-          m->code=AND;
-        }else{
-          vmax=l2zm(i-1);
-          if(c==DIV) m->code=RSHIFT; else m->code=LSHIFT;
-        }
-        c=m->code;
-	gval.vmax=vmax;
-	eval_const(&gval,MAXINT);
-	if(c==AND){
-	  insert_const(&m->q2.val,t);
-	}else{
-	  insert_const(&m->q2.val,INT);
-	  p->typf2=INT;
-	}
-      }
-    }
-    if(c==CALL&&argsize<zm2l(m->q2.val.vmax)) argsize=zm2l(m->q2.val.vmax);
-  }
-  peephole(p);
-
-  for(c=1;c<=MAXR;c++){
-    if(regsa[c]||regused[c]){
-      BSET(regs_modified,c);
-    }
-  }
-
-  localsize=(zm2l(offset)+3)/4*4;
-#if FIXED_SP
-  /*FIXME: adjust localsize to get an aligned stack-frame */
-#endif
-
-  function_top(f,v,localsize);
-
-  for(;p;p=p->next){
-    c=p->code;t=p->typf;
-    if(c==NOP) {p->z.flags=0;continue;}
-    if(c==ALLOCREG) {regs[p->q1.reg]=1;continue;}
-    if(c==FREEREG) {regs[p->q1.reg]=0;continue;}
-
-    if(DEBUG&256){emit(f,"# "); pric2(f,p);}
-    if(DEBUG&512) emit(f,"# stackoffset=%ld, notpopped=%ld, dontpop=%ld\n",stackoffset,notpopped,dontpop);
-    if(notpopped&&!dontpop){
-      int flag=0;
-      if(c==LABEL||c==COMPARE||c==TEST||c==BRA){
-        emit(f,"\tadd\t%s,%ld\n",regnames[sp],notpopped);
-        pop(notpopped);notpopped=0;
-      }
-    }
-
-    if(c==LABEL) {emit(f,"%s%d:\n",labprefix,t);continue;}
-    if(c==BRA){
-      if(0/*t==exit_label&&framesize==0*/)
-	emit(f,ret);
-      else
-	emit(f,"\tb\t%s%d\n",labprefix,t);
-      continue;
-    }
-    if(c>=BEQ&&c<BRA){
-      if(lastcomp&UNSIGNED)
-	emit(f,"\tb%s\t",ccu[c-BEQ]);
-      else
-	emit(f,"\tb%s\t",ccs[c-BEQ]);
-      if(isreg(q1)){
-	emit_obj(f,&p->q1,0);
-	emit(f,",");
-      }
-      emit(f,"%s%d\n",labprefix,t);
-      continue;
-    }
-    if(c==MOVETOREG){
-      load_reg(f,p->z.reg,&p->q1,regtype[p->z.reg]->flags);
-      continue;
-    }
-    if(c==MOVEFROMREG){
-      store_reg(f,p->q1.reg,&p->z,regtype[p->q1.reg]->flags);
-      continue;
-    }
-    if(c==PUSH)
-      dontpop+=zm2l(p->q2.val.vmax);
-    if((c==ASSIGN||c==PUSH)&&((t&NQ)>POINTER||((t&NQ)==CHAR&&zm2l(p->q2.val.vmax)!=1))){
-      int i,cnt,unit,lab,treg,acnt=0,atreg=0;
-      long size;
-      char *ut;
-      if((p->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&reg_is_scratched(p,p->q1.reg)){
-	q1reg=p->q1.reg;
-	if(p->q1.am) ierror(0);
-      }else{
-	q1reg=t1;
-	if(p->q1.flags&(REG|DREFOBJ)){
-	  p->q1.flags&=~DREFOBJ;
-	  load_reg(f,q1reg,&p->q1,POINTER);
-	}else
-	  load_address(f,q1reg,&p->q1,POINTER);
-      }
-      if((p->z.flags&(REG|DREFOBJ))==(REG|DREFOBJ)&&reg_is_scratched(p,p->z.reg)){
-	zreg=p->z.reg;
-	if(p->z.am) ierror(0);
-      }else if(c==PUSH){
-	zreg=sp;
-      }else{
-	if(q1reg==t1)
-	  zreg=t2;
-	else
-	  zreg=t1;
-	if(p->z.flags&(REG|DREFOBJ)){
-	  p->z.flags&=~DREFOBJ;
-	  load_reg(f,zreg,&p->z,POINTER);
-	}else
-	  load_address(f,zreg,&p->z,POINTER);
-      }      
-      if(zreg==t2){
-	treg=get_reg(f,p);
-	atreg=1;
-      }else if(zreg==t1||q1reg==t1)
-	treg=t2;
-      else
-	treg=t1;
-
-      unit=1;ut="b";
-      size=zm2l(p->q2.val.vmax);
-
-      if(c==PUSH)
-	emit(f,"\tadd\t%s,%ld\n",regnames[q1reg],size);
-
-      if(size/unit>=8){
-	if(treg!=t2&&zreg!=t2)
-	  cnt=t2;
-	else{
-	  cnt=get_reg(f,p);
-	  acnt=1;
-	}
-	emit(f,"\tmov\t%s,%ld\n",regnames[cnt],(size/unit)>>2);
-	emit(f,"%s%d:\n",labprefix,++label);
-      }
-
-      for(i=0;i<((size/unit>4)?4:size/unit);i++){
-	if(c!=PUSH){
-	  emit(f,"\tld%s\t%s,(%s)++\n",ut,regnames[treg],regnames[q1reg]);
-	  emit(f,"\tst%s\t%s,(%s)++\n",ut,regnames[treg],regnames[zreg]);
-	}else{
-	  emit(f,"\tld%s\t%s,--(%s)\n",ut,regnames[treg],regnames[q1reg]);
-	  emit(f,"\tst%s\t%s,--(%s)\n",ut,regnames[treg],regnames[zreg]);
-	}
-      }
-      if(size/unit>=8){
-	emit(f,"\taddcmpbne\t%s,-1,0,%s%d\n",regnames[cnt],labprefix,label);
-      }
-      for(i=0;i<((size/unit)&3);i++){
-	if(c!=PUSH){
-	  emit(f,"\tld%s\t%s,(%s)++\n",ut,regnames[treg],regnames[q1reg]);
-	  emit(f,"\tst%s\t%s,(%s)++\n",ut,regnames[treg],regnames[zreg]);
-	}else{
-	  emit(f,"\tld%s\t%s,--(%s)\n",ut,regnames[treg],regnames[q1reg]);
-	  emit(f,"\tst%s\t%s,--(%s)\n",ut,regnames[treg],regnames[zreg]);
-	}
-      }
-      if(c==PUSH)
-	push(size);
-      if(acnt) free_reg(f,cnt);
-      if(atreg) free_reg(f,treg);
-      continue;
-    }
-
-    if(c==CALL){
-      int reg;
-      /*FIXME*/
-#if 0      
-      if(stack_valid&&(p->q1.flags&(VAR|DREFOBJ))==VAR&&p->q1.v->fi&&(p->q1.v->fi->flags&ALL_STACK)){
-	if(framesize+zum2ul(p->q1.v->fi->stack1)>stack)
-	  stack=framesize+zum2ul(p->q1.v->fi->stack1);
-      }else
-	stack_valid=0;
-#endif
-      /*FIXME: does not work with fixed parameters on stack */
-      if((p->q1.flags&(VAR|DREFOBJ))==VAR&&!strcmp("__va_start",p->q1.v->identifier)){
-	emit(f,"\tadd\t%s,%s,%ld\n",regnames[r0],regnames[sp],localsize+rsavesize-stackoffset);
-	continue;
-      }
-
-      if((p->q1.flags&(VAR|DREFOBJ))==VAR&&p->q1.v->fi&&p->q1.v->fi->inline_asm){
-        emit_inline_asm(f,p->q1.v->fi->inline_asm);
-      }else{
-	if((p->q1.flags&(REG|DREFOBJ))==DREFOBJ){
-	  p->q1.flags&=~DREFOBJ;
-	  load_reg(f,t1,&p->q1,POINTER);
-	  p->q1.flags|=(DREFOBJ|REG);
-	  p->q1.reg=t1;
-	}
-	emit(f,"\tbl\t");
-	if((p->q1.flags&(REG|DREFOBJ))==(REG|DREFOBJ)){
-	  emit(f,"%s",regnames[p->q1.reg]);
-	}else{
-	  no_suffix=1;
-	  emit_obj(f,&p->q1,t);
-	  no_suffix=0;
-	}
-	emit(f,"\n");
-      }
-
-      if(!zmeqto(p->q2.val.vmax,l2zm(0L))){
-        notpopped+=zm2l(p->q2.val.vmax);
-        dontpop-=zm2l(p->q2.val.vmax);
-        if(!NODELAYEDPOP&&!vlas&&stackoffset==-notpopped){
-          /*  Entfernen der Parameter verzoegern  */
-        }else{
-	  emit(f,"\tadd\t%s,%ld\n",regnames[sp],zm2l(p->q2.val.vmax));
-          pop(zm2l(p->q2.val.vmax));
-          notpopped-=zm2l(p->q2.val.vmax);
-        }
-      }
-
-      if((p->q1.flags&(VAR|DREFOBJ))==VAR&&p->q1.v->fi&&(p->q1.v->fi->flags&ALL_REGS)){
-	bvunite(regs_modified,p->q1.v->fi->regs_modified,RSIZE);
-      }else{
-	int i;
-	for(i=1;i<=MAXR;i++){
-	  if(regscratch[i]) BSET(regs_modified,i);
-	}
-      }
-      continue;
-    }
-
-    if(c==ADDRESS){
-      if(isreg(z))
-	zreg=p->z.reg;
-      else
-	zreg=t1;
-      load_address(f,zreg,&p->q1,POINTER);
-      save_result(f,p);
-      continue;
-    }
-
-    if(isreg(q1)) q1wasreg=1; else q1wasreg=0;
-    if(isreg(q2)) q2wasreg=1; else q2wasreg=0;
-    if(isreg(z)) zwasreg=1; else zwasreg=0;
-
-    p=preload(f,p);
-    c=p->code;
-    if(c==SUBPFP) c=SUB;
-    if(c==ADDI2P) c=ADD;
-    if(c==SUBIFP) c=SUB;
-    if(c==CONVERT){
-      if(ISFLOAT(q1typ(p))){
-	if(ztyp(p)&UNSIGNED) ierror(0);
-	if(ISFLOAT(ztyp(p)))
-	  emit(f,"\tmov%s\t%s,%s\n",cc,regnames[zreg],regnames[q1reg]);
-	else
-	  emit(f,"\tftrunc%s\t%s,%s\n",cc,regnames[zreg],regnames[q1reg]);
-	save_result(f,p);
-	continue;
-      }
-      if(ISFLOAT(ztyp(p))){
-	emit(f,"\tflt%c%s\t%s,%s\n",(q1typ(p)&UNSIGNED)?'u':'s',cc,regnames[zreg],regnames[q1reg]);
-	save_result(f,p);
-	continue;
-      }
-      if(sizetab[q1typ(p)&NQ]<sizetab[ztyp(p)&NQ]){
-	int mask;
-	if((q1typ(p)&NQ)==CHAR)
-	  mask=7;
-	else
-	  mask=15;
-	if(q1typ(p)&UNSIGNED)
-	  mask++;
-	if(q1wasreg||(q1typ(p)&NU)==CHAR)
-	  emit(f,"\text%c%s\t%s,%s,%d\n",(q1typ(p)&UNSIGNED)?'u':'s',cc,regnames[zreg],regnames[q1reg],mask);
-      }else{
-	zreg=q1reg;
-      }	  
-      save_result(f,p);
-      continue;
-    }
-    if(c==KOMPLEMENT){
-      emit(f,"\tmvn%s\t%s,%s\n",cc,regnames[zreg],regnames[q1reg]);
-      save_result(f,p);
-      continue;
-    }
-    if(c==SETRETURN){
-      if(isreg(q1)){
-	if(p->q1.reg!=p->z.reg)
-	  emit(f,"\tmov%s\t%s,%s\n",cc,regnames[p->z.reg],regnames[p->q1.reg]);
-      }else
-	load_reg(f,p->z.reg,&p->q1,t);
-      BSET(regs_modified,p->z.reg);
-      continue;
-    }
-    if(c==GETRETURN){
-      if(p->q1.reg){
-        zreg=p->q1.reg;
-	save_result(f,p);
-      }else
-        p->z.flags=0;
-      continue;
-    }
-
-    if(c==ASSIGN||c==PUSH){
-      if(t==0) ierror(0);
-      if(c==PUSH){
-	if(!q1reg){
-	  q1reg=t1;
-	  load_reg(f,q1reg,&p->q1,t);
-	}
-	if(SHORT_DOUBLE&&ISFLOAT(t)) t=FLOAT;
-	emit(f,"\tst%s%s\t%s,--(%s)\n",sdt(t),cc,regnames[q1reg],regnames[sp]);
-	push(zm2l(p->q2.val.vmax));
-	continue;
-      }
-      if(c==ASSIGN){
-	if(isreg(q1)){
-	  if(isreg(z))
-	    emit(f,"\tmov%s\t%s,%s\n",cc,regnames[zreg],regnames[p->q1.reg]);
-	  else
-	    zreg=p->q1.reg;
-	}else
-	  load_reg(f,zreg,&p->q1,t);
-	save_result(f,p);
-      }
-      continue;
-    }
-    if(c==MINUS){
-      load_reg(f,zreg,&p->q1,t);
-      emit(f,"\tneg%s\t%s,%s\n",cc,regnames[zreg],regnames[zreg]);
-      save_result(f,p);
-      continue;
-    }
-    if(c==TEST){
-      emit(f,"\tcmp%s\t",cc);
-      emit_obj(f,&p->q1,t);
-      emit(f,",0\n");
-      lastcomp=t;
-      continue;
-    }
-    if(c==COMPARE){
-      if(ISFLOAT(t))
-	emit(f,"\tfcmp%s\t%s,",cc,regnames[t1]);
-      else
-	emit(f,"\tcmp%s\t",cc);
-      emit_obj(f,&p->q1,t);
-      emit(f,",");
-      emit_obj(f,&p->q2,t);
-      emit(f,"\n");
-      lastcomp=t;
-      continue;
-    }
-    if(c==MOD){
-      /* TODO: is there a faster way? */
-      int m;
-      if(q2reg!=t2)
-	m=t2;
-      else
-	m=get_reg(f,p);
-      if(!isreg(q1)||p->q1.reg!=zreg)
-	load_reg(f,zreg,&p->q1,t);
-      emit(f,"\tdiv%c%s\t%s,%s,",(t&UNSIGNED)?'u':'s',cc,regnames[m],regnames[zreg]);
-      emit_obj(f,&p->q2,t);
-      emit(f,"\n");
-      emit(f,"\tmul%s\t%s,",cc,regnames[m]);
-      emit_obj(f,&p->q2,t);
-      emit(f,"\n");
-      emit(f,"\tsub%s\t%s,%s,%s\n",cc,regnames[zreg],regnames[zreg],regnames[m]);
-      free_reg(f,m);
-      save_result(f,p);
-      continue;
-    }      
-    if((c>=OR&&c<=AND)||(c>=LSHIFT&&c<MOD)){
-      if(c>=OR&&c<=AND)
-	emit(f,"\t%s%s\t%s,",logicals[c-OR],cc,regnames[zreg]);
-      else{
-	if(ISFLOAT(t))
-	  emit(f,"\t%s%s\t%s,",farithmetics[c-LSHIFT],cc,regnames[zreg]);
-	else
-	  emit(f,"\t%s%s\t%s,",(t&UNSIGNED)?uarithmetics[c-LSHIFT]:arithmetics[c-LSHIFT],cc,regnames[zreg]);
-      }
-      if(!isreg(q1)||p->q1.reg!=zreg||*cc||c==DIV||ISFLOAT(t)){
-	emit_obj(f,&p->q1,t);
-	emit(f,",");
-      }
-      emit_obj(f,&p->q2,t);
-      emit(f,"\n");
-      save_result(f,p);
-      continue;
-    }
-    pric2(stdout,p);
-    ierror(0);
-  }
-
-  if(notpopped){
-    emit(f,"\tadd\t%s,%ld\n",regnames[sp],notpopped);
-    pop(notpopped);notpopped=0;
-  }
-
-  function_bottom(f,v,localsize);
-  if(stack_valid){
-    if(!v->fi) v->fi=new_fi();
-    v->fi->flags|=ALL_STACK;
-    v->fi->stack1=stack;
-  }
-  /*emit(f,"# stacksize=%lu%s\n",zum2ul(stack),stack_valid?"":"+??");*/
-}
-
-int shortcut(int code,int typ)
-{
-  return 0;
-}
-
-int reg_parm(struct reg_handle *m, struct Typ *t,int vararg,struct Typ *d)
-{
-  int f;
-
-  if(vararg)
-    return 0;
-
-  f=t->flags&NQ;
-  if(ISINT(f)||ISFLOAT(f)||f==POINTER){
-    if(zmeqto(sizetab[f],l2zm(8L))){
-      if(m->gregs<=r4){
-	m->gregs=(m->gregs+1)&0xfe;
-	m->gregs+=2;
-	if(m->gregs==r1)
-	  return r0r1;
-	else if(m->gregs==r3)
-	  return r2r3;
-	else if(m->gregs==r5)
-	  return r4r5;
-	else
-	  ierror(0);
-      }else
-	return 0;
-    }else{
-      if(m->gregs<=r4)
-	return ++m->gregs;
-      else
-	return 0;
-    }
-  }
-  return 0;
-}
-
-int handle_pragma(const char *s)
-{
-}
-void cleanup_cg(FILE *f)
-{
-}
-void cleanup_db(FILE *f)
-{
-  if(f) section=-1;
-}
-
-char *use_libcall(int c,int t,int t2)
-/* Return name of library function, if this node should be
-   implemented via libcall. */
-{
-  static char fname[16];
-  char *ret = NULL;
-
-  if(c==COMPARE){
-    if((t&NQ)==DOUBLE) t=(SHORT_DOUBLE)?FLOAT:LDOUBLE;
-    if((t&NQ)==LLONG||t==LDOUBLE){
-      sprintf(fname,"__cmp%s%s%ld",(t&UNSIGNED)?"u":"s",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
-      ret=fname;
-    }
-  }else{
-    t&=NU;
-    t2&=NU;
-    if(SHORT_DOUBLE){
-      if(ISFLOAT(t)) t=FLOAT;
-      if(ISFLOAT(t2)) t2=FLOAT;
-    }else{
-      if(t==DOUBLE) t=LDOUBLE;
-      if(t2==DOUBLE) t2=LDOUBLE;
-    }
-    if(c==CONVERT){
-      if(t==t2) return 0;
-      if(t==FLOAT&&t2==LDOUBLE) return "__flt64toflt32";
-      if(t==LDOUBLE&&t2==FLOAT) return "__flt32toflt64";
-      if(t!=LDOUBLE&&t2!=LDOUBLE&&(t&NQ)!=LLONG&&(t2&NQ)!=LLONG) return 0;
-      if(ISFLOAT(t)){
-        sprintf(fname,"__%cint%ldtoflt%d",(t2&UNSIGNED)?'u':'s',zm2l(sizetab[t2&NQ])*8,(t==FLOAT)?32:64);
-        ret=fname;
-      }
-      if(ISFLOAT(t2)&&(t&NU)==LLONG){
-        sprintf(fname,"__flt%dto%cint%ld",((t2&NU)==FLOAT)?32:64,(t&UNSIGNED)?'u':'s',zm2l(sizetab[t&NQ])*8);
-        ret=fname;
-      }
-    }
-    if((t&NQ)==LLONG||t==DOUBLE){
-      if((c>=LSHIFT&&c<=MOD)||(c>=OR&&c<=AND)||c==KOMPLEMENT||c==MINUS){
-        if(t==(UNSIGNED|LLONG)&&(c==DIV||c==MOD||c==RSHIFT)){
-          sprintf(fname,"__%suint64",ename[c]);
-          ret=fname;
-        }else if((t&NQ)==LLONG){
-          sprintf(fname,"__%sint64",ename[c]);
-          ret=fname;
-        }else{
-          sprintf(fname,"__%s%s%s%ld",ename[c],(t&UNSIGNED)?"u":"",ISFLOAT(t)?"flt":"int",zm2l(sizetab[t&NQ])*8);
-          ret=fname;
-        }
-      }
-    }
-  }
-
-  return ret;
-}
diff -Naur vbcc/machines/vidcore/machine.dt /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.dt
--- vbcc/machines/vidcore/machine.dt	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.dt	Thu Jan  1 00:00:00 1970
@@ -1,16 +0,0 @@
-S8BS
-S8BU
-S16BSBE S16BSLE
-S16BUBE S16BULE
-S32BSBE S32BSLE
-S32BUBE S32BULE
-S32BSBE S32BSLE
-S32BUBE S32BULE
-S64BSBE S64BSLE
-S64BUBE S64BULE
-S32BIEEEBE
-S64BIEEEBE
-S64BIEEEBE
-S32BUBE S32BULE
-
-
diff -Naur vbcc/machines/vidcore/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.h
--- vbcc/machines/vidcore/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/vidcore/machine.h	Thu Jan  1 00:00:00 1970
@@ -1,131 +0,0 @@
-/*  Backend for VideoCore IV
-    (c) in 2013 by Volker Barthelmann
-*/
-
-/* buil-time configurable options: */
-#define NUM_GPRS 48
-
-#include "dt.h"
-
-
-/*  This struct can be used to implement machine-specific           */
-/*  addressing-modes.                                               */
-/*  Currently possible are (const,gpr) and (gpr,gpr)                */
-struct AddressingMode{
-    int flags;
-    int base;
-    long offset;
-};
-
-/*  The number of registers of the target machine.                  */
-#define MAXR 48
-
-/*  Number of commandline-options the code-generator accepts.       */
-#define MAXGF 20
-
-/*  If this is set to zero vbcc will not generate ICs where the     */
-/*  target operand is the same as the 2nd source operand.           */
-/*  This can sometimes simplify the code-generator, but usually     */
-/*  the code is better if the code-generator allows it.             */
-#define USEQ2ASZ 0
-
-/*  This specifies the smallest integer type that can be added to a */
-/*  pointer.                                                        */
-#define MINADDI2P INT
-
-/*  This specifies the smallest integer type that can be added to a */
-/*  pointer.                                                        */
-#define MAXADDI2P INT
-
-/*  If the bytes of an integer are ordered most significant byte    */
-/*  byte first and then decreasing set BIGENDIAN to 1.              */
-#define BIGENDIAN 0
-
-/*  If the bytes of an integer are ordered lest significant byte    */
-/*  byte first and then increasing set LITTLEENDIAN to 1.           */
-#define LITTLEENDIAN 1
-
-/*  Note that BIGENDIAN and LITTLEENDIAN are mutually exclusive.    */
-
-/*  If switch-statements should be generated as a sequence of       */
-/*  SUB,TST,BEQ ICs rather than COMPARE,BEQ ICs set this to 1.      */
-/*  This can yield better code on some machines.                    */
-#define SWITCHSUBS 1
-
-/*  In optimizing compilation certain library memcpy/strcpy-calls   */
-/*  with length known at compile-time will be inlined using an      */
-/*  ASSIGN-IC if the size is less or equal to INLINEMEMCPY.         */
-/*  The type used for the ASSIGN-IC will be UNSIGNED|CHAR.          */
-#define INLINEMEMCPY 1024
-
-/*  Parameters are sometimes passed in registers without __reg.     */
-#define HAVE_REGPARMS 1
-
-/*  Parameters on the stack should be pushed in order rather than   */
-/*  in reverse order.                                               */
-#undef ORDERED_PUSH
-
-/*  Structure for reg_parm().                                       */
-struct reg_handle{
-    unsigned long gregs;
-};
-
-/*  We have some target-specific variable attributes.               */
-#define HAVE_TARGET_ATTRIBUTES
-
-/* We have target-specific pragmas */
-#define HAVE_TARGET_PRAGMAS
-
-/*  We keep track of all registers modified by a function.          */
-#define HAVE_REGS_MODIFIED 1
-
-/* We have a implement our own cost-functions to adapt 
-   register-allocation */
-#define HAVE_TARGET_RALLOC 1
-#define cost_move_reg(x,y) 1
-#define cost_load_reg(x,y) 2
-#define cost_save_reg(x,y) 2
-#define cost_pushpop_reg(x) 3
-
-/* size of buffer for asm-output, this can be used to do
-   peephole-optimizations of the generated assembly-output */
-#define EMIT_BUF_LEN 1024 /* should be enough */
-/* number of asm-output lines buffered */
-#define EMIT_BUF_DEPTH 4
-
-/*  We have no asm_peephole to optimize assembly-output */
-#define HAVE_TARGET_PEEPHOLE 0
-
-/* we do not have a mark_eff_ics function, this is used to prevent
-   optimizations on code which can already be implemented by efficient
-   assembly */
-#undef HAVE_TARGET_EFF_IC
-
-/* we only need the standard data types (no bit-types, different pointers
-   etc.) */
-#undef HAVE_EXT_TYPES
-#undef HAVE_TGT_PRINTVAL
-
-/* we do not need extra elements in the IC */
-#undef HAVE_EXT_IC
-
-/* we do use unsigned int as size_t (but unsigned long, the default) */
-#define HAVE_INT_SIZET 1
-
-/* we need register-pairs */
-#define HAVE_REGPAIRS 1
-
-
-/* do not create CONVERT ICs from integers smaller than int to floats */
-#define MIN_INT_TO_FLOAT_TYPE INT
-
-/* do not create CONVERT ICs from floats to ints smaller than int */
-#define MIN_FLOAT_TO_INT_TYPE INT
-
-/* do not create CONVERT_ICs from floats to unsigned integers */
-#define AVOID_FLOAT_TO_UNSIGNED 1
-
-/* do not create CONVERT_ICs from unsigned integers to floats */
-#define AVOID_UNSIGNED_TO_FLOAT 0
-
-#define HAVE_LIBCALLS 1
diff -Naur vbcc/machines/z/dt.c /usr/glenda/advbcc/Advent-master/vbcc/machines/z/dt.c
--- vbcc/machines/z/dt.c	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/z/dt.c	Tue Sep 22 04:22:06 2015
@@ -0,0 +1,7 @@
+
+
+/* Machine generated file. DON'T TOUCH ME! */
+
+
+#include "dt.h"
+
diff -Naur vbcc/machines/z/dt.h /usr/glenda/advbcc/Advent-master/vbcc/machines/z/dt.h
--- vbcc/machines/z/dt.h	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/z/dt.h	Tue Sep 22 04:22:06 2015
@@ -0,0 +1,94 @@
+
+
+/* Machine generated file. DON'T TOUCH ME! */
+
+
+#ifndef DT_H
+#define DT_H 1
+typedef char zchar;
+typedef unsigned char zuchar;
+typedef short zshort;
+typedef unsigned short zushort;
+typedef int zint;
+typedef unsigned int zuint;
+typedef long zlong;
+typedef unsigned long zulong;
+typedef long long zllong;
+typedef unsigned long long zullong;
+typedef float zfloat;
+typedef double zdouble;
+typedef long double zldouble;
+typedef char * zpointer;
+#define zc2zm(x) ((long long)(x))
+#define zs2zm(x) ((long long)(x))
+#define zi2zm(x) ((long long)(x))
+#define zl2zm(x) ((long long)(x))
+#define zll2zm(x) ((long long)(x))
+#define zm2zc(x) ((char)(x))
+#define zm2zs(x) ((short)(x))
+#define zm2zi(x) ((int)(x))
+#define zm2zl(x) ((long)(x))
+#define zm2zll(x) ((long long)(x))
+#define zuc2zum(x) ((unsigned long long)(x))
+#define zus2zum(x) ((unsigned long long)(x))
+#define zui2zum(x) ((unsigned long long)(x))
+#define zul2zum(x) ((unsigned long long)(x))
+#define zull2zum(x) ((unsigned long long)(x))
+#define zum2zuc(x) ((unsigned char)(x))
+#define zum2zus(x) ((unsigned short)(x))
+#define zum2zui(x) ((unsigned int)(x))
+#define zum2zul(x) ((unsigned long)(x))
+#define zum2zull(x) ((unsigned long long)(x))
+#define zum2zm(x) ((long long)(x))
+#define zm2zum(x) ((unsigned long long)(x))
+#define zf2zld(x) ((long double)(x))
+#define zd2zld(x) ((long double)(x))
+#define zld2zf(x) ((float)(x))
+#define zld2zd(x) ((double)(x))
+#define zld2zm(x) ((long long)(x))
+#define zm2zld(x) ((long double)(x))
+#define zld2zum(x) ((unsigned long long)(x))
+#define zum2zld(x) ((long double)(x))
+#define zp2zum(x) ((unsigned long long)(x))
+#define zum2zp(x) ((char *)(x))
+#define l2zm(x) ((long long)(x))
+#define ul2zum(x) ((unsigned long long)(x))
+#define d2zld(x) ((long double)(x))
+#define zm2l(x) ((long)(x))
+#define zum2ul(x) ((unsigned long)(x))
+#define zld2d(x) ((double)(x))
+#define zmadd(a,b) ((a)+(b))
+#define zumadd(a,b) ((a)+(b))
+#define zldadd(a,b) ((a)+(b))
+#define zmsub(a,b) ((a)-(b))
+#define zumsub(a,b) ((a)-(b))
+#define zldsub(a,b) ((a)-(b))
+#define zmmult(a,b) ((a)*(b))
+#define zummult(a,b) ((a)*(b))
+#define zldmult(a,b) ((a)*(b))
+#define zmdiv(a,b) ((a)/(b))
+#define zumdiv(a,b) ((a)/(b))
+#define zlddiv(a,b) ((a)/(b))
+#define zmmod(a,b) ((a)%(b))
+#define zummod(a,b) ((a)%(b))
+#define zmlshift(a,b) ((a)<<(b))
+#define zumlshift(a,b) ((a)<<(b))
+#define zmrshift(a,b) ((a)>>(b))
+#define zumrshift(a,b) ((a)>>(b))
+#define zmand(a,b) ((a)&(b))
+#define zumand(a,b) ((a)&(b))
+#define zmor(a,b) ((a)|(b))
+#define zumor(a,b) ((a)|(b))
+#define zmxor(a,b) ((a)^(b))
+#define zumxor(a,b) ((a)^(b))
+#define zmmod(a,b) ((a)%(b))
+#define zummod(a,b) ((a)%(b))
+#define zmkompl(a) (~(a))
+#define zumkompl(a) (~(a))
+#define zmleq(a,b) ((a)<=(b))
+#define zumleq(a,b) ((a)<=(b))
+#define zldleq(a,b) ((a)<=(b))
+#define zmeqto(a,b) ((a)==(b))
+#define zumeqto(a,b) ((a)==(b))
+#define zldeqto(a,b) ((a)==(b))
+#endif
diff -Naur vbcc/machines/z/machine.c /usr/glenda/advbcc/Advent-master/vbcc/machines/z/machine.c
--- vbcc/machines/z/machine.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/z/machine.c	Tue Sep 22 04:25:31 2015
@@ -60,6 +60,10 @@
 static char FILE_[]=__FILE__;
 char cg_copyright[]="vbcc code-generator for Z-machine V0.0a (c) in 2001 by David Given";
 
+extern char *strdup(const char *);
+
+#define NOT_ON_STACK 999999
+
 /* Command-line flags. */
 
 int g_flags[MAXGF] = {
@@ -68,7 +72,9 @@
 	0,
 	0,
 	0,
-	0
+	0,
+	0,
+	STRINGFLAG
 };
 char *g_flags_name[MAXGF] = {
 	"module-name",
@@ -76,7 +82,9 @@
 	"trace-all",
 	"safe-branches",
 	"comment-ic",
-	"comment-misc"
+	"comment-misc",
+	"patch-not",
+	"opt-puts"
 };
 union ppi g_flags_val[MAXGF];
 
@@ -197,6 +205,10 @@
 
 static char* modulename;
 
+/* Name of the function to use for "puts" optimization. */
+
+const char *z_optimize_puts_name;
+
 /* Stack frame layout:
  *
  *  --------------
@@ -243,8 +255,8 @@
 
 /* Some useful zops. */
 
-struct zop zop_zero = {ZOP_CONSTANT, {constant: 0}};
-struct zop zop_xp = {ZOP_REG, {reg: XP}};
+struct zop zop_zero = {ZOP_CONSTANT, {0}};
+struct zop zop_xp = {ZOP_REG, {XP}};
 struct zop zop_stack = {ZOP_STACK, 0};
 
 /* Temporaries used to store comparison register numbers. */
@@ -337,20 +349,16 @@
 
 /* Extract the sign extended byte n of a value. */
 
-static char xbyte(zmax val, int byte)
+static unsigned char xbyte(zmax val, int byte)
 {
-	val <<= (sizeof(val)*8) - (byte*8) - 8;
-	val >>= (sizeof(val)*8) - 8;
-	return (unsigned char) val;
+	return val >> (byte*8);
 }
 
 /* Extract the sign extended word n of a value. */
 
-static zshort xword(zmax val, int word)
+static short xword(zmax val, int word)
 {
-	val <<= (sizeof(val)*8) - (word*16) - 16;
-	val >>= (sizeof(val)*8) - 16;
-	return (zshort) val;
+	return val >> (word*16);
 }
 
 /* Debug function: prints the text name of a type. */
@@ -428,17 +436,12 @@
 				break;
 
 			case FLOAT:
-				fprintf(fp, "[float #%04X]", obj->val.vfloat);
+				fprintf(fp, "[float #%f]", obj->val.vfloat);
 				break;
 
 			case DOUBLE:
-				fprintf(fp, "[double #%08X]", obj->val.vdouble);
-				break;
-#if 0
-			case POINTER:
-				fprintf(fp, "[pointer #%04X]", obj->val.vpointer);
+				fprintf(fp, "[double #%f]", obj->val.vdouble);
 				break;
-#endif
 		}
 	}
 	else if (f == REG)
@@ -455,13 +458,15 @@
 		if ((obj->v->storage_class == AUTO) ||
 		    (obj->v->storage_class == REGISTER))
 		{
-			zmax offset = obj->v->offset;
-			//if (offset < 0)
-			//	offset = -(offset+maxalign);
-			fprintf(fp, " at fp%+d", offset);
+			int offset = obj->v->offset;
+			if (offset == NOT_ON_STACK) {
+				fprintf(fp, " (not on stack)", offset);
+			} else {
+				fprintf(fp, " at fp%+d", offset);
+			}
 		}
 
-		fprintf(fp, "+%ld", obj->val.vlong);
+		fprintf(fp, "+%d", (int)obj->val.vlong);
 
 		if (f & REG)
 			fprintf(fp, " in %s", regnames[obj->reg]);
@@ -503,19 +508,7 @@
 		case MINUS:		p = "MINUS";		break;
 		case ADDRESS:		p = "ADDRESS";		break;
 		case CALL:		p = "CALL";		break;
-#if 0
-		case CONVCHAR:		p = "CONVCHAR";		break;
-		case CONVSHORT:		p = "CONVSHORT";	break;
-		case CONVINT:		p = "CONVINT";		break;
-		case CONVLONG:		p = "CONVLONG";		break;
-		case CONVFLOAT:		p = "CONVFLOAT";	break;
-		case CONVDOUBLE:	p = "CONVDOUBLE";	break;
-		case CONVPOINTER:	p = "CONVPOINTER";	break;
-		case CONVUCHAR:		p = "CONVUCHAR";	break;
-		case CONVUSHORT:	p = "CONVUSHORT";	break;
-		case CONVUINT:		p = "CONVUINT";		break;
-		case CONVULONG:		p = "CONVULONG";	break;
-#endif
+		case CONVERT:		p = "CONVERT";		break;
 		case ALLOCREG:		p = "ALLOCREG";		break;
 		case FREEREG:		p = "FREEREG";		break;
 		case COMPARE:		p = "COMPARE";		break;
@@ -580,6 +573,10 @@
 	if (!modulename)
 		modulename = "";
 
+	z_optimize_puts_name = g_flags_val[7].p;
+	if (!z_optimize_puts_name)
+		z_optimize_puts_name = "print (string) ";
+
   /*  Initialize the min/max-settings. Note that the types of the     */
   /*  host system may be different from the target system and you may */
   /*  only use the smallest maximum values ANSI guarantees if you     */
@@ -743,8 +740,8 @@
 			break;
 			
 		case STATIC:
-			fprintf(fp, "Array STATIC_%s_%ld ->\n",
-				modulename, var->offset);
+			fprintf(fp, "Array STATIC_%s_%d ->\n",
+				modulename, (int)var->offset);
 			currentvar.type = STATIC;
 			currentvar.val.number = var->offset;
 			currentvar.offset = 0;
@@ -757,7 +754,8 @@
 
 void gen_ds(FILE *fp, zmax size, struct Typ *typ)
 {
-	fprintf(fp, " %ld\n", size);
+	if (currentvar.offset != 0) ierror(0);
+	fprintf(fp, " %d\n", (int)size);
 	currentvar.offset += size;
 }
 
@@ -834,6 +832,8 @@
 zmax voff(struct obj* obj)
 {
 	zmax offset = obj->v->offset;
+	if (offset == NOT_ON_STACK)
+		return NOT_ON_STACK;  /* this result should never be used */
 	if (offset < 0)
 		offset = stackparamadjust + stackoffset - offset - maxalign;
 	else
@@ -892,8 +892,8 @@
 	switch (obj->v->storage_class)
 	{
 		case STATIC:
-			fprintf(fp, "STATIC_%s_%ld",
-				modulename, obj->v->offset);
+			fprintf(fp, "STATIC_%s_%d",
+				modulename, (int)obj->v->offset);
 			break;
 
 		case EXTERN:
@@ -956,10 +956,10 @@
 		case AUTO:
 		case REGISTER: /* Local variable */
 		{
-			zmax offset = voff(obj);
+			int offset = voff(obj);
 
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb xp 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb xp (%d) %s;\n",
 					offset, regnames[reg]);
 			else
 			{
@@ -969,11 +969,11 @@
 					c.type = ZOP_CONSTANT;
 					c.val.constant = offset;
 					emit_add(fp, &zop_xp, &c, &zop_stack);
-					//fprintf(fp, "\t@add xp 0%+ld -> sp;\n", offset);
+					//fprintf(fp, "\t@add xp (%ld) -> sp;\n", offset);
 					fprintf(fp, "\t@storew sp 0 %s;\n", regnames[reg]);
 				}
 				else
-					fprintf(fp, "\t@storew xp 0%+ld %s;\n",
+					fprintf(fp, "\t@storew xp (%d) %s;\n",
 						offset >> 1, regnames[reg]);
 			}
 			return;
@@ -988,8 +988,8 @@
 			{
 				fprintf(fp, "\t@storeb ");
 				emit_identifier(fp, obj);
-				fprintf(fp, " 0%+ld %s;\n",
-					obj->val.vlong, regnames[reg]);
+				fprintf(fp, " (%d) %s;\n",
+					(int)obj->val.vlong, regnames[reg]);
 			}
 			else
 			{
@@ -997,8 +997,8 @@
 				{
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> sp;\n",
-						obj->val.vlong);
+					fprintf(fp, " (%d) -> sp;\n",
+						(int)obj->val.vlong);
 					fprintf(fp, "\t@storew sp 0 %s;\n",
 						regnames[reg]);
 				}
@@ -1006,15 +1006,15 @@
 				{
 					fprintf(fp, "\t@storew ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld %s;\n",
-						obj->val.vlong >> 1, regnames[reg]);
+					fprintf(fp, " (%d) %s;\n",
+						(int)(obj->val.vlong >> 1), regnames[reg]);
 				}
 			}
 			return;
 #if 0
 		case EXTERN: /* External linkage */
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb _%s 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb _%s (%ld) %s;\n",
 					obj->v->identifier, offset, regnames[reg]);
 			else
 			{
@@ -1025,7 +1025,7 @@
 
 		case STATIC: /* Static global */
 			if ((typf & NQ) == CHAR)
-				fprintf(fp, "\t@storeb STATIC_%s_%ld 0%+ld %s;\n",
+				fprintf(fp, "\t@storeb STATIC_%s_%ld (%ld) %s;\n",
 					modulename, obj->v->offset, offset, regnames[reg]);
 			else
 				fprintf(fp, "\t@storew STATIC_%s_%ld 0 %s;\n",
@@ -1071,12 +1071,6 @@
 	int flags = obj->flags &
 		(KONST|REG|VAR|DREFOBJ|VARADR);
 
-	/* The only thing you can do with a function is to take the address of
-	 * it. */
-
-	if ((typf & NQ) == FUNKT)
-		flags &= ~DREFOBJ & ~VARADR;
-
 	/* Is this a memory dereference? */
 
 	if (flags & DREFOBJ)
@@ -1096,7 +1090,7 @@
 			case UNSIGNED|CHAR:	c.val.constant = obj->val.vuchar;	break;
 			case SHORT:		c.val.constant = obj->val.vshort;	break;
 			case UNSIGNED|SHORT:	c.val.constant = obj->val.vushort;	break;
-		case POINTER:	      ierror(0);
+			case POINTER:	      	c.val.constant = obj->val.vulong;	break;
 			case INT:		c.val.constant = obj->val.vint;		break;
 			case UNSIGNED|INT:	c.val.constant = obj->val.vuint;	break;
 			default:
@@ -1127,8 +1121,8 @@
 			case REGISTER: /* Local variable */
 				if (flags & VARADR)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
-						voff(obj), regnames[reg]);
+					fprintf(fp, "\t@add xp (%d) -> %s;\n",
+						(int)voff(obj), regnames[reg]);
 				}
 				else if (flags & REG)
 				{
@@ -1138,20 +1132,20 @@
 				}
 				else
 				{
-					zmax offset = voff(obj);
+					int offset = voff(obj);
 
 					if ((typf & NQ) == CHAR)
-						fprintf(fp, "\t@loadb xp 0%+ld -> %s;\n",
+						fprintf(fp, "\t@loadb xp (%d) -> %s;\n",
 							offset, regnames[reg]);
 					else
 					{
 						if (offset & 1)
 						{
-							fprintf(fp, "\t@add xp 0%+ld -> sp;\n", offset);
+							fprintf(fp, "\t@add xp (%d) -> sp;\n", offset);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n", regnames[reg]);
 						}
 						else
-							fprintf(fp, "\t@loadw xp 0%+ld -> %s;\n",
+							fprintf(fp, "\t@loadw xp (%d) -> %s;\n",
 								offset >> 1, regnames[reg]);
 					}
 				}
@@ -1170,12 +1164,12 @@
 
 					fprintf(fp, "\t@add ");
 					emit_identifier(fp, obj);
-					fprintf(fp, " 0%+ld -> %s;\n",
-						obj->val.vlong, regnames[reg]);
+					fprintf(fp, " (%d) -> %s;\n",
+						(int)obj->val.vlong, regnames[reg]);
 				}
 				else if (strcmp(obj->v->identifier, "__va_start") == 0)
 				{
-					fprintf(fp, "\t@add xp 0%+ld -> %s;\n",
+					fprintf(fp, "\t@add xp (%d) -> %s;\n",
 						find_varargs(), regnames[reg]);
 				}
 				else
@@ -1186,8 +1180,8 @@
 					{
 						fprintf(fp, "\t@loadb ");
 						emit_identifier(fp, obj);
-						fprintf(fp, " 0%+ld -> %s;\n",
-							obj->val.vlong, regnames[reg]);
+						fprintf(fp, " (%d) -> %s;\n",
+							(int)obj->val.vlong, regnames[reg]);
 					}
 					else
 					{
@@ -1195,8 +1189,8 @@
 						{
 							fprintf(fp, "\t@add ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> sp;\n",
-								obj->val.vlong);
+							fprintf(fp, " (%d) -> sp;\n",
+								(int)obj->val.vlong);
 							fprintf(fp, "\t@loadw sp 0 -> %s;\n",
 								regnames[reg]);
 						}
@@ -1204,8 +1198,8 @@
 						{
 							fprintf(fp, "\t@loadw ");
 							emit_identifier(fp, obj);
-							fprintf(fp, " 0%+ld -> %s;\n",
-								obj->val.vlong >> 1, regnames[reg]);
+							fprintf(fp, " (%d) -> %s;\n",
+								(int)(obj->val.vlong >> 1), regnames[reg]);
 						}
 					}
 				}
@@ -1224,7 +1218,7 @@
 	obj->flags &= ~DREFOBJ;
 	read_reg(fp, obj, POINTER, 0);
 		
-	if (flags & DREFOBJ)
+	if ((flags & DREFOBJ) && typf != FUNKT)
 	{
 		switch (typf & NQ)
 		{
@@ -1266,18 +1260,13 @@
 			case UNSIGNED|SHORT:	op->val.constant = obj->val.vushort;	break;
 			case INT:		op->val.constant = obj->val.vint;	break;
 			case UNSIGNED|INT:	op->val.constant = obj->val.vuint;	break;
-		case POINTER:		ierror(0);
+			case POINTER:		op->val.constant = obj->val.vulong;	break;
 			default:
 				fprintf(fp, "XXX !!! bad konst type %X\n", typf);
 		}
 		return;
 	}
 
-	/* The only thing you can do with a function is to take the address of it. */
-
-	if ((typf & NQ) == FUNKT)
-		flags &= ~DREFOBJ & ~VARADR;
-
 	/* This is used by the long code. The longop functions can only operate
 	 * on pointers to longs; so if we need to pass in a constant, we have
 	 * to stash it on the stack and return a pointer. */
@@ -1309,7 +1298,7 @@
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == EXTERN) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr extern %s\n", obj->v->identifier);
 		op->type = ZOP_EXTERN;
@@ -1319,7 +1308,7 @@
 
 	if ((flags == (VAR|VARADR)) &&
 	    (obj->v->storage_class == STATIC) &&
-	    (obj->v->offset == 0))
+	    (obj->val.vlong == 0))
 	{
 		debugemit(fp, "! zop varaddr static %ld\n", obj->v->offset);
 		op->type = ZOP_STATIC;
@@ -1404,7 +1393,7 @@
 			return;
 
 		case ZOP_CONSTANT:
-			fprintf(fp, "0%+ld", (zshort)op->val.constant);
+			fprintf(fp, "(%d)", (short)op->val.constant);
 			return;
 
 		case ZOP_EXTERN:
@@ -1412,13 +1401,13 @@
 			return;
 
 		case ZOP_STATIC:
-			fprintf(fp, "STATIC_%s_%ld",
-				modulename, op->val.constant);
+			fprintf(fp, "STATIC_%s_%d",
+				modulename, (int)op->val.constant);
 			return;
 
 		case ZOP_CONSTANTADDR:
-			fprintf(fp, "CONSTANT_%s_%ld",
-				modulename, op->val.constant);
+			fprintf(fp, "CONSTANT_%s_%d",
+				modulename, (int)op->val.constant);
 			return;
 
 		default:
@@ -1585,7 +1574,7 @@
 		push_addrof(fp, z, POINTER, &zz);
 		fprintf(fp, "\t@call_vn __long_loadconst ");
 		emit_zop(fp, &zz);
-		fprintf(fp, " 0%+ld 0%+ld;\n", (short)hi, (short)lo);
+		fprintf(fp, " (%d) (%d);\n", (short)hi, (short)lo);
 		return;
 	}
 
@@ -1598,6 +1587,98 @@
 	fprintf(fp, " 4;\n");
 }
 
+static int ssf_max = 0;
+static short *ssf_frameusage = NULL;
+
+void ssf_record_frameusage(int where, int len)
+{
+	if (!(len >= 1)) ierror(0);
+	if (!(0 <= where && where+len <= ssf_max)) ierror(0);
+	while (len--) {
+		ssf_frameusage[where+len] = 1;
+	}
+}
+
+int ssf_record_object(struct obj *obj)
+{
+	if (obj->flags & VAR) {
+		int sc = obj->v->storage_class;
+		if (sc != AUTO && sc != REGISTER)
+			return 0;  /* don't care about non-stack vars */
+		/* Mark this variable for updating later. */
+		obj->v->nesting = 1;
+		if (obj->flags & REG) {
+			if (obj->flags & VARADR) ierror(0);
+			return 0;  /* it's allocated to a register */
+		}
+		/* don't optimize function containing pointer arithmetic
+		 * on stack objects */
+		if (obj->flags & VARADR)
+			return 1;
+		/* don't optimize function containing VLA */
+		if (obj->v->vtyp->dsize != NULL)
+			return 1;
+		ssf_record_frameusage(obj->v->offset, szof(obj->v->vtyp));
+	}
+	return 0;
+}
+
+void ssf_update_object(struct obj *obj)
+{
+	if (obj->flags & VAR) {
+		int sc = obj->v->storage_class;
+		if (sc != AUTO && sc != REGISTER)
+			return;  /* don't care about non-stack vars */
+		if (obj->v->nesting) {
+			if (ssf_frameusage[obj->v->offset] == -1) {
+				obj->v->offset = NOT_ON_STACK;
+			} else {
+				obj->v->offset = ssf_frameusage[obj->v->offset];
+			}
+			obj->v->nesting = 0;
+		}
+	}
+}
+
+/* The middle-end likes to make tons of temporaries on the stack and then
+ * mostly optimize them away, leaving a "stackframe" of several thousand
+ * sparsely occupied bytes. This little hack counts the stack space that's
+ * actually being used, and squashes the remaining variables down into
+ * that smaller space. */
+int squash_stack_frame(struct IC *orig_ic, zmax stackframe)
+{
+	struct IC *ic;
+	int bytes_used;
+	int i;
+
+	ssf_max = stackframe;
+	ssf_frameusage = realloc(ssf_frameusage, ssf_max * sizeof *ssf_frameusage);
+	memset(ssf_frameusage, -1, ssf_max * sizeof *ssf_frameusage);
+
+	for (ic = orig_ic; ic != NULL; ic = ic->next) {
+		/* Record the bytes actually referenced by this IC's operands.
+		 * If optimization is inhibited, return the old stackframe. */
+		if (ssf_record_object(&ic->q1)) return stackframe;
+		if (ssf_record_object(&ic->q2)) return stackframe;
+		if (ssf_record_object(&ic->z)) return stackframe;
+	}
+
+	bytes_used = 0;
+	for (i=0; i < ssf_max; ++i) {
+		if (ssf_frameusage[i] != -1) {
+			ssf_frameusage[i] = bytes_used++;
+		}
+	}
+	
+	for (ic = orig_ic; ic != NULL; ic = ic->next) {
+		ssf_update_object(&ic->q1);
+		ssf_update_object(&ic->q2);
+		ssf_update_object(&ic->z);
+	}
+
+	return bytes_used;
+}
+
 /* The code generator itself.
  * This big, complicated, hairy and scary function does the work to actually
  * produce the code.  fp is the output stream, ic the beginning of the ic
@@ -1615,6 +1696,8 @@
 
     int c,t,lastcomp=0,reg;
 	    
+	stackframe = squash_stack_frame(ic, stackframe);
+    
     	function = func;
 
 	/* r0..r5 are always used for parameter passing. */
@@ -1638,7 +1721,7 @@
 	reflower(fp);
 
 	if (func->storage_class == STATIC)
-		fprintf(fp, "[ STATIC_%s_%ld xp\n", modulename, func->offset);
+		fprintf(fp, "[ STATIC_%s_%d xp\n", modulename, (int)func->offset);
 	else
 		fprintf(fp, "[ _%s xp\n", func->identifier);
 
@@ -1658,7 +1741,7 @@
 	if (g_flags[1] & USEDFLAG)
 	{
 		if (func->storage_class == STATIC)
-			fprintf(fp, "print \"STATIC_%s_%ld^\";\n", modulename, func->offset);
+			fprintf(fp, "print \"STATIC_%s_%d^\";\n", modulename, (int)func->offset);
 		else
 			fprintf(fp, "print \"_%s^\";\n", func->identifier);
 	}
@@ -1666,7 +1749,7 @@
 	/* Adjust stack for locals. */
 
 	if (stackframe)
-		fprintf(fp, "\t@sub xp 0%+ld -> xp;\n", stackframe);
+		fprintf(fp, "\t@sub xp (%d) -> xp;\n", (int)stackframe);
 	//if (stackoffset)
 	//	fprintf(fp, "\txp = xp - %ld\n", stackframe);
 
@@ -1862,17 +1945,29 @@
 				continue;
 
 			case KOMPLEMENT: /* Unary komplement */
-				/* INFORM BUG! */
-				/* The @not opcode doesn't work. We have to use a
-				 * wrapper function instead. */
-				
 				push_value(fp, &ic->q1, typf, &q1);
 				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@call_2s __not ");
-				emit_zop(fp, &q1);
-				fprintf(fp, " -> ");
-				emit_zop(fp, &z);
-				fprintf(fp, ";\n");
+				if (g_flags[6] & USEDFLAG) {
+					/* Prior to Inform 6.30, the assembler
+					 * had a major bug in the @not opcode;
+					 * it would generate bogus code and
+					 * crash some Z-machine interpreters. */
+					fprintf(fp, "\t@call_2s __not ");
+					emit_zop(fp, &q1);
+					fprintf(fp, " -> ");
+					emit_zop(fp, &z);
+					fprintf(fp, ";\n");
+				} else {
+					/* The bug was fixed in Inform 6.30.
+					 * The current distribution of Inform 6
+					 * is 6.31; the version distributed
+					 * with Inform 7 is 6.32. */
+					fprintf(fp, "\t@not ");
+					emit_zop(fp, &q1);
+					fprintf(fp, " -> ");
+					emit_zop(fp, &z);
+					fprintf(fp, ";\n");
+				}
 				fin_zop(fp, &ic->z, typf, &z);
 				continue;
 
@@ -1912,7 +2007,7 @@
 						emit_zop(fp, &q1);
 						fprintf(fp, " ");
 						emit_zop(fp, &z);
-						fprintf(fp, " 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " (%d);\n", (int)ic->q2.val.vlong);
 						break;
 
 					default:
@@ -1924,15 +2019,15 @@
 					 AUTO or STATIC */
 				i = voff(&ic->q1);
 				pop_value(fp, &ic->z, typf, &z);
-				fprintf(fp, "\t@add xp 0%+ld -> ", i);
+				fprintf(fp, "\t@add xp (%d) -> ", i);
 				emit_zop(fp, &z);
 				fprintf(fp, ";\n");
 				fin_zop(fp, &ic->z, typf, &z);
 				continue;
 
 			case PUSH: /* Push a value onto the stack */
-				fprintf(fp, "\t@sub xp 0%+ld -> xp;\n",
-					ic->q2.val.vlong);
+				fprintf(fp, "\t@sub xp (%d) -> xp;\n",
+					(int)ic->q2.val.vlong);
 				//stackoffset += ic->q2.val.vlong;
 				stackparamadjust += ic->q2.val.vlong;
 
@@ -1956,7 +2051,7 @@
 						push_addrof(fp, &ic->q1, typf, &q1);
 						fprintf(fp, "\t@copy_table ");
 						emit_zop(fp, &q1);
-						fprintf(fp, " xp 0%+ld;\n", ic->q2.val.vlong);
+						fprintf(fp, " xp (%d);\n", (int)ic->q2.val.vlong);
 						break;
 				}
 				continue;
@@ -2148,7 +2243,7 @@
 						fprintf(fp, "\t@log_shift ");
 						emit_zop(fp, &q1);
 						fprintf(fp, " 8 -> sp;\n");
-						fprintf(fp, "\t@art_shift sp 0-8 -> ");
+						fprintf(fp, "\t@art_shift sp (-8) -> ");
 						emit_zop(fp, &z);
 						fprintf(fp, ";\n");
 						fin_zop(fp, &ic->z, typf, &z);
@@ -2545,12 +2640,10 @@
 				/* If any parameters have been pushed, adjust
 				 * the stack to pop them. */
 
-				if (stackparamadjust)
-				{
-					fprintf(fp, "\t@add xp 0%+ld -> xp;\n",
-						stackparamadjust);
-					//stackoffset -= stackparamadjust;
-					stackparamadjust = 0;
+				int this_call_adjust = pushedargsize(ic);
+				if (this_call_adjust) {
+					fprintf(fp, "\t@add xp (%d) -> xp;\n", this_call_adjust);
+					stackparamadjust -= this_call_adjust;
 				}
 				continue;
 			}
@@ -2622,9 +2715,9 @@
 
 		while (constant)
 		{
-			fprintf(fp, "Array CONSTANT_%s_%ld -->\n",
+			fprintf(fp, "Array CONSTANT_%s_%d -->\n",
 				modulename, constant->id);
-			fprintf(fp, " 0%+ld 0%+ld;\n",
+			fprintf(fp, " (%d) (%d);\n",
 				xword(constant->value, 1),
 				xword(constant->value, 0));
 			constant = constant->next;
@@ -2639,12 +2732,12 @@
 		fprintf(fp, "[ __init_vars_%s;\n", modulename);
 		while (fixup)
 		{
-			fprintf(fp, "\t@add 0%+ld ", fixup->offset);
+			fprintf(fp, "\t@add (%d) ", (int)fixup->offset);
 
 			switch (fixup->value.type)
 			{
 				case STATIC:
-					fprintf(fp, "STATIC_%s_%ld -> sp;\n",
+					fprintf(fp, "STATIC_%s_%d -> sp;\n",
 						modulename, fixup->value.val.number);
 					break;
 
@@ -2660,15 +2753,15 @@
 			switch (fixup->identifier.type)
 			{
 				case STATIC:
-					fprintf(fp, "\t@storew STATIC_%s_%ld 0%+ld sp;\n",
+					fprintf(fp, "\t@storew STATIC_%s_%d (%d) sp;\n",
 						modulename, fixup->identifier.val.number,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				case EXTERN:
-					fprintf(fp, "\t@storew _%s 0%+ld sp;\n",
+					fprintf(fp, "\t@storew _%s (%d) sp;\n",
 						fixup->identifier.val.identifier,
-						fixup->identifier.offset);
+						fixup->identifier.offset >> 1);
 					break;
 
 				default:
diff -Naur vbcc/machines/z/machine.h /usr/glenda/advbcc/Advent-master/vbcc/machines/z/machine.h
--- vbcc/machines/z/machine.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/machines/z/machine.h	Tue Sep 22 04:19:14 2015
@@ -18,7 +18,7 @@
 
 /* Number of command-line options we accept. */
 
-#define MAXGF 6
+#define MAXGF 8
 
 /* If this is set to zero vbcc will not generate ICs where the target operand
  * is the same as the 2nd source operand. This can sometimes simplify the
diff -Naur vbcc/main.c /usr/glenda/advbcc/Advent-master/vbcc/main.c
--- vbcc/main.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/main.c	Tue Sep 22 04:22:36 2015
@@ -43,8 +43,7 @@
   struct Var *p;
   if(cross_module){
     for(p=first_ext;p;p=p->next)
-      if(!(p->flags&BUILTIN))
-	p->flags|=NOTINTU;
+      p->flags|=NOTINTU;
   }
   while(1){
     killsp();
@@ -96,20 +95,18 @@
 void dontwarn(char *p)
 /*  schaltet flags fuer Meldung auf DONTWARN    */
 {
+  int i;
   if(*p!='=') error(4,"-dontwarn");
-  do{
-    int i=atoi(p+1);
-    if(i>=err_num) error(159,i);
-    if(i<0){
-      for(i=0;i<err_num;i++)
-        if(!(err_out[i].flags&(ANSIV|FATAL)))
-    err_out[i].flags|=DONTWARN;
-      return;
-    }
-    if(err_out[i].flags&(ANSIV|FATAL)) error(160,i);
-    err_out[i].flags|=DONTWARN;
-    p=strchr(p+1,',');
-  } while(p);
+  i=atoi(p+1);
+  if(i>=err_num) error(159,i);
+  if(i<0){
+    for(i=0;i<err_num;i++)
+      if(!(err_out[i].flags&(ANSIV|FATAL)))
+	err_out[i].flags|=DONTWARN;
+    return;
+  }
+  if(err_out[i].flags&(ANSIV|FATAL)) error(160,i);
+  err_out[i].flags|=DONTWARN;
 }
 
 
@@ -578,8 +575,6 @@
   if(c_flags[45]&USEDFLAG) {ecpp=1;}
   if(c_flags[46]&USEDFLAG) {short_push=1;}
   if(c_flags[47]&USEDFLAG) {default_unsigned=1;}
-  if(c_flags[48]&USEDFLAG) {opencl=1;}
-
 
   if(wpo){
     cross_module=1;
@@ -614,9 +609,6 @@
   if(!init_cg()) exit(EXIT_FAILURE);
   if(zmeqto(stackalign,l2zm(0L)))
     stackalign=maxalign;
-  for(i=0;i<=MAX_TYPE;i++)
-    if(zmeqto(align[i],l2zm(0L)))
-      align[i]=l2zm(1L);
   for(i=0;i<EMIT_BUF_DEPTH;i++)
     emit_buffer[i]=mymalloc(EMIT_BUF_LEN);
   emit_p=emit_buffer[0];
@@ -905,6 +897,7 @@
     }
   }
   raus();
+  return;
 }
 int mcmp(const char *s1,const char *s2)
 /*  Einfachere strcmp-Variante.     */
@@ -1184,7 +1177,7 @@
   if(misracheck&&ctok->type!=PRAGMA&&ctok->type!=NONE&&ctok->type!=NEWLINE&&ctok->type!=COMMENT)
     misratok=1;
   /*FIXME: do not store multiple */
-  if(filename!=current_filename&&strcmp(filename,current_filename)){
+  if(filename!=current_filename){
     filename=mymalloc(strlen(current_filename)+1);
     strcpy(filename,current_filename);
   }
@@ -1777,8 +1770,6 @@
 {
   va_list vl;
   va_start(vl,errn);
-  if(errn==0)
-    printf("error=0\n");
   do_error(errn,vl);
   va_end(vl);
 }
diff -Naur vbcc/minicomp.c /usr/glenda/advbcc/Advent-master/vbcc/minicomp.c
--- vbcc/minicomp.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/minicomp.c	Thu Jan  1 00:00:00 1970
@@ -1,913 +0,0 @@
-#include "minicomp.h"
-
-#define clone_type clone_typ
-#define free_type freetyp
-#define new_icode new_IC
-#define add_icode add_IC
-#define free_all_icode() free_IC(first_ic)
-#define get_first_icode() first_ic
-typedef struct IC icode;
-
-static int errors;
-var *store_locals;
-
-struct rpair rp;
-
-char *copyright="minicomp/vbcc (c) in 2002 Volker Barthelmann";
-char *inname,*outname;
-struct struct_declaration *first_sd;
-struct Var *first_ext,*merk_varf;
-char **target_macros;
-
-FILE *out;
-
-void raus(void)
-{
-  var *v;
-  for(v=first_var[0];v;v=v->next)
-    if(v->type->flags!=FUNCTION){
-      gen_align(out,falign(v->type));
-      gen_var_head(out,v->vbccvar);
-      gen_ds(out,szof(v->type),v->type);
-    }
-
-  cleanup_cg(out);
-
-  if(errors>0)
-    exit(EXIT_FAILURE);
-  else
-    exit(EXIT_SUCCESS);
-}
-
-main(int argc,char **argv)
-{
-  int i,j,flag;
-  type *nt;
-
-  for(i=1;i<argc;i++){
-    if(*argv[i]!='-'){
-      if(inname)
-	error(18,"multiple input files");
-      inname=argv[i];
-    }else{
-      flag=0;
-      if((!strcmp("-o",argv[i]))&&i<argc-1){
-	flag=1;
-	outname=argv[++i];
-	continue;
-      }
-      if(!strncmp("-debug=",argv[i],7)){
-	flag=1;
-	sscanf(argv[i]+7,"%d",&j);
-	DEBUG=j;
-	continue;
-      }
-      if(!strncmp("-unroll-size=",argv[i],13)){
-	flag=1;
-	sscanf(argv[i]+13,"%d",&j);
-	unroll_size=j;
-	continue;
-      }
-      if(!strncmp("-inline-size=",argv[i],13)){
-	flag=1;
-	sscanf(argv[i]+13,"%d",&j);
-	inline_size=j;
-	continue;
-      }
-      if(!strncmp("-maxoptpasses=",argv[i],14)){
-	flag=1;
-	sscanf(argv[i]+14,"%d",&j);
-	maxoptpasses=j;
-	continue;
-      }
-      for(j=0;j<MAXGF&&flag==0;j++){
-        size_t l;
-        if(!g_flags_name[j]) continue;
-        l=strlen(g_flags_name[j]);
-        if(l>0&&!strncmp(argv[i]+1,g_flags_name[j],l)){
-          flag=1;
-          if((g_flags[j]&(USEDFLAG|FUNCFLAG))==USEDFLAG){error(19,"multiple option");break;}
-	  g_flags[j]|=USEDFLAG;
-          if(g_flags[j]&STRINGFLAG){
-            if(argv[i][l+1]!='='){error(21,"string expected");}
-            if(argv[i][l+2]||i>=argc-1)
-              g_flags_val[j].p=&argv[i][l+2];
-            else
-              g_flags_val[j].p=&argv[++i][0];
-          }
-          if(g_flags[j]&VALFLAG){
-            if(argv[i][l+1]!='='){error(20,"value expected");}
-            if(argv[i][l+2]||i>=argc-1)
-              g_flags_val[j].l=atol(&argv[i][l+2]);
-            else
-              g_flags_val[j].l=atol(&argv[++i][0]);
-          }
-          if(g_flags[j]&FUNCFLAG) g_flags_val[j].f(&argv[i][l+1]);
-	}
-      }
-      if(!flag) error(23,"unknown option");
-    }
-  }
-
-  if(!inname)
-    error(22,"no input file");
-  infile=fopen(inname,"r");
-  if(!infile)
-    error(18,"could not open output file");
-  if(!outname)
-    error(23,"no output file");
-  out=fopen(outname,"w");
-  if(!out){
-    error(24,"could not open input file");
-  }
-  nt=new_type(FUNCTION);
-  nt->next=new_type(INT);
-  add_var("readInt",clone_type(nt));
-  add_var("writeInt",clone_type(nt));
-  add_var("writeChar",clone_type(nt));
-  add_var("readChar",clone_type(nt));
-  add_var("writeReal",nt);
-  nt=new_type(FUNCTION);
-  nt->next=new_type(REAL);
-  add_var("readReal",nt);
-
-  stackalign=l2zm(0L);
-  if(!init_cg()) exit(EXIT_FAILURE);
-  if(zmeqto(stackalign,l2zm(0L)))
-    stackalign=maxalign; 
-  for(i=0;i<EMIT_BUF_DEPTH;i++)
-    emit_buffer[i]=mymalloc(EMIT_BUF_LEN);
-  emit_p=emit_buffer[0];
-
-  multiple_ccs=0;
-  optflags=-1;
-  maxoptpasses=100;
-
-  yyparse();
-
-  raus();
-}
-
-yyerror(char *s)
-{
-  error(1,s);
-}
-
-void error(int n,...)
-{
-  if(n==170||n==172) return;
-  errors++;
-  fprintf(stderr,"error %d\n",n);
-  raus();
-}
-
-void *getmem(size_t s)
-{
-  void *p=malloc(s);
-  if(!p){
-    error(2,"out of memory");
-  }
-  return p;
-}
-
-#define LABELNESTING 1024
-static int labelstack[LABELNESTING],labelidx;
-
-void push_int(int l)
-{
-  labelstack[labelidx++]=l;
-}
-
-int pop_int()
-{
-  return labelstack[--labelidx];
-}
-
-#define NAMENESTING 1024
-static char *namestack[NAMENESTING],nameidx;
-
-void push_ptr(void *ptr)
-{
-  namestack[nameidx++]=ptr;
-}
-
-void *pop_ptr()
-{
-  return namestack[--nameidx];
-}
-
-
-char *typename[]={"    ","int","real","array","function"};
-
-
-type *new_type(int t)
-{
-  type *new=new_typ();
-  new->flags=t;
-  new->next=0;
-  return new;
-}
-
-type *new_array(type *t,node *p)
-{
-  type *new=new_typ();
-  simplify_tree(p);
-  if(p->flags!=NNUMBER)
-    error(3,"array size not a constant");
-  if(p->type->flags!=INT)
-    error(4,"array size not an integer");
-  new->flags=ARRAY;
-  new->next=t;
-  new->size=l2zm((long)p->ivalue);
-  free_tree(p);
-  return new;
-}
-
-int nesting;
-int local_offset,parm_offset,framesize;
-
-#define MAXNESTING 128
-var *first_var[128];
-
-void free_varlist(var *v)
-{
-  var *m;
-  while(v){
-    free_var(v->vbccvar);
-    m=v->next;
-    free(v);
-    v=m;
-  }
-}
-
-void enter_block()
-{
-  nesting++;
-  first_var[nesting]=0;
-  push_int(local_offset);
-}
-
-void leave_block()
-{
-  if(first_var[nesting]){
-    var *p=first_var[nesting];
-    while(p->next)
-      p=p->next;
-    p->next=store_locals;
-    p->vbccvar->next=merk_varf;
-    store_locals=first_var[nesting];
-    merk_varf=store_locals->vbccvar;
-  }
-  nesting--;
-  local_offset=pop_int();
-}
-
-void gen_func(var *v,icode *first,int framesize)
-{
-  pric(stdout,get_first_icode());
-  vl1=first_var[0]?first_var[0]->vbccvar:0;
-  vl2=first_var[1]?first_var[1]->vbccvar:0;
-  vl3=merk_varf;
-  optimize(optflags,v->vbccvar);
-  memset(regs_modified,0,RSIZE);
-  pric(stdout,get_first_icode());
-  gen_code(out,get_first_icode(),v->vbccvar,max_offset);
-}
-
-void enter_func(char *name,type *p)
-{
-  type *t=new_type(FUNCTION);
-  var *v;
-  t->next=p;
-  t->exact=getmem(sizeof(*t->exact));
-  t->exact->count=0;
-  v=add_var(name,t);
-  local_offset=parm_offset=framesize=0;
-  push_ptr(v);
-  enter_block();
-}
-
-void leave_func()
-{
-  icode *p,*merk;
-  leave_block();
-  gen_func(pop_ptr(),get_first_icode(),framesize);
-  free_all_icode();
-  first_ic=last_ic=0;
-  free_varlist(store_locals);
-  merk_varf=0;
-  store_locals=0;
-}
-
-var *find_var(char *p,int minnest)
-{
-  var *v;
-  int i;
-
-  for(i=nesting;i>=minnest;i--){
-    for(v=first_var[i];v;v=v->next)
-      if(!strcmp(v->name,p))
-	return v;
-  }
-  return 0;
-}
-
-var *add_var(char *name,type *t)
-{
-  var *new=getmem(sizeof(*new));
-  struct Var *vv;
-  /*FIXME: add vbccvar */  
-  if(find_var(name,nesting))
-    error(5,"var %s already defined",name);
-  new->nesting=nesting;
-  new->name=add_string(name);
-  new->type=t;
-  if(*name==0){
-    new->next=store_locals;
-  }else{
-    new->next=first_var[nesting];
-  }
-  if(nesting==1){
-    /* parameter */
-    new->offset=parm_offset;
-    parm_offset+=szof(t);
-  }
-  if(nesting>1){
-    /* local variable */
-    new->offset=local_offset;
-    local_offset+=szof(t);
-    if(local_offset>framesize)
-      framesize=local_offset;
-  }    
-  /* attach vbcc variable */
-  vv=new_var();
-  vv->vtyp=clone_typ(new->type);
-  vv->identifier=add_string(name);
-  vv->nesting=(*name!=0?nesting:2);
-  vv->storage_class=(vv->nesting==0?EXTERN:AUTO);
-  if(nesting==1)
-    vv->offset=zmsub(l2zm(0L),zmadd(maxalign,l2zm(new->offset)));
-  else
-    vv->offset=l2zm((long)local_offset);
-  new->vbccvar=vv;
-
-  if(*name==0){
-    store_locals=new;
-    vv->next=merk_varf;
-    merk_varf=vv;
-  }else{
-    vv->next=first_var[nesting]?first_var[nesting]->vbccvar:0;
-    first_var[nesting]=new;
-  }
-  return new;
-}
-
-var *new_temp(int tflags)
-{
-  char tname[16];
-  static int itmps,rtmps,ptmps;
-  if(tflags==INT)
-    sprintf(tname,"\0 itmp%d",++itmps);
-  else if(tflags==REAL)
-    sprintf(tname,"\0 rtmp%d",++rtmps);
-  else if(tflags==POINTER)
-    sprintf(tname,"\0 rtmp%d",++ptmps);
-  else
-    error(16,"internal");
-  return add_var(tname,new_type(tflags));
-}
-
-struct Var *add_tmp_var(struct Typ *t)
-{
-  
-  return new_temp(t->flags)->vbccvar;
-}
-
-char *add_string(char *s)
-{
-  char *new=getmem(strlen(s)+1);
-  strcpy(new,s);
-  return new;
-}
-
-char *nodename[]={
-  "var","number","add","mul","sub","div","index","equals",
-  "lt","gt","leq","geq","neq","and","or",
-  "int2real","real2int","assign","call","argument"
-};
-
-node *number_node(void)
-{
-  node *new=getmem(sizeof(*new));
-  new->flags=NNUMBER;
-  if(strstr(tkname,".")){
-    double rval;
-    sscanf(tkname,"%lf",&rval);
-    new->rvalue=rval;
-    new->type=new_type(REAL);
-    new->left=new->right=0;
-  }else{
-    new->ivalue=atoi(tkname);
-    new->type=new_type(INT);
-    new->left=new->right=0;
-  }
-  return new;
-}
-
-node *var_node(void)
-{
-  var *v=find_var(tkname,0);
-  node *new;
-  if(!v){
-    error(6,"unknown identifier: %s",tkname);
-  }
-  new=getmem(sizeof(*new));
-  new->flags=NVARIABLE;
-  new->var=v;
-  new->type=clone_type(v->type);
-  new->left=new->right=0;
-  return new;
-}
-
-
-node *binary_node(enum nodeflags flags,node *left,node *right)
-{
-  node *new=getmem(sizeof(*new));
-  new->flags=flags;
-  new->left=left;
-  new->right=right;
-  new->type=0;
-  if(!left||(flags!=NCALL&&!right))
-    error(7,"internal error");
-  if(flags==NINDEX){
-    if(left->type->flags!=ARRAY)
-      error(8,"operand of [] must be array");
-    new->type=clone_type(left->type->next);
-  }else if(flags==NARG){
-    /* nothing to do? */
-  }else if(flags==NCALL){
-    if(left->type->flags!=FUNCTION)
-      error(9,"only functions can be called");
-    new->type=clone_type(left->type->next);
-  }else{
-    if(left->type->flags==ARRAY||right->type->flags==ARRAY)
-      error(10,"both operands must be real or int");
-    if(left->type->flags==REAL||right->type->flags==REAL){
-      new->type=new_type(REAL);
-      if(left->type->flags==INT){
-	new->left=conv_tree(left,REAL);
-      }
-      if(right->type->flags==INT){
-	new->right=conv_tree(right,REAL);
-      }      
-    }else
-      new->type=new_type(INT);
-  }
-  return new;
-}
-
-void print_tree(node *p)
-{
-  printf("%s(",nodename[p->flags]);
-  if(p->left)
-    print_tree(p->left);
-  if(p->right){
-    printf(",");
-    print_tree(p->right);
-  }
-  if(p->flags==NNUMBER){
-    if(p->type->flags==INT)
-      printf("%d[int]",p->ivalue);
-    else
-      printf("%g[real]",p->rvalue);
-  }
-  if(p->flags==NVARIABLE)
-    printf("%s[%s]",p->var->name,typename[p->var->type->flags]);
-  printf(")");
-}
-
-node *conv_tree(node *p,int tflags)
-{
-  node *new;
-  if(p->type->flags==tflags)
-    return p;
-  new=getmem(sizeof(*new));
-  if(tflags==REAL)
-    new->flags=NI2R;
-  else
-    new->flags=NR2I;
-  new->type=new_type(p->type->flags);
-  new->left=p;
-  new->right=0;
-  return new;
-}
-
-void free_tree(node *p)
-{
-  if(p->left)
-    free_tree(p->left);
-  if(p->right)
-    free_tree(p->right);
-  if(p->type)
-    free_type(p->type);
-  free(p);
-}
-
-
-static void const_node(node *p,int val)
-{
-  p->flags=NNUMBER;
-  p->ivalue=val;
-  if(p->left)
-    free_tree(p->left);
-  if(p->right)
-    free_tree(p->right);
-  p->left=p->right=0;
-}
-
-void simplify_tree(node *p)
-{
-  if(p->left)
-    simplify_tree(p->left);
-  if(p->right)
-    simplify_tree(p->right);
-  if(p->type&&p->type->flags==INT&&p->left&&p->left->flags==NNUMBER&&p->right&&p->right->flags==NNUMBER){
-    switch(p->flags){
-    case NADD: const_node(p,p->left->ivalue+p->right->ivalue); break;
-    case NMUL: const_node(p,p->left->ivalue*p->right->ivalue); break;
-    case NSUB: const_node(p,p->left->ivalue-p->right->ivalue); break;
-    case NDIV: 
-      if(p->right->ivalue!=0)
-	const_node(p,p->left->ivalue/p->right->ivalue); break;
-    }
-  }
-}
-
-void assign_statement(node *left,node *right)
-{
-  if(left->type->flags==ARRAY||right->type->flags==ARRAY)
-    error(11,"array type in assignment");
-  if(left->type->flags==FUNCTION||right->type->flags==FUNCTION)
-    error(12,"function type in assignment");
-
-  right=conv_tree(right,left->type->flags);
-  simplify_tree(left);
-  simplify_tree(right);
-  if(left->flags==NINDEX){
-    icode *n1,*n2,*n3;
-    n1=new_icode();
-    n1->code=MULT;
-    n1->typf=INT;
-    n1->q1=*gen_tree(left->right);
-    n1->q2.flags=KONST;
-    n1->q2.val.vint=zm2zi(sizetab[INT]);
-    n1->z.flags=VAR;
-    n1->z.v=new_temp(INT)->vbccvar;
-    n1->z.val.vmax=l2zm(0L);
-    n2=new_icode();
-    n2->code=ADDI2P;
-    n2->typf=INT;
-    n2->typf2=POINTER;
-    n2->q1=*gen_tree(left->left);
-    n2->q2=n1->z;
-    n2->z.flags=VAR;
-    n2->z.v=new_temp(POINTER)->vbccvar;
-    n2->z.val.vmax=l2zm(0L);
-    n3=new_icode();
-    n3->code=ASSIGN;
-    n3->typf=left->type->flags;
-    n3->q1=*gen_tree(right);
-    n3->z=n2->z;
-    n3->z.flags|=DREFOBJ;
-    n3->z.dtyp=POINTER;
-    n3->q2.val.vmax=szof(left->type);
-    add_icode(n1);
-    add_icode(n2);
-    add_icode(n3);
-#if 0    
-    /* leicht anderes Format */
-    new->flags=CSTORE;
-    new->op1=*gen_tree(right);
-    new->op2=*gen_tree(left->left);
-    new->dest=*gen_tree(left->right);
-#endif
-  }else{
-    icode *new=new_icode();
-    new->code=ASSIGN;
-    new->q1=*gen_tree(right);
-    new->z=*gen_tree(left);
-    new->q2.val.vmax=szof(left->type);
-    new->typf=left->type->flags;
-    add_icode(new);
-  }
-  free_tree(left);
-  free_tree(right);
-}
-
-void return_statement(node *p)
-{
-  icode *new=new_icode();
-  p=conv_tree(p,INT); /*FIXME*/
-  simplify_tree(p);
-  new->code=SETRETURN;
-  new->typf=p->type->flags;
-  new->q1=*gen_tree(p);
-  new->z.reg=freturn(p->type);
-  add_icode(new);
-  free_tree(p);
-}
-
-void while_statement(node *p)
-{
-  int loop=++label,exit=++label;
-  simplify_tree(p);
-  gen_cond(p,loop,exit);
-  gen_label(loop);
-  last_ic->flags|=LOOP_COND_TRUE;
-  push_ptr(p);
-  push_int(loop);
-  push_int(exit);
-#if 0
-  gen_label(loop);
-  gen_cond(p,start,exit);
-  free_tree(p);
-  gen_label(start);
-  push_int(loop);
-  push_int(exit);
-#endif
-}
-
-void while_end()
-{
-  int loop,exit;
-  node *p;
-  exit=pop_int();
-  loop=pop_int();
-  p=pop_ptr();
-  gen_cond(p,loop,exit);
-  gen_label(exit);
-#if 0
-  new=new_icode();
-  new->code=BRA;
-  new->typf=loop;
-  add_icode(new);
-  gen_label(exit);
-#endif
-}
-
-void if_statement(node *p)
-{
-  int true=++label,false=++label;
-  simplify_tree(p);
-  gen_cond(p,true,false);
-  free_tree(p);
-  gen_label(true);
-  push_int(false);
-}
-
-void if_end()
-{
-  gen_label(pop_int());
-}
-
-void if_else()
-{
-  int endlabel=++label;
-  icode *new=new_icode();
-  new->code=BRA;
-  new->typf=++label;
-  add_icode(new);
-  gen_label(pop_int());
-  push_int(label);
-}
-
-int label;
-
-operand *gen_tree(node *p)
-{
-  icode *new;
-  static operand op;
-
-  if(p->flags==NVARIABLE){
-    if(p->var->type->flags==ARRAY){
-      if(p->var->nesting==0){
-	op.flags=VAR|VARADR;
-	op.v=p->var->vbccvar;
-	op.val.vmax=l2zm(0L);
-	return &op;
-      }else{
-	icode *new=new_icode();
-	new->flags=ADDRESS;
-	new->q1.flags=VAR;
-	new->q1.v=p->var->vbccvar;
-	new->q1.val.vmax=l2zm(0L);
-	new->z.flags=VAR;
-	new->z.v=new_temp(POINTER)->vbccvar;
-	new->z.val.vmax=l2zm(0L);
-	add_icode(new);
-	return &new->z;
-      }
-    }else{
-      op.flags=VAR;
-      op.v=p->var->vbccvar;
-      op.val.vmax=l2zm(0L);
-      return &op;
-    }
-  }
-
-  if(p->flags==NNUMBER){
-    op.flags=KONST;
-    if(p->type->flags==INT)
-      op.val.vint=p->ivalue;
-    else
-      op.val.vdouble=zld2zd(d2zld(p->rvalue));
-    return &op;
-  }
-
-  if(p->flags==NADD||p->flags==NMUL||p->flags==NSUB||p->flags==NDIV||p->flags==NI2R||p->flags==NR2I){
-    int ttyp=p->type->flags;
-    new=new_icode();
-    switch(p->flags){
-    case NADD: new->code=ADD;break;
-    case NMUL: new->code=MULT;break;
-    case NSUB: new->code=SUB;break;
-    case NDIV: new->code=DIV;break;
-    case NI2R: new->code=CONVERT;ttyp=REAL;new->typf2=INT;break;
-    case NR2I: new->code=CONVERT;ttyp=INT;new->typf2=REAL;break;
-    }
-    new->q1=*gen_tree(p->left);
-    if(p->right)
-      new->q2=*gen_tree(p->right);
-    new->z.flags=VAR;
-    new->z.v=new_temp(ttyp)->vbccvar;
-    new->z.val.vmax=l2zm(0L);
-    new->typf=ttyp;
-    add_icode(new);
-    return &new->z;
-  }
-
-  if(p->flags==NINDEX){
-    if(p->type->flags==ARRAY){
-      icode *merk,*new=new_icode();
-      new->flags=MULT;
-      new->typf=INT;
-      new->q1=*gen_tree(p->right);
-      new->q2.flags=KONST;
-      new->q2.val.vint=szof(p->type);
-      new->z.flags=VAR;
-      new->z.v=new_temp(INT)->vbccvar;
-      new->z.val.vmax=l2zm(0L);
-      add_icode(new);
-      merk=new;
-      new=new_icode();
-      new->flags=ADDI2P;
-      new->typf=INT;
-      new->typf2=POINTER;
-      new->q1=*gen_tree(p->left);
-      new->q2=merk->z;
-      new->z.flags=VAR;
-      new->z.v=new_temp(POINTER)->vbccvar;
-      new->z.val.vmax=l2zm(0L);
-      op=new->z;
-      add_icode(new);
-      return &new->z;
-    }else{
-      icode *merk,*new=new_icode();
-      new->code=MULT;
-      new->typf=INT;
-      new->q1=*gen_tree(p->right);
-      new->q2.flags=KONST;
-      new->q2.val.vint=zm2zi(sizetab[INT]);
-      new->z.flags=VAR;
-      new->z.v=new_temp(INT)->vbccvar;
-      new->z.val.vmax=l2zm(0L);
-      add_icode(new);
-      merk=new;
-      new=new_icode();
-      new->code=ADDI2P;
-      new->q1=*gen_tree(p->left);
-      new->q2=merk->z;
-      new->typf=INT;
-      new->typf2=POINTER;
-      new->z.flags=VAR;
-      new->z.v=new_temp(POINTER)->vbccvar;
-      new->z.val.vmax=l2zm(0L);
-      op=new->z;
-      op.flags|=DREFOBJ;
-      op.dtyp=POINTER;
-      add_icode(new);
-      return &op;
-    }
-  }
-
-  if(p->flags==NCALL){
-    icode *new=new_icode();
-    new->code=CALL;
-    new->typf=FUNKT;
-    if(p->right)
-      new->q2.val.vmax=l2zm(push_arg(p->right));
-    else
-      new->q2.val.vmax=l2zm(0L);
-    new->q1=*gen_tree(p->left);
-    add_icode(new);
-    new=new_icode();
-    new->code=GETRETURN;
-    new->z.flags=VAR;
-    new->typf=p->type->flags;
-    new->z.v=new_temp(p->type->flags)->vbccvar;
-    new->z.val.vmax=l2zm(0L);
-    new->q1.reg=freturn(p->type);
-    add_icode(new);
-    return &new->z;
-  }
-
-  error(13,"operation not yet supported");
-}
-
-void gen_label(int l)
-{
-  icode *new=new_icode();
-  new->code=LABEL;
-  new->typf=l;
-  add_icode(new);
-}
-
-void gen_cond(node *p,int true_label,int false_label)
-{
-  icode *new;
-  if(p->flags==NAND){
-    int tmp=++label;
-    gen_cond(p->left,tmp,false_label);
-    gen_label(tmp);
-    gen_cond(p->right,true_label,false_label);
-    return;
-  }
-  if(p->flags==NOR){
-    int tmp=++label;
-    gen_cond(p->left,true_label,tmp);
-    gen_label(tmp);
-    gen_cond(p->right,true_label,false_label);
-    return;
-  }
-  new=new_icode();
-  new->code=COMPARE;
-  new->typf=p->type->flags;
-  new->q1=*gen_tree(p->left);
-  new->q2=*gen_tree(p->right);
-  add_icode(new);
-  new=new_icode();
-  switch(p->flags){
-  case NEQUALS: new->code=BEQ;break;
-  case NNEQ: new->code=BNE;break;
-  case NLT: new->code=BLT;break;
-  case NGT: new->code=BGT;break;
-  case NLEQ: new->code=BLE;break;
-  case NGEQ: new->code=BGE;break;
-  default: error(14,"internal");
-  }
-  new->typf=true_label;
-  add_icode(new);
-
-  new=new_icode();
-  new->code=BRA;
-  new->typf=false_label;
-  add_icode(new);
-}
-
-int push_arg(node *p)
-{
-  if(p->flags==NARG){
-    int s;
-    s=push_arg(p->right);
-    return s+push_arg(p->left);
-  }else{
-    icode *new=new_icode();
-    if(p->type->flags==ARRAY)
-      error(15,"arrays cannot be passed");
-    new->code=PUSH;
-    new->q2.val.vmax=szof(p->type);
-    new->z.val.vmax=new->q2.val.vmax;
-    new->typf=p->type->flags;
-    new->q1=*gen_tree(p);
-    add_icode(new);
-    return szof(p->type);
-  }
-}
-
-void free_var(struct Var *v)
-{
-  free(v);
-  /*FIXME*/
-}
-
-void add_IC(icode *new)
-{
-  if(last_ic&&new->code==ASSIGN&&new->q1.flags==VAR&&last_ic->z.flags==VAR&&
-     new->q1.v==last_ic->z.v&&zmeqto(new->q1.val.vmax,last_ic->z.val.vmax)&&
-     *new->q1.v->identifier==0){
-    last_ic->z=new->z;
-    free(new);
-    return;
-  }
-  insert_IC(last_ic,new);
-}
diff -Naur vbcc/minicomp.h /usr/glenda/advbcc/Advent-master/vbcc/minicomp.h
--- vbcc/minicomp.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/minicomp.h	Thu Jan  1 00:00:00 1970
@@ -1,93 +0,0 @@
-#include <stdio.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-
-#include "supp.h"
-
-extern FILE *infile;
-#define MAXLEN 1024
-extern char tkname[MAXLEN];
-extern int label;
-extern int nesting;
-extern int local_offset,parm_offset,framesize;
-
-#define REAL DOUBLE
-#define FUNCTION FUNKT
-
-#define YYERROR_VERBOSE 1
-
-enum nodeflags {
-  NVARIABLE,NNUMBER,NADD,NMUL,NSUB,NDIV,NINDEX,
-  NEQUALS,NLT,NGT,NLEQ,NGEQ,NNEQ,NAND,NOR,
-  NI2R,NR2I,NASSGN,NCALL,NARG
-};
-
-extern char *nodename[];
-
-typedef struct Typ type;
-
-typedef struct obj operand;
-
-typedef struct var {
-  int nesting;
-  char *name;
-  struct Typ *type;
-  struct var *next;
-  int offset;
-  struct Var *vbccvar;
-} var;
-
-#define MAXNESTING 128
-extern var *first_var[128];
-
-typedef struct {
-  int flags;
-  char *name;
-} *stype;
-
-typedef struct mnode {
-  enum nodeflags flags;
-  struct mnode *left,*right;
-  type *type;
-  var *var;
-  int ivalue;
-  double rvalue;
-} node;
-
-void enter_block(void);
-void leave_block(void);
-void enter_func(char *,type *);
-void leave_func(void);
-var *find_var(char *,int);
-var *add_var(char *,type *);
-var *new_temp(int);
-char *add_string(char *);
-void error(int,...);
-void *getmem(size_t);
-node *number_node(void);
-node *var_node(void);
-node *conv_tree(node *,int);
-node *binary_node(enum nodeflags,node *,node *);
-void print_tree(node *);
-void simplify_tree(node *);
-void free_tree(node *);
-type *new_type(int);
-type *new_array(type *,node *);
-void return_statement(node *);
-void while_statement(node *);
-void while_end(void);
-void if_statement(node *);
-void if_end(void);
-void if_else(void);
-void assign_statement(node *,node *);
-void push_int(int);
-int pop_int(void);
-void push_name(char *);
-char *pop_name(void);
-operand *gen_tree(node *);
-void gen_cond(node *,int,int);
-void gen_label(int);
-int push_arg(node *);
-void gen_global(char *,int);
diff -Naur vbcc/minicomp.tab.c /usr/glenda/advbcc/Advent-master/vbcc/minicomp.tab.c
--- vbcc/minicomp.tab.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/minicomp.tab.c	Thu Jan  1 00:00:00 1970
@@ -1,1189 +0,0 @@
-
-/*  A Bison parser, made from minicomp.y
- by  GNU Bison version 1.27
-  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define	TKNUMBER	257
-#define	TKIDENTIFIER	258
-#define	TKREAL	259
-#define	TKINT	260
-#define	TKLEQ	261
-#define	TKGEQ	262
-#define	TKNEQ	263
-#define	TKIF	264
-#define	TKELSE	265
-#define	TKWHILE	266
-#define	TKRETURN	267
-#define	TKASSIGN	268
-#define	TKAND	269
-#define	TKOR	270
-
-#line 18 "minicomp.y"
-
-#include "minicomp.h"
-
-typedef void *voidptr;
-#define YYSTYPE voidptr
-#ifndef YYSTYPE
-#define YYSTYPE int
-#endif
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		123
-#define	YYFLAG		-32768
-#define	YYNTBASE	32
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 270 ? yytranslate[x] : 64)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,    23,
-    24,    27,    25,    29,    26,     2,    28,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,    19,    21,
-    20,    22,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-    17,     2,    18,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,    30,     2,    31,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     3,     5,     7,     9,    11,    13,    18,    21,    23,
-    27,    29,    33,    37,    39,    43,    47,    51,    55,    59,
-    63,    67,    71,    75,    77,    81,    85,    87,    91,    93,
-    98,   102,   104,   109,   111,   113,   117,   119,   122,   124,
-   126,   128,   130,   132,   134,   135,   139,   143,   146,   149,
-   151,   152,   160,   161,   162,   166,   167,   174,   179,   183,
-   186,   190,   194,   197,   201,   203
-};
-
-static const short yyrhs[] = {    32,
-    33,     0,    33,     0,    59,     0,    36,     0,     5,     0,
-     6,     0,    34,    17,    40,    18,     0,    35,    36,     0,
-    36,     0,    34,    37,    19,     0,     4,     0,    38,    15,
-    39,     0,    38,    16,    39,     0,    39,     0,    40,    20,
-    40,     0,    40,     9,    40,     0,    40,    21,    40,     0,
-    40,    22,    40,     0,    40,     7,    40,     0,    40,     8,
-    40,     0,    23,    38,    24,     0,    40,    25,    41,     0,
-    40,    26,    41,     0,    41,     0,    41,    27,    42,     0,
-    41,    28,    42,     0,    42,     0,    23,    40,    24,     0,
-     3,     0,    44,    23,    45,    24,     0,    44,    23,    24,
-     0,    43,     0,    42,    17,    40,    18,     0,    44,     0,
-     4,     0,    45,    29,    40,     0,    40,     0,    46,    47,
-     0,    47,     0,    51,     0,    55,     0,    57,     0,    58,
-     0,    48,     0,     0,    30,    49,    50,     0,    35,    46,
-    31,     0,    46,    31,     0,    35,    31,     0,    31,     0,
-     0,    10,    23,    38,    24,    52,    48,    53,     0,     0,
-     0,    11,    54,    48,     0,     0,    12,    23,    38,    24,
-    56,    48,     0,    43,    14,    40,    19,     0,    13,    40,
-    19,     0,    60,    61,     0,    34,    37,    23,     0,    62,
-    24,    48,     0,    24,    48,     0,    62,    29,    63,     0,
-    63,     0,    34,    37,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    27,    29,    32,    34,    37,    39,    40,    43,    45,    48,
-    52,    56,    58,    59,    62,    64,    65,    66,    67,    68,
-    69,    72,    73,    74,    77,    78,    79,    82,    84,    85,
-    86,    87,    90,    92,    95,    99,   101,   104,   106,   109,
-   111,   112,   113,   114,   117,   119,   121,   123,   124,   125,
-   129,   130,   133,   135,   135,   139,   140,   143,   147,   151,
-   155,   159,   161,   164,   166,   169
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","TKNUMBER",
-"TKIDENTIFIER","TKREAL","TKINT","TKLEQ","TKGEQ","TKNEQ","TKIF","TKELSE","TKWHILE",
-"TKRETURN","TKASSIGN","TKAND","TKOR","'['","']'","';'","'='","'<'","'>'","'('",
-"')'","'+'","'-'","'*'","'/'","','","'{'","'}'","glob_decl_list","glob_decl",
-"type","decl_list","decl","decl_id","cond_expr","ao_expr","arith_expr","term",
-"factor","lvalue","variable","arg_list","stmt_list","stmt","block","@1","block_end",
-"if_stmt","@2","else_part","@3","while_stmt","@4","assgn_stmt","return_stmt",
-"func_decl","func_decl_begin","func_decl_end","par_list","par_decl", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    32,    32,    33,    33,    34,    34,    34,    35,    35,    36,
-    37,    38,    38,    38,    39,    39,    39,    39,    39,    39,
-    39,    40,    40,    40,    41,    41,    41,    42,    42,    42,
-    42,    42,    43,    43,    44,    45,    45,    46,    46,    47,
-    47,    47,    47,    47,    49,    48,    50,    50,    50,    50,
-    52,    51,    53,    54,    53,    56,    55,    57,    58,    59,
-    60,    61,    61,    62,    62,    63
-};
-
-static const short yyr2[] = {     0,
-     2,     1,     1,     1,     1,     1,     4,     2,     1,     3,
-     1,     3,     3,     1,     3,     3,     3,     3,     3,     3,
-     3,     3,     3,     1,     3,     3,     1,     3,     1,     4,
-     3,     1,     4,     1,     1,     3,     1,     2,     1,     1,
-     1,     1,     1,     1,     0,     3,     3,     2,     2,     1,
-     0,     7,     0,     0,     3,     0,     6,     4,     3,     2,
-     3,     3,     2,     3,     1,     2
-};
-
-static const short yydefact[] = {     0,
-     5,     6,     0,     2,     0,     4,     3,     0,     1,    11,
-     0,     0,     0,     0,    60,     0,    65,    29,    35,     0,
-     0,    24,    27,    32,    34,    10,    61,    45,    63,    66,
-     0,     0,     0,     7,     0,     0,     0,     0,     0,     0,
-     0,    62,    64,    28,    22,    23,    25,    26,     0,    31,
-    37,     0,     0,     0,     0,    50,     0,     0,     9,     0,
-    32,     0,    39,    44,    46,    40,    41,    42,    43,    33,
-    30,     0,     0,     0,     0,     0,    49,     8,     0,     0,
-    48,    38,    36,     0,     0,    14,     0,     0,    59,    47,
-     0,     0,     0,     0,     0,    51,     0,     0,     0,     0,
-     0,     0,    56,    58,    21,    12,    13,     0,    19,    20,
-    16,    15,    17,    18,     0,    53,    57,    54,    52,     0,
-    55,     0,     0
-};
-
-static const short yydefgoto[] = {     3,
-     4,     5,    58,     6,    12,    85,    86,    87,    22,    23,
-    24,    25,    52,    62,    63,    64,    41,    65,    66,   108,
-   119,   120,    67,   115,    68,    69,     7,     8,    15,    16,
-    17
-};
-
-static const short yypact[] = {    33,
--32768,-32768,   148,-32768,    27,-32768,-32768,     0,-32768,-32768,
-    50,    75,   -21,    27,-32768,   128,-32768,-32768,-32768,    50,
-    25,   102,    -5,-32768,    32,-32768,-32768,-32768,-32768,-32768,
-   -21,    33,   137,-32768,    50,    50,    50,    50,    50,    44,
-    10,-32768,-32768,-32768,   102,   102,    -5,    -5,    46,-32768,
-   133,   131,    78,    81,    50,-32768,    27,    53,-32768,    -5,
-    55,    93,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,    50,    57,    57,    56,    60,-32768,-32768,   105,    50,
--32768,-32768,   133,    57,    62,-32768,   125,    95,-32768,-32768,
-    74,    97,   118,    57,    57,-32768,    50,    50,    50,    50,
-    50,    50,-32768,-32768,-32768,-32768,-32768,   -21,   133,   133,
-   133,   133,   133,   133,   -21,   103,-32768,-32768,-32768,   -21,
--32768,    85,-32768
-};
-
-static const short yypgoto[] = {-32768,
-   117,    -6,-32768,   -24,   -11,   -47,    70,   -10,   132,   -30,
-   -37,-32768,-32768,    64,   -43,   -13,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-    99
-};
-
-
-#define	YYLAST		168
-
-
-static const short yytable[] = {    29,
-    21,    14,    30,    61,     1,     2,    47,    48,    28,    33,
-    60,    39,    18,    19,     1,     2,    59,    42,    82,    53,
-    61,    54,    55,    13,    61,    14,    88,    60,    49,    51,
-    10,    60,    20,    78,    57,    82,    92,     1,     2,    28,
-    56,    61,    34,    11,    75,    76,    18,    19,    60,    35,
-    36,    57,    18,    19,    40,    18,    19,     1,     2,    18,
-    19,    83,    53,    70,    54,    55,    20,    50,    80,    91,
-    35,    36,    20,    93,    89,    20,    94,    95,    26,    84,
-    35,    36,    28,    77,   123,    96,   109,   110,   111,   112,
-   113,   114,   104,    26,   116,    18,    19,    27,    35,    36,
-    73,   117,    53,    74,    54,    55,   121,    18,    19,    94,
-    95,    94,    95,   118,    53,    20,    54,    55,   103,     9,
-   105,    79,    28,    81,    97,    98,    99,    20,    37,    38,
-    43,    97,    98,    99,    28,    90,     0,   100,   101,   102,
-     0,    44,    35,    36,   100,   101,   102,   122,     0,    35,
-    36,    31,     1,     2,    71,     0,    32,    35,    36,    72,
-    44,    35,    36,   106,   107,     0,    45,    46
-};
-
-static const short yycheck[] = {    13,
-    11,     8,    14,    41,     5,     6,    37,    38,    30,    20,
-    41,    17,     3,     4,     5,     6,    41,    31,    62,    10,
-    58,    12,    13,    24,    62,    32,    74,    58,    39,    40,
-     4,    62,    23,    58,    41,    79,    84,     5,     6,    30,
-    31,    79,    18,    17,    55,    57,     3,     4,    79,    25,
-    26,    58,     3,     4,    23,     3,     4,     5,     6,     3,
-     4,    72,    10,    18,    12,    13,    23,    24,    14,    80,
-    25,    26,    23,    84,    19,    23,    15,    16,    19,    23,
-    25,    26,    30,    31,     0,    24,    97,    98,    99,   100,
-   101,   102,    19,    19,   108,     3,     4,    23,    25,    26,
-    23,   115,    10,    23,    12,    13,   120,     3,     4,    15,
-    16,    15,    16,    11,    10,    23,    12,    13,    24,     3,
-    24,    58,    30,    31,     7,     8,     9,    23,    27,    28,
-    32,     7,     8,     9,    30,    31,    -1,    20,    21,    22,
-    -1,    24,    25,    26,    20,    21,    22,     0,    -1,    25,
-    26,    24,     5,     6,    24,    -1,    29,    25,    26,    29,
-    24,    25,    26,    94,    95,    -1,    35,    36
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/bison.simple"
-/* This file comes from bison-1.27.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 216 "/usr/share/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 5:
-#line 38 "minicomp.y"
-{yyval=new_type(DOUBLE);;
-    break;}
-case 6:
-#line 39 "minicomp.y"
-{yyval=new_type(INT);;
-    break;}
-case 7:
-#line 40 "minicomp.y"
-{yyval=new_array(yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 10:
-#line 49 "minicomp.y"
-{add_var(yyvsp[-1],yyvsp[-2]);;
-    break;}
-case 11:
-#line 53 "minicomp.y"
-{yyval=add_string(tkname);;
-    break;}
-case 12:
-#line 57 "minicomp.y"
-{yyval=binary_node(NAND,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 13:
-#line 58 "minicomp.y"
-{yyval=binary_node(NOR,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 15:
-#line 63 "minicomp.y"
-{yyval=binary_node(NEQUALS,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 16:
-#line 64 "minicomp.y"
-{yyval=binary_node(NNEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 17:
-#line 65 "minicomp.y"
-{yyval=binary_node(NLT,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 18:
-#line 66 "minicomp.y"
-{yyval=binary_node(NGT,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 19:
-#line 67 "minicomp.y"
-{yyval=binary_node(NLEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 20:
-#line 68 "minicomp.y"
-{yyval=binary_node(NGEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 21:
-#line 69 "minicomp.y"
-{yyval=yyvsp[-1];
-    break;}
-case 22:
-#line 72 "minicomp.y"
-{yyval=binary_node(NADD,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 23:
-#line 73 "minicomp.y"
-{yyval=binary_node(NSUB,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 25:
-#line 77 "minicomp.y"
-{yyval=binary_node(NMUL,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 26:
-#line 78 "minicomp.y"
-{yyval=binary_node(NDIV,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 28:
-#line 83 "minicomp.y"
-{yyval=yyvsp[-1];;
-    break;}
-case 29:
-#line 84 "minicomp.y"
-{yyval=number_node();;
-    break;}
-case 30:
-#line 85 "minicomp.y"
-{yyval=binary_node(NCALL,yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 31:
-#line 86 "minicomp.y"
-{yyval=binary_node(NCALL,yyvsp[-2],0);;
-    break;}
-case 33:
-#line 91 "minicomp.y"
-{yyval=binary_node(NINDEX,yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 35:
-#line 96 "minicomp.y"
-{yyval=var_node();;
-    break;}
-case 36:
-#line 100 "minicomp.y"
-{yyval=binary_node(NARG,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 45:
-#line 118 "minicomp.y"
-{enter_block();;
-    break;}
-case 47:
-#line 122 "minicomp.y"
-{leave_block();;
-    break;}
-case 48:
-#line 123 "minicomp.y"
-{leave_block();;
-    break;}
-case 49:
-#line 124 "minicomp.y"
-{leave_block();;
-    break;}
-case 50:
-#line 125 "minicomp.y"
-{leave_block();;
-    break;}
-case 51:
-#line 130 "minicomp.y"
-{if_statement(yyvsp[-1]);;
-    break;}
-case 53:
-#line 134 "minicomp.y"
-{if_end();;
-    break;}
-case 54:
-#line 135 "minicomp.y"
-{if_else();;
-    break;}
-case 55:
-#line 135 "minicomp.y"
-{if_end();;
-    break;}
-case 56:
-#line 140 "minicomp.y"
-{while_statement(yyvsp[-1]);;
-    break;}
-case 57:
-#line 140 "minicomp.y"
-{while_end();;
-    break;}
-case 58:
-#line 144 "minicomp.y"
-{assign_statement(yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 59:
-#line 148 "minicomp.y"
-{return_statement(yyvsp[-1]);;
-    break;}
-case 61:
-#line 156 "minicomp.y"
-{enter_func(yyvsp[-1],yyvsp[-2]);;
-    break;}
-case 62:
-#line 160 "minicomp.y"
-{leave_func();;
-    break;}
-case 63:
-#line 161 "minicomp.y"
-{leave_func();;
-    break;}
-case 66:
-#line 170 "minicomp.y"
-{add_var(yyvsp[0],yyvsp[-1]);;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 542 "/usr/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 173 "minicomp.y"
-
-
-#include "minicomplexer.c"
-
diff -Naur vbcc/minicompg.tab.c /usr/glenda/advbcc/Advent-master/vbcc/minicompg.tab.c
--- vbcc/minicompg.tab.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/minicompg.tab.c	Thu Jan  1 00:00:00 1970
@@ -1,1187 +0,0 @@
-
-/*  A Bison parser, made from minicompg.y
- by  GNU Bison version 1.27
-  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define	TKNUMBER	257
-#define	TKIDENTIFIER	258
-#define	TKREAL	259
-#define	TKINT	260
-#define	TKLEQ	261
-#define	TKGEQ	262
-#define	TKNEQ	263
-#define	TKIF	264
-#define	TKELSE	265
-#define	TKWHILE	266
-#define	TKRETURN	267
-#define	TKASSIGN	268
-#define	TKAND	269
-#define	TKOR	270
-
-#line 18 "minicompg.y"
-
-#include "minicomp.h"
-
-typedef void *voidptr;
-#define YYSTYPE voidptr
-#ifndef YYSTYPE
-#define YYSTYPE int
-#endif
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		123
-#define	YYFLAG		-32768
-#define	YYNTBASE	32
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 270 ? yytranslate[x] : 64)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,    23,
-    24,    27,    25,    29,    26,     2,    28,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,    19,    21,
-    20,    22,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-    17,     2,    18,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,    30,     2,    31,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     3,     5,     7,     9,    11,    13,    18,    21,    23,
-    27,    29,    33,    37,    39,    43,    47,    51,    55,    59,
-    63,    67,    71,    75,    77,    81,    85,    87,    91,    93,
-    98,   102,   104,   109,   111,   113,   117,   119,   122,   124,
-   126,   128,   130,   132,   134,   135,   139,   143,   146,   149,
-   151,   152,   160,   161,   162,   166,   167,   174,   179,   183,
-   186,   190,   194,   197,   201,   203
-};
-
-static const short yyrhs[] = {    32,
-    33,     0,    33,     0,    59,     0,    36,     0,     5,     0,
-     6,     0,    34,    17,    40,    18,     0,    35,    36,     0,
-    36,     0,    34,    37,    19,     0,     4,     0,    38,    15,
-    39,     0,    38,    16,    39,     0,    39,     0,    40,    20,
-    40,     0,    40,     9,    40,     0,    40,    21,    40,     0,
-    40,    22,    40,     0,    40,     7,    40,     0,    40,     8,
-    40,     0,    23,    38,    24,     0,    40,    25,    41,     0,
-    40,    26,    41,     0,    41,     0,    41,    27,    42,     0,
-    41,    28,    42,     0,    42,     0,    23,    40,    24,     0,
-     3,     0,    44,    23,    45,    24,     0,    44,    23,    24,
-     0,    43,     0,    42,    17,    40,    18,     0,    44,     0,
-     4,     0,    45,    29,    40,     0,    40,     0,    46,    47,
-     0,    47,     0,    51,     0,    55,     0,    57,     0,    58,
-     0,    48,     0,     0,    30,    49,    50,     0,    35,    46,
-    31,     0,    46,    31,     0,    35,    31,     0,    31,     0,
-     0,    10,    23,    38,    24,    52,    48,    53,     0,     0,
-     0,    11,    54,    48,     0,     0,    12,    23,    38,    24,
-    56,    48,     0,    43,    14,    40,    19,     0,    13,    40,
-    19,     0,    60,    61,     0,    34,    37,    23,     0,    62,
-    24,    48,     0,    24,    48,     0,    62,    29,    63,     0,
-    63,     0,    34,    37,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    27,    29,    32,    34,    37,    39,    40,    43,    45,    48,
-    52,    56,    58,    59,    62,    64,    65,    66,    67,    68,
-    69,    72,    73,    74,    77,    78,    79,    82,    84,    85,
-    86,    87,    90,    92,    95,    99,   101,   104,   106,   109,
-   111,   112,   113,   114,   117,   119,   121,   123,   124,   125,
-   129,   130,   133,   135,   135,   139,   140,   143,   147,   151,
-   155,   159,   161,   164,   166,   169
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","TKNUMBER",
-"TKIDENTIFIER","TKREAL","TKINT","TKLEQ","TKGEQ","TKNEQ","TKIF","TKELSE","TKWHILE",
-"TKRETURN","TKASSIGN","TKAND","TKOR","'['","']'","';'","'='","'<'","'>'","'('",
-"')'","'+'","'-'","'*'","'/'","','","'{'","'}'","glob_decl_list","glob_decl",
-"type","decl_list","decl","decl_id","cond_expr","ao_expr","arith_expr","term",
-"factor","lvalue","variable","arg_list","stmt_list","stmt","block","@1","block_end",
-"if_stmt","@2","else_part","@3","while_stmt","@4","assgn_stmt","return_stmt",
-"func_decl","func_decl_begin","func_decl_end","par_list","par_decl", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    32,    32,    33,    33,    34,    34,    34,    35,    35,    36,
-    37,    38,    38,    38,    39,    39,    39,    39,    39,    39,
-    39,    40,    40,    40,    41,    41,    41,    42,    42,    42,
-    42,    42,    43,    43,    44,    45,    45,    46,    46,    47,
-    47,    47,    47,    47,    49,    48,    50,    50,    50,    50,
-    52,    51,    53,    54,    53,    56,    55,    57,    58,    59,
-    60,    61,    61,    62,    62,    63
-};
-
-static const short yyr2[] = {     0,
-     2,     1,     1,     1,     1,     1,     4,     2,     1,     3,
-     1,     3,     3,     1,     3,     3,     3,     3,     3,     3,
-     3,     3,     3,     1,     3,     3,     1,     3,     1,     4,
-     3,     1,     4,     1,     1,     3,     1,     2,     1,     1,
-     1,     1,     1,     1,     0,     3,     3,     2,     2,     1,
-     0,     7,     0,     0,     3,     0,     6,     4,     3,     2,
-     3,     3,     2,     3,     1,     2
-};
-
-static const short yydefact[] = {     0,
-     5,     6,     0,     2,     0,     4,     3,     0,     1,    11,
-     0,     0,     0,     0,    60,     0,    65,    29,    35,     0,
-     0,    24,    27,    32,    34,    10,    61,    45,    63,    66,
-     0,     0,     0,     7,     0,     0,     0,     0,     0,     0,
-     0,    62,    64,    28,    22,    23,    25,    26,     0,    31,
-    37,     0,     0,     0,     0,    50,     0,     0,     9,     0,
-    32,     0,    39,    44,    46,    40,    41,    42,    43,    33,
-    30,     0,     0,     0,     0,     0,    49,     8,     0,     0,
-    48,    38,    36,     0,     0,    14,     0,     0,    59,    47,
-     0,     0,     0,     0,     0,    51,     0,     0,     0,     0,
-     0,     0,    56,    58,    21,    12,    13,     0,    19,    20,
-    16,    15,    17,    18,     0,    53,    57,    54,    52,     0,
-    55,     0,     0
-};
-
-static const short yydefgoto[] = {     3,
-     4,     5,    58,     6,    12,    85,    86,    87,    22,    23,
-    24,    25,    52,    62,    63,    64,    41,    65,    66,   108,
-   119,   120,    67,   115,    68,    69,     7,     8,    15,    16,
-    17
-};
-
-static const short yypact[] = {    33,
--32768,-32768,   148,-32768,    27,-32768,-32768,     0,-32768,-32768,
-    50,    75,   -21,    27,-32768,   128,-32768,-32768,-32768,    50,
-    25,   102,    -5,-32768,    32,-32768,-32768,-32768,-32768,-32768,
-   -21,    33,   137,-32768,    50,    50,    50,    50,    50,    44,
-    10,-32768,-32768,-32768,   102,   102,    -5,    -5,    46,-32768,
-   133,   131,    78,    81,    50,-32768,    27,    53,-32768,    -5,
-    55,    93,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,    50,    57,    57,    56,    60,-32768,-32768,   105,    50,
--32768,-32768,   133,    57,    62,-32768,   125,    95,-32768,-32768,
-    74,    97,   118,    57,    57,-32768,    50,    50,    50,    50,
-    50,    50,-32768,-32768,-32768,-32768,-32768,   -21,   133,   133,
-   133,   133,   133,   133,   -21,   103,-32768,-32768,-32768,   -21,
--32768,    85,-32768
-};
-
-static const short yypgoto[] = {-32768,
-   117,    -6,-32768,   -24,   -11,   -47,    70,   -10,   132,   -30,
-   -37,-32768,-32768,    64,   -43,   -13,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-    99
-};
-
-
-#define	YYLAST		168
-
-
-static const short yytable[] = {    29,
-    21,    14,    30,    61,     1,     2,    47,    48,    28,    33,
-    60,    39,    18,    19,     1,     2,    59,    42,    82,    53,
-    61,    54,    55,    13,    61,    14,    88,    60,    49,    51,
-    10,    60,    20,    78,    57,    82,    92,     1,     2,    28,
-    56,    61,    34,    11,    75,    76,    18,    19,    60,    35,
-    36,    57,    18,    19,    40,    18,    19,     1,     2,    18,
-    19,    83,    53,    70,    54,    55,    20,    50,    80,    91,
-    35,    36,    20,    93,    89,    20,    94,    95,    26,    84,
-    35,    36,    28,    77,   123,    96,   109,   110,   111,   112,
-   113,   114,   104,    26,   116,    18,    19,    27,    35,    36,
-    73,   117,    53,    74,    54,    55,   121,    18,    19,    94,
-    95,    94,    95,   118,    53,    20,    54,    55,   103,     9,
-   105,    79,    28,    81,    97,    98,    99,    20,    37,    38,
-    43,    97,    98,    99,    28,    90,     0,   100,   101,   102,
-     0,    44,    35,    36,   100,   101,   102,   122,     0,    35,
-    36,    31,     1,     2,    71,     0,    32,    35,    36,    72,
-    44,    35,    36,   106,   107,     0,    45,    46
-};
-
-static const short yycheck[] = {    13,
-    11,     8,    14,    41,     5,     6,    37,    38,    30,    20,
-    41,    17,     3,     4,     5,     6,    41,    31,    62,    10,
-    58,    12,    13,    24,    62,    32,    74,    58,    39,    40,
-     4,    62,    23,    58,    41,    79,    84,     5,     6,    30,
-    31,    79,    18,    17,    55,    57,     3,     4,    79,    25,
-    26,    58,     3,     4,    23,     3,     4,     5,     6,     3,
-     4,    72,    10,    18,    12,    13,    23,    24,    14,    80,
-    25,    26,    23,    84,    19,    23,    15,    16,    19,    23,
-    25,    26,    30,    31,     0,    24,    97,    98,    99,   100,
-   101,   102,    19,    19,   108,     3,     4,    23,    25,    26,
-    23,   115,    10,    23,    12,    13,   120,     3,     4,    15,
-    16,    15,    16,    11,    10,    23,    12,    13,    24,     3,
-    24,    58,    30,    31,     7,     8,     9,    23,    27,    28,
-    32,     7,     8,     9,    30,    31,    -1,    20,    21,    22,
-    -1,    24,    25,    26,    20,    21,    22,     0,    -1,    25,
-    26,    24,     5,     6,    24,    -1,    29,    25,    26,    29,
-    24,    25,    26,    94,    95,    -1,    35,    36
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/bison.simple"
-/* This file comes from bison-1.27.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 216 "/usr/share/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 5:
-#line 38 "minicompg.y"
-{yyval=new_type(DOUBLE);;
-    break;}
-case 6:
-#line 39 "minicompg.y"
-{yyval=new_type(INT);;
-    break;}
-case 7:
-#line 40 "minicompg.y"
-{yyval=new_array(yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 10:
-#line 49 "minicompg.y"
-{add_var(yyvsp[-1],yyvsp[-2]);;
-    break;}
-case 11:
-#line 53 "minicompg.y"
-{yyval=add_string(tkname);;
-    break;}
-case 12:
-#line 57 "minicompg.y"
-{yyval=binary_node(NAND,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 13:
-#line 58 "minicompg.y"
-{yyval=binary_node(NOR,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 15:
-#line 63 "minicompg.y"
-{yyval=binary_node(NEQUALS,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 16:
-#line 64 "minicompg.y"
-{yyval=binary_node(NNEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 17:
-#line 65 "minicompg.y"
-{yyval=binary_node(NLT,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 18:
-#line 66 "minicompg.y"
-{yyval=binary_node(NGT,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 19:
-#line 67 "minicompg.y"
-{yyval=binary_node(NLEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 20:
-#line 68 "minicompg.y"
-{yyval=binary_node(NGEQ,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 21:
-#line 69 "minicompg.y"
-{yyval=yyvsp[-1];
-    break;}
-case 22:
-#line 72 "minicompg.y"
-{yyval=binary_node(NADD,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 23:
-#line 73 "minicompg.y"
-{yyval=binary_node(NSUB,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 25:
-#line 77 "minicompg.y"
-{yyval=binary_node(NMUL,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 26:
-#line 78 "minicompg.y"
-{yyval=binary_node(NDIV,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 28:
-#line 83 "minicompg.y"
-{yyval=yyvsp[-1];;
-    break;}
-case 29:
-#line 84 "minicompg.y"
-{yyval=number_node();;
-    break;}
-case 30:
-#line 85 "minicompg.y"
-{yyval=binary_node(NCALL,yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 31:
-#line 86 "minicompg.y"
-{yyval=binary_node(NCALL,yyvsp[-2],0);;
-    break;}
-case 33:
-#line 91 "minicompg.y"
-{yyval=binary_node(NINDEX,yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 35:
-#line 96 "minicompg.y"
-{yyval=var_node();;
-    break;}
-case 36:
-#line 100 "minicompg.y"
-{yyval=binary_node(NARG,yyvsp[-2],yyvsp[0]);;
-    break;}
-case 45:
-#line 118 "minicompg.y"
-{enter_block();;
-    break;}
-case 47:
-#line 122 "minicompg.y"
-{leave_block();;
-    break;}
-case 48:
-#line 123 "minicompg.y"
-{leave_block();;
-    break;}
-case 49:
-#line 124 "minicompg.y"
-{leave_block();;
-    break;}
-case 50:
-#line 125 "minicompg.y"
-{leave_block();;
-    break;}
-case 51:
-#line 130 "minicompg.y"
-{if_statement(yyvsp[-1]);;
-    break;}
-case 53:
-#line 134 "minicompg.y"
-{if_end();;
-    break;}
-case 54:
-#line 135 "minicompg.y"
-{if_else();;
-    break;}
-case 55:
-#line 135 "minicompg.y"
-{if_end();;
-    break;}
-case 56:
-#line 140 "minicompg.y"
-{while_statement(yyvsp[-1]);;
-    break;}
-case 57:
-#line 140 "minicompg.y"
-{while_end();;
-    break;}
-case 58:
-#line 144 "minicompg.y"
-{assign_statement(yyvsp[-3],yyvsp[-1]);;
-    break;}
-case 59:
-#line 148 "minicompg.y"
-{return_statement(yyvsp[-1]);;
-    break;}
-case 61:
-#line 156 "minicompg.y"
-{enter_func(yyvsp[-1],yyvsp[-2]);;
-    break;}
-case 62:
-#line 160 "minicompg.y"
-{leave_func();;
-    break;}
-case 63:
-#line 161 "minicompg.y"
-{leave_func();;
-    break;}
-case 66:
-#line 170 "minicompg.y"
-{add_var(yyvsp[0],yyvsp[-1]);;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 542 "/usr/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 173 "minicompg.y"
-
-
-#include "minicomplexer.c"
-
diff -Naur vbcc/minicomplexer.c /usr/glenda/advbcc/Advent-master/vbcc/minicomplexer.c
--- vbcc/minicomplexer.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/minicomplexer.c	Thu Jan  1 00:00:00 1970
@@ -1,79 +0,0 @@
-
-FILE *infile;
-static int cur_char=' ';
-
-char tkname[MAXLEN];
-
-int yylex()
-{
-  char *p=tkname;
-  int tmp;
-
-  while(isspace(cur_char))
-    cur_char=getc(infile);
-
-  if(isdigit(cur_char)){
-    do{
-      *p++=cur_char;
-      cur_char=getc(infile);
-    }while(isdigit(cur_char));
-    if(cur_char=='.'){
-      *p++=cur_char;
-      cur_char=getc(infile);
-      while(isdigit(cur_char)){
-	*p++=cur_char;
-	cur_char=getc(infile);
-      }
-    }
-    *p++=0;
-    return TKNUMBER;
-  }
-  if(isalpha(cur_char)){
-    do{
-      *p++=cur_char;
-      cur_char=getc(infile);
-    }while(isalnum(cur_char));
-    *p++=0;
-    if(!strcmp(tkname,"int"))
-      return TKINT;
-    if(!strcmp(tkname,"real"))
-      return TKREAL;
-    if(!strcmp(tkname,"if"))
-      return TKIF;
-    if(!strcmp(tkname,"else"))
-      return TKELSE;
-    if(!strcmp(tkname,"while"))
-      return TKWHILE;
-    if(!strcmp(tkname,"return"))
-      return TKRETURN;
-    return TKIDENTIFIER;
-  }
-  tmp=cur_char;
-  cur_char=getc(infile);
-  if(tmp=='!'&&cur_char=='='){
-    cur_char=getc(infile);
-    return TKNEQ;
-  }
-  if(tmp=='<'&&cur_char=='='){
-    cur_char=getc(infile);
-    return TKLEQ;
-  }
-  if(tmp=='>'&&cur_char=='='){
-    cur_char=getc(infile);
-    return TKGEQ;
-  }
-  if(tmp=='&'&&cur_char=='&'){
-    cur_char=getc(infile);
-    return TKAND;
-  }
-  if(tmp=='|'&&cur_char=='|'){
-    cur_char=getc(infile);
-    return TKOR;
-  }
-  if(tmp==':'&&cur_char=='='){
-    cur_char=getc(infile);
-    return TKASSIGN;
-  }
-  return tmp;
-}
-
diff -Naur vbcc/misra_errors.h /usr/glenda/advbcc/Advent-master/vbcc/misra_errors.h
--- vbcc/misra_errors.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/misra_errors.h	Tue Sep 22 04:22:58 2015
@@ -1,5 +1,5 @@
 /* Kapitel 1 */
-1,1,"All code shall conform to ISO 9899:1990 \"Programming languages - C\", amended and "
+1,1,"All code shall conform to ISO 9899:1990 \"Programming languages - C\", amended and "
 "corrected by ISO/IEC 9899/COR1:1995, ISO/IEC 9899/AMD1:1995, and ISO/IEC 9899/COR2:1996.",MISRA|MISRA_2004,
 
 1,2,"No reliance shall be placed on undefined or unspecified behaviour.",MISRA|MISRA_2004,
diff -Naur vbcc/opt.c /usr/glenda/advbcc/Advent-master/vbcc/opt.c
--- vbcc/opt.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/opt.c	Tue Sep 22 04:18:49 2015
@@ -41,82 +41,6 @@
 int norek;      /*  diese Funktion wird nicht rekursiv auf          */
 int nocall;     /*  diese Funktion kehrt nicht zum Caller zurueck   */
 
-#if HAVE_LIBCALLS
-extern np gen_libcall(char *fname,np arg1,struct Typ *t1,np arg2,struct Typ *t2);
-
-
-/* insert libcalls just before register allocation */
-static int insert_libcalls(struct flowgraph *fg)
-{
-  struct IC *p,*next,*add;
-  int replaced=0;
-  static struct node n,nl,nr;
-  static struct Typ t,tl,tr;
-  if(DEBUG&1024) printf("insert_libcalls\n");
-  while(fg){
-    for(p=fg->start;p;p=next){
-      int c=p->code,end=0;
-      char *libname;
-      next=p->next;
-      if((c>=OR&&c<=XOR)||(c>=LSHIFT&&c<=KOMPLEMENT)||c==COMPARE||c==CONVERT||c==MINUS||c==TEST){
-	if(libname=use_libcall(c,p->typf,p->typf2)){
-	  struct IC *merk_first,*merk_last;
-	  static struct node n1,n2;
-	  static struct Typ t1,t2;
-	  if(DEBUG&1024){
-	    printf("converting IC to libcall:\n");
-	    pric2(stdout,p);
-	  }
-	  replaced=1;
-	  merk_last=last_ic;
-	  merk_first=first_ic;
-	  first_ic=last_ic=0;
-	  n1.flags=REINTERPRET;
-	  n1.o=p->q1;
-	  n1.ntyp=&t1;
-	  t1.flags=q1typ(p);
-	  if(p->q2.flags){
-	    n2.flags=REINTERPRET;
-	    n2.o=p->q2;
-	    n2.ntyp=&t2;
-	    t2.flags=q2typ(p);
-	    gen_libcall(libname,&n1,&t1,&n2,&t2);
-	  }else
-	    gen_libcall(libname,&n1,&t1,0,0);
-	  if(!last_ic||last_ic->code!=GETRETURN) ierror(0);
-	  last_ic->z=p->z;
-	  add=first_ic;
-	  last_ic=merk_last;
-	  first_ic=merk_first;
-	  for(;add;add=next){
-	    next=add->next;
-	    insert_IC_fg(fg,p->prev,add);
-	  }
-	  next=p->next;
-	  if(fg->end==p) end=1;
-	  if(p->z.flags){
-	    remove_IC_fg(fg,p);
-	  }else{
-	    struct Typ *t=new_typ();
-	    t->flags=INT;
-	    p->code=TEST;
-	    p->typf=INT;
-	    p->q1.flags=VAR;
-	    p->q1.v=add_tmp_var(t);
-	    p->q1.val.vmax=l2zm(0L);
-	    p->prev->z=p->q1;
-	    p->q2.flags=p->z.flags=0;
-	  }
-	}
-      }
-      if(end||p==fg->end) break;
-    }
-    fg=fg->normalout;
-  }
-  return replaced;
-}
-#endif
-
 /*  temporary fuer verschiedene Bitvektoren */
 bvtype *tmp;
 
@@ -654,26 +578,6 @@
 	  p->code=c=MINUS;p->q2.flags=0;
 	  changed=1;
 	}
-
-	if(c==LSHIFT||c==RSHIFT){
-	  zmax size;
-	  size=zmmult(sizetab[q1typ(p)&NQ],char_bit);
-	  if(zmleq(size,vmax)){
-	    if(c==LSHIFT){
-	      if(DEBUG&1024){ printf("lshift converted to ASSIGN 0:\n");pric2(stdout,p);}
-	      o.val.vmax=l2zm(0L);eval_const(&o.val,MAXINT);
-	      insert_const(&p->q1.val,t);p->q1.flags=KONST;
-	      p->code=c=ASSIGN;p->q2.flags=0;p->q2.val.vmax=sizetab[t&NQ];
-	      changed=1;
-	    }else{
-	      if(DEBUG&1024){ printf("rshift changed to maxlength:\n");pric2(stdout,p);}
-	      o.val.vmax=zmsub(size,l2zm(1L));eval_const(&o.val,MAXINT);
-	      insert_const(&p->q2.val,t);
-	      changed=1;	      
-	    }
-	  }
-	}
-
 	if((c==SUB||c==ADD||c==ADDI2P||c==SUBIFP)&&!(q2typ(p)&UNSIGNED)&&zmleq(vmax,l2zm(0L))&&zldleq(vldouble,d2zld(0.0))){
 	  struct obj o;int ct=q2typ(p);
 	  o=p->q2;
@@ -1213,9 +1117,7 @@
 /*             in Verbindung mit 32), 256=recalc_offsets                */
 {
 #ifndef NO_OPTIMIZER
-  struct flowgraph *g,*fg=0;
-  int r,i,pass=0,mustrepeat,intask;
-  int lc_freed,lc_done=0;
+  struct flowgraph *g,*fg=0;int r,i,pass=0,mustrepeat,intask;
   if(!function) ierror(0);
   norek=nocall=0;
   report_suspicious_loops=report_weird_code=1;
@@ -1428,20 +1330,6 @@
 	}
       }
 
-
-#if HAVE_LIBCALLS
-      /* if no further optimizations are found, insert libcalls
-	 and look some more */
-      if(!lc_done&&(!gchanged||pass>=maxoptpasses)){
-	int r;
-	r=insert_libcalls(fg);
-	lc_done=1;
-	if(r){
-	  gchanged|=1;
-	  pass--;
-	}
-      }
-#endif
       
       if((!gchanged||pass>=maxoptpasses)){
 	/*  Funktion evtl. fuer inlining vorbereiten und    */
@@ -1485,8 +1373,7 @@
 	}
 	
 	if(cross_module) calc_finfo(function,CALC_USES|CALC_CHANGES);
-       
-
+	
 	if(flags&1){
 	  local_combine(fg);
 	  if(DEBUG&1024) print_flowgraph(fg);
@@ -1542,14 +1429,13 @@
 	  }
 	}
       }
-
       free_alias(fg);
       free_flowgraph(fg);
       free(vilist);
       FREEAV;
-
+      
       if((flags&32)&&gchanged&&pass>=maxoptpasses) error(172,maxoptpasses);
-
+      
     }while(gchanged&&pass<maxoptpasses);
     /*  nur, um nochmal ueberfluessige Labels zu entfernen  */
     fg=construct_flowgraph();
diff -Naur vbcc/parse_expr.c /usr/glenda/advbcc/Advent-master/vbcc/parse_expr.c
--- vbcc/parse_expr.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/parse_expr.c	Tue Sep 22 04:18:49 2015
@@ -5,20 +5,7 @@
 
 static char FILE_[]=__FILE__;
 
-np new_node(void)
-{
-  np p=mymalloc(NODES);
-  p->flags=0;
-  p->lvalue=0;
-  p->sidefx=0;
-  p->ntyp=0;
-  p->left=0;
-  p->right=0;
-  p->alist=0;
-  p->identifier=0;
-  p->o.flags=0;
-  return p;
-}
+
 
 np expression(void)
 /*  Komma-Ausdruecke  */
@@ -34,7 +21,7 @@
     next_token();
     killsp();
     right=assignment_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->ntyp=0;
@@ -66,7 +53,7 @@
     return left;
   }
   next_token();
-  new=new_node();
+  new=mymalloc(NODES);
   new->left=left;
   new->ntyp=0;
   if(c==ASSIGN){
@@ -76,7 +63,7 @@
     /*  ASSIGNOP(a,b)->ASSIGN(a,OP(a,b))    */
     new->flags=ASSIGNOP;    /* nur um zum Merken, dass nur einmal */
                             /* ausgewertet werden darf            */
-    new->right=new_node();
+    new->right=mymalloc(NODES);
     new->right->left=left;
     new->right->right=assignment_expression();
     new->right->ntyp=0;
@@ -92,11 +79,11 @@
   killsp();
   if(ctok->type==QUEST){   
     next_token();killsp();
-    new=new_node();
+    new=mymalloc(NODES);
     new->flags=COND;
     new->ntyp=0;
     new->left=left;
-    new->right=new_node();
+    new->right=mymalloc(NODES);
     new->right->flags=COLON;
     new->right->ntyp=0;
     new->right->left=expression();
@@ -126,7 +113,7 @@
 #ifdef HAVE_MISRA
 /* removed */
 #endif
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=LOR;
@@ -155,7 +142,7 @@
 #ifdef HAVE_MISRA
 /* removed */
 #endif
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=LAND;
@@ -176,7 +163,7 @@
     next_token();
     killsp();
     right=exclusive_or_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=OR;
@@ -196,7 +183,7 @@
     next_token();
     killsp();
     right=and_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=XOR;
@@ -217,7 +204,7 @@
     next_token();
     killsp();
     right=equality_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=AND;
@@ -238,7 +225,7 @@
     next_token();
     killsp();
     right=relational_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=c;
@@ -262,7 +249,7 @@
     next_token();
     killsp();
     right=shift_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=c;
@@ -286,7 +273,7 @@
     next_token();
     killsp();
     right=additive_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=c;
@@ -306,7 +293,7 @@
     if(ctok->type==PLUS) c=ADD; else c=SUB;
     next_token();killsp();
     right=multiplicative_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=c;
@@ -328,7 +315,7 @@
     else c=MOD;
     next_token();killsp();
     right=cast_expression();
-    new=new_node();
+    new=mymalloc(NODES);
     new->left=left;
     new->right=right;
     new->flags=c;
@@ -345,7 +332,7 @@
   killsp();
   if(ctok->type!=LPAR||!declaration(1)) return unary_expression();
   next_token();killsp();
-  new=new_node();
+  new=mymalloc(NODES);
   new->right=0;
   buff[0]=0;
   imerk=ident;ident=buff;
@@ -397,7 +384,7 @@
 	op=OFFSETOF;
       next_token();
       killsp();
-      new=new_node();
+      new=mymalloc(NODES);
       new->flags=CEXPR;
       new->ntyp=new_typ();
       if(op==SIZEOF||op==OFFSETOF){
@@ -501,7 +488,7 @@
       return new;
     }
   }
-  new=new_node();
+  new=mymalloc(NODES);
   new->right=0;
   new->ntyp=0;
   if(ctok->type==PLUS){
@@ -548,7 +535,7 @@
   left=primary_expression();
   killsp();
   while(ctok->type==LBRK||ctok->type==LPAR||ctok->type==DOT||ctok->type==ARROW||ctok->type==PPLUS||ctok->type==MMINUS){
-    new=new_node();
+    new=mymalloc(NODES);
     new->ntyp=0;
     new->right=0;
     new->left=left;
@@ -560,7 +547,7 @@
       new->flags=DSTRUCT;
       new->right=identifier_expression();
       new->right->flags=MEMBER;
-      new->left=new_node();
+      new->left=mymalloc(NODES);
       new->left->ntyp=0;
       new->left->left=left;
       new->left->right=0;
@@ -568,7 +555,7 @@
     }else if(ctok->type==LBRK){
       next_token(); killsp();
       new->flags=CONTENT;
-      new->left=new_node();
+      new->left=mymalloc(NODES);
       new->left->flags=ADD;
       new->left->ntyp=0;
       new->left->left=left;
@@ -617,6 +604,7 @@
 /* returns CALL node with alist attached, but without identifier */
 {
   struct argument_list *al,*first_alist=0,*last_alist=0;np n;
+  /*new=mymalloc(NODES);memset(new,0,NODES);*/
   if(ctok->type!=LPAR)ierror(0);
   next_token();killsp();
   while(ctok->type!=RPAR){
@@ -653,28 +641,6 @@
   }
   return identifier_expression();
 }
-
-struct const_list *cl_from_string(char *start, char *end)
-{
-  struct const_list *r,*cl,**prev;int i;
-  prev=&r;
-  for(i=0;i<end-start+1;i++){
-    cl=mymalloc(CLS);
-    cl->next=0;
-    cl->tree=0;
-    cl->idx=l2zm((long)i);
-    cl->val.vmax=l2zm(0L);
-    cl->other=mymalloc(CLS);
-    cl->other->next=cl->other->other=0;
-    cl->other->tree=0;
-    cl->other->idx=l2zm(0L);
-    cl->other->val.vchar=zm2zc(l2zm((long)start[i]));
-    *prev=cl;
-    prev=&cl->next;
-  }
-  return r;
-}
-
 np string_expression(void)
 /*  Gibt Zeiger auf string oder Zeichenkonstante zurueck  */
 {
@@ -694,7 +660,7 @@
     f=*s++;
     while(*s!=f&&*s!=0){
       size_t pos=p-string;
-      if(slen<=pos+1){
+      if(slen<=pos){
 	slen+=128;
 	string=myrealloc(string,slen);
 	p=string+pos;
@@ -747,16 +713,31 @@
     p=string;
   }
   *p=0;
-  new=new_node();
+  new=mymalloc(NODES);
   new->ntyp=new_typ();
   if(f=='\"'){
+    struct const_list *cl,**prev;int i;
     new->ntyp->flags=ARRAY;
     new->ntyp->size=l2zm((long)(p-string)+1);
     new->ntyp->next=new_typ();
     new->ntyp->next->flags=STRINGCONST|CHAR;
     new->ntyp->next->next=0;
     new->flags=STRING;
-    new->cl=cl_from_string(string,p);
+    prev=&new->cl;
+    for(i=0;i<p-string+1;i++){
+      cl=mymalloc(CLS);
+      cl->next=0;
+      cl->tree=0;
+      cl->idx=l2zm((long)i);
+      cl->val.vmax=l2zm(0L);
+      cl->other=mymalloc(CLS);
+      cl->other->next=cl->other->other=0;
+      cl->other->tree=0;
+      cl->other->idx=l2zm(0L);
+      cl->other->val.vchar=zm2zc(l2zm((long)string[i]));
+      *prev=cl;
+      prev=&cl->next;
+    }
     /*        new->identifier=add_identifier(string,p-string);*/
     new->val.vmax=l2zm(0L);
   }else{
@@ -791,7 +772,7 @@
   char *s,*merk;int warned=0,tm=0;
   merk=s=ctok->name;
   value=ul2zum(0L);
-  new=new_node();
+  new=mymalloc(NODES);
   new->ntyp=new_typ();
   new->ntyp->flags=0;
   new->flags=CEXPR;
@@ -988,7 +969,7 @@
 #ifdef HAVE_MISRA
 /* removed */
 #endif
-    new=new_node();
+    new=mymalloc(NODES);
     new->flags=IDENTIFIER;
     new->left=new->right=0;
     new->identifier=add_identifier(ctok->name,strlen(ctok->name));
@@ -999,7 +980,7 @@
     next_token();
   }else{
     error(76);
-    new=0;
+    new->flags=0;
   }
   return new;
 }
diff -Naur vbcc/pp.c /usr/glenda/advbcc/Advent-master/vbcc/pp.c
--- vbcc/pp.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/pp.c	Thu Jan  1 00:00:00 1970
@@ -1,975 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <assert.h>
-
-FILE *infile;
-int line=1;
-
-#define INCSIZE 16
-FILE **incfile;
-char **incname;
-int *incline;
-int incn,incsize;
-
-#define PP_TSIZE 1024
-
-/*FIXME*/
-#define ierror(x) abort();
-#define mymalloc(x) malloc(x)
-#define myrealloc(x,y) realloc(x,y)
-
-/* must not collide with source character-set */
-enum {
-  TKKEYWORD=-32,
-  TKMARG,
-  TKIDENTIFIER,
-  TKNUMBER,
-  TKPLUSPLUS,
-  TKMINMIN,
-  TKEOL,
-  TKLTLT,
-  TKGTGT,
-  TKSREF,
-  TKLE,
-  TKGE,
-  TKEQ,
-  TKNE,
-  TKLAND,
-  TKLOR,
-  TKMULEQ,
-  TKDIVEQ,
-  TKMODEQ,
-  TKPLUSEQ,
-  TKMINEQ,
-  TKLTLTEQ,
-  TKGTGTEQ,
-  TKANDEQ,
-  TKOREQ,
-  TKXOREQ,
-  TKDDD,
-  TKNUMNUM
-};
-
-static char *tokout[]={"err","err","err","err","++","--","","<<",">>","->","<=",">=","==",
-		       "!=","&&","||","*=","/=","%=","+=","-=","<<=",">>=","&=",
-		       "|=","^=","...","##"
-};
-
-static char *desc[]={
-  "TKKEYWORD",
-  "TKMARG",
-  "TKIDENTIFIER",
-  "TKNUMBER",
-  "TKPLUSPLUS",
-  "TKMINMIN",
-  "TKEOL",
-  "TKLTLT",
-  "TKGTGT",
-  "TKSREF",
-  "TKLE",
-  "TKGE",
-  "TKEQ",
-  "TKNE",
-  "TKLAND",
-  "TKLOR",
-  "TKMULEQ",
-  "TKDIVEQ",
-  "TKMODEQ",
-  "TKPLUSEQ",
-  "TKMINEQ",
-  "TKLTLTEQ",
-  "TKGTGTEQ",
-  "TKANDEQ",
-  "TKOREQ",
-  "TKXOREQ",
-  "TKDDD",
-  "TKNUMNUM"
-};
-
-typedef struct {
-  int size;
-  int next;
-  int *tokens;
-} tokenlist;
-
-#ifndef OBFUSCATOR
-
-#define VARARG_MACRO  1
-#define BUILTIN_MACRO 2
-#define NEED_PAREN    4
-
-typedef struct {
-  char *name;
-  int flags;
-  int nargs;
-  tokenlist repl;
-} macro;
-
-#define PP_HSIZE 16384
-static int **hash_table;
-
-#define PP_MSIZE 128
-static macro *macro_table;
-static int macro_cnt=1,macro_size;
-
-void print_tokenlist(FILE *,tokenlist *);
-
-static void copy_tokenlist(tokenlist *new,tokenlist *old)
-{
-  if(new->size<old->next+new->next){
-    new->size=old->next+new->next;
-    new->tokens=myrealloc(new->tokens,new->size*sizeof(*new->tokens));
-  }
-  memcpy(new->tokens+new->next,old->tokens,old->next*sizeof(*new->tokens));
-  new->next+=old->next;
-}
-
-static int new_macro(char *name,int flags,int nargs,tokenlist *repl)
-{
-  int i,*p;
-  if(macro_cnt>=macro_size){
-    macro_size+=PP_MSIZE;
-    macro_table=myrealloc(macro_table,macro_size*sizeof(*macro_table));
-    macro_table[0].name=0; /* dummy */
-  }
-  macro_table[macro_cnt].name=mymalloc(strlen(name)+1);
-  strcpy(macro_table[macro_cnt].name,name);
-  macro_table[macro_cnt].flags=flags;
-  macro_table[macro_cnt].nargs=nargs;
-  macro_table[macro_cnt].repl.size=0;
-  macro_table[macro_cnt].repl.next=0;
-  macro_table[macro_cnt].repl.tokens=0;  
-  copy_tokenlist(&macro_table[macro_cnt].repl,repl);
-  return macro_cnt++;
-}
-
-static void free_macro(int n)
-{
-  free(macro_table[n].name);
-  free(macro_table[n].repl.tokens);
-  macro_table[n].name=0;
-}
-
-static int hash(char *p)
-{
-  int s=0;
-  while(*p)
-    s+=*p++;
-  return s%PP_HSIZE;
-}
-
-static int find_macro(char *name)
-{
-  int i=hash(name),n,*p;
-  if(!(p=hash_table[i])) return 0;
-  n=p[0];
-  for(i=1;i<=n;i++)
-    if(macro_table[p[i]].name&&!strcmp(macro_table[p[i]].name,name))
-      return p[i];
-  return 0;
-}
-
-static void add_macro(int n)
-{
-  int i=hash(macro_table[n].name),*p;
-  if(!(p=hash_table[i])){
-    hash_table[i]=p=mymalloc(2*sizeof(*hash_table[i]));
-    p[0]=1;
-    p[1]=n;
-  }else{
-    p=hash_table[i]=myrealloc(p,(p[0]+1)*sizeof(*p));
-    p[0]++;
-    p[p[0]]=n;
-printf("hash_collisio, depth=%d\n",p[0]);
-  }
-}
-
-#endif /* OBFUSCATOR */
-
-static FILE *include_file(const char *name)
-{
-    if(incn>=incsize){
-	incsize+=INCSIZE;
-	incfile=myrealloc(incfile,incsize*sizeof(*incfile));
-	incname=myrealloc(incname,incsize*sizeof(*incname));
-	incline=myrealloc(incline,incsize*sizeof(*incline));
-    }
-    if(!name){
-	incfile[incn]=stdin;
-	name="<stdin>";
-    }else{
-	incfile[incn]=fopen(name,"r");
-    }
-printf("include file %s\n",name);
-    incname[incn]=mymalloc(strlen(name)+1);
-    strcpy(incname[incn],name);
-    incn++;
-    return incfile[incn-1];
-}
-
-static FILE *close_file(void)
-{
-    --incn;
-    free(incname[incn]);
-    if(incfile[incn])
-      fclose(incfile[incn]);
-    if(incn<=0)
-	return 0;
-    return incfile[incn-1];
-}
-
-static void add_token(tokenlist *p,int c)
-{
-  if(p->next>=p->size){
-    p->size+=PP_TSIZE;
-    p->tokens=myrealloc(p->tokens,p->size*sizeof(*p->tokens));
-  }
-  p->tokens[p->next]=c;
-  p->next++;
-}
-
-int read_char(void)
-/* Read next input character. Counts line numbers. */
-{
-  int tmp=getc(infile);
-  if(tmp=='\n') line++;
-  return tmp;
-}
-
-static int push_back=EOF;
-
-static int get_next_char(void)
-/* Read next character. Handles trigraphs and line-concatenation. */
-{
-  static int buf[2],inbuf;
-  int tmp,tmp2;
-  if(push_back!=EOF){
-    tmp=push_back;
-    push_back=EOF;
-    return tmp;
-  }
-  if(inbuf==0){
-    tmp=read_char();
-    if(tmp!='\\'&&tmp!='?'){
-      return tmp;
-    }else{
-      buf[0]=tmp;
-      inbuf=1;
-      /* fall through */
-    }
-  }
-  if(inbuf==1){
-    if(buf[0]!='?'&&buf[0]!='\\'){
-      inbuf=0;
-      return buf[0];
-    }else{
-      tmp=read_char();
-      if(buf[0]=='\\'){
-	if(tmp=='\n'){
-	  inbuf=0;
-	  return get_next_char();
-	}else{
-	  buf[0]=tmp;
-	  return '\\';
-	}
-      }else{
-	if(tmp=='?'){
-	  buf[1]='?';
-	  inbuf=2;
-	  /* fall through */
-	}else{
-	  buf[0]=tmp;
-	  return '?';
-	}
-      }
-    }
-  }
-  if(inbuf==2){
-    if(buf[0]!='?') ierror(0);
-    if(buf[1]!='?'){
-      inbuf=1;
-      tmp=buf[0];
-      buf[0]=buf[1];
-      return tmp;
-    }else{
-      tmp2=tmp=read_char();;
-      /* FIXME: only if on */
-      if(tmp=='=') tmp2='#';
-      else if(tmp=='(') tmp2='[';
-      else if(tmp=='/') tmp2='\\';
-      else if(tmp==')') tmp2=']';
-      else if(tmp=='\'') tmp2='^';
-      else if(tmp=='<') tmp2='{';
-      else if(tmp=='!') tmp2='|';
-      else if(tmp=='>') tmp2='}';
-      else if(tmp=='-') tmp2='~';
-      if(tmp!=tmp2){
-	/* FIXME: warning */
-	if(tmp2!='\\'){
-	  inbuf=0;
-	  return tmp2;
-	}else{
-	  inbuf=1;
-	  buf[0]=tmp2;
-	  return get_next_char();
-	}
-      }else{
-	tmp=buf[0];
-	buf[0]=buf[1];
-	buf[1]=tmp2;
-	return tmp;
-      }
-    }
-  }
-  ierror(0);
-}
-
-static int get_next_token(tokenlist *p)
-{
-  int c,z,tmp,*cnt;
-  while(1){
-    c=get_next_char();
-    if(c=='"'||c=='\''){
-      int term=c,escape=0;
-      add_token(p,c);      
-      z=p->next;
-      add_token(p,0);
-      while(1){
-	c=get_next_char();
-	/* FIXME */
-	if(c==EOF||c=='\n'){
-	  puts("unterminated string");
-	  return 0;
-	}
-	if(c==term&&!escape) return 0;
-	if(escape&&c=='\\')
-	    escape=0;
-	else
-	    escape=(c=='\\');
-	add_token(p,c);
-	p->tokens[z]++;
-      }
-    }else if(c=='_'||isalpha((unsigned char)c)){
-      add_token(p,TKIDENTIFIER);
-      z=p->next;
-      add_token(p,1);
-      add_token(p,c);
-      while((c=get_next_char())=='_'||isalnum((unsigned char)c)){
-	add_token(p,c);
-	p->tokens[z]++;
-      }
-      push_back=c;
-      return 0;
-    }else if(isdigit((unsigned char)c)){
-      tmp=c;
-      c=TKNUMBER;
-    }else if(c=='.'){
-      tmp=get_next_char();
-      if(isdigit((unsigned char)tmp)){
-	push_back=tmp;
-	tmp='.';
-	c=TKNUMBER;
-      }else if(tmp=='.'){
-	c=get_next_char();
-	if(c!='.'){puts("..x-token");return 0;}/*FIXME*/
-	add_token(p,TKDDD);
-	return 0;
-      }else
-	push_back=tmp;
-      /* fall through */
-    }else if(c=='+'){
-      c=get_next_char();
-      if(c=='+'){
-	add_token(p,TKPLUSPLUS);
-      }else if(c=='='){
-	add_token(p,TKPLUSEQ);
-      }else{
-	add_token(p,'+');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='-'){
-      c=get_next_char();
-      if(c=='-'){
-	add_token(p,TKMINMIN);
-      }else if(c=='='){
-	add_token(p,TKMINEQ);
-      }else if(c=='>'){
-	add_token(p,TKSREF);
-      }else{
-	add_token(p,'-');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='|'){
-      c=get_next_char();
-      if(c=='|'){
-	add_token(p,TKLOR);
-      }else if(c=='='){
-	add_token(p,TKOREQ);
-      }else{
-	add_token(p,'|');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='&'){
-      c=get_next_char();
-      if(c=='&'){
-	add_token(p,TKLAND);
-      }else if(c=='='){
-	add_token(p,TKANDEQ);
-      }else{
-	add_token(p,'&');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='<'){
-      c=get_next_char();
-      if(c=='<'){
-	c=get_next_char();
-	if(c=='='){
-	  add_token(p,TKLTLTEQ);
-	}else{
-	  add_token(p,TKLTLT);
-	  push_back=c;
-	}
-      }else if(c=='='){
-	add_token(p,TKLE);
-      }else{
-	add_token(p,'<');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='>'){
-      c=get_next_char();
-      if(c=='>'){
-	c=get_next_char();
-	if(c=='=')
-	  add_token(p,TKGTGTEQ);
-	else{
-	  add_token(p,TKGTGT);
-	  push_back=c;
-	}
-      }else if(c=='='){
-	add_token(p,TKGE);
-      }else{
-	add_token(p,'>');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='!'){
-      c=get_next_char();
-      if(c=='='){
-	add_token(p,TKNE);
-      }else{
-	add_token(p,'!');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='*'){
-      c=get_next_char();
-      if(c=='='){
-	add_token(p,TKMULEQ);
-      }else{
-	add_token(p,'*');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='%'){
-      c=get_next_char();
-      if(c=='='){
-	add_token(p,TKMODEQ);
-      }else{
-	add_token(p,'%');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='#'){
-      c=get_next_char();
-      if(c=='#'){
-	add_token(p,TKNUMNUM);
-      }else{
-	add_token(p,'#');
-	push_back=c;
-      }
-      return 0;
-    }else if(c=='/'){
-      /*FIXME*/
-      c=get_next_char();
-      if(c=='*'){
-	int cstate=0;
-	while(1){
-	  c=get_next_char();
-	  if(c=='*'){
-	    if(cstate==2) /*FIXME*/;
-	    cstate=1;
-	  }else if(c=='/'){
-	    if(cstate==1) break;
-	    cstate=2;
-	  }else cstate=0;
-	}
-	if(p->next>=1&&p->tokens[p->next-1]!=' '){
-	    add_token(p,' ');
-	    return 0;
-	}else
-	    continue;
-      }else if(c=='/'/*FIXME*/){
-	while((c=get_next_char())!=EOF&&c!='\n');
-	if(c==EOF) ierror(0); /*FIXME*/
-	add_token(p,'\n');
-	return 0;
-      }else if(c=='='){
-	add_token(p,TKDIVEQ);
-	return 0;
-      }
-      push_back=c;
-      c='/';
-      /* fall through */
-    }
-    if(c==TKNUMBER){
-      add_token(p,TKNUMBER);
-      z=p->next;
-      add_token(p,1);
-      add_token(p,tmp);
-      while(1){
-	c=get_next_char();
-	if(c=='e'||c=='E'||/*FIXME?*/c=='p'||c=='P'){
-	  add_token(p,c);
-	  p->tokens[z]++;
-	  tmp=get_next_char();
-	  if(tmp=='+'||tmp=='-'){
-	    add_token(p,tmp);
-	    p->tokens[z]++;
-	  }else{
-	    push_back=tmp;
-	  }
-	}else if(c=='.'||c=='_'||isalnum((unsigned char)c)){
-	  add_token(p,c);
-	  p->tokens[z]++;
-	}else{
-	  push_back=c;
-	  break;
-	}
-      }
-      return 0;
-    }
-    if(c==EOF||c=='\n'){
-      add_token(p,c);
-      return c;
-    }
-    if(!isspace((unsigned char)c)){
-      add_token(p,c);
-      return 0;
-    }else{
-      if(p->next>=1&&p->tokens[p->next-1]!=' ')
-	add_token(p,' ');
-      return 0;
-    }
-  }
-}
-
-void print_tokenlist(FILE *f,tokenlist *p)
-{
-  int i,*tr=p->tokens,*end=tr+p->next;
-  while(tr<end){
-    if(*tr=='"'||*tr=='\''||*tr==TKIDENTIFIER||*tr==TKNUMBER){
-      int n;
-      if(*tr=='"')
-	fprintf(f,"STRING: ");
-      else if(*tr=='\'')
-	fprintf(f,"CCONST: ");
-      else if(*tr==TKNUMBER)
-	fprintf(f,"NUMBER: ");
-      else
-	fprintf(f,"IDENT: ");
-      tr++;
-      n=*tr++;
-      for(i=0;i<n;i++)
-	fprintf(f,"%c",*tr++);
-      fprintf(f,"\n");
-      continue;
-    }
-    if(*tr==TKMARG){
-      fprintf(f,"ARG %d\n",tr[1]);
-      tr+=2; continue;
-    }
-    if(*tr==EOF){
-      fprintf(f,"EOF\n");
-      tr++; continue;
-    }
-    if(*tr=='\n'){
-      fprintf(f,"NEWLINE\n");
-      tr++; continue;
-    }
-    if(*tr>=TKPLUSPLUS&&*tr<=TKNUMNUM){
-      fprintf(f,"%s\n",desc[*tr-TKKEYWORD]);
-      tr++; continue;
-    }
-    fprintf(f,"OTHER: %d(%c)\n",*tr,*tr);
-    tr++;
-  }
-}
-
-void print_code(FILE *f,tokenlist *p)
-{
-  int i,*tr=p->tokens,*end=tr+p->next;
-  while(tr<end){
-    if(*tr=='"'||*tr=='\''||*tr==TKIDENTIFIER||*tr==TKNUMBER){
-      int n,c;
-      if(*tr==TKIDENTIFIER||*tr==TKNUMBER)
-	c=0;
-      else
-	c=*tr;
-      tr++;
-      if(c)
-	  fprintf(f,"%c",c);
-      n=*tr++;
-      for(i=0;i<n;i++)
-	fprintf(f,"%c",*tr++);
-      if(c)
-	fprintf(f,"%c",c);
-      continue;
-    }
-    if(*tr==EOF){
-	return;
-    }
-    if(*tr=='\n'){
-      fprintf(f,"\n");
-      tr++; continue;
-    }
-    if(*tr>=TKPLUSPLUS&&*tr<=TKNUMNUM){
-      fprintf(f,"%s",tokout[*tr-TKKEYWORD]);
-      tr++; continue;
-    }
-    fprintf(f,"%c",*tr);
-    tr++;
-  }
-}
-
-char *token2string(int *p)
-{
-  int n=p[1];char *s;
-  static char *buf,len;
-  if(n+1>len){
-    len=n+1;
-    buf=mymalloc(len);
-  }
-  s=buf;
-  p+=2;
-  while(--n>=0) *s++=*p++;
-  *s=0;
-  return buf;
-}
-
-#ifndef OBFUSCATOR
-
-static int *get_macro_arg(tokenlist *arg,int *p,int vararg)
-{
-  int par=0;
-  while(1){
-    if(*p==EOF||*p=='\n') puts("unterminated macro invocation"); /*FIXME*/
-    if(*p==','&&par==0&&!vararg) return p;
-    if(*p==')'){
-      if(par>0){
-	add_token(arg,*p++);
-	par--;
-	continue;
-      }else
-	return p;
-    }
-    if(*p==TKIDENTIFIER||*p==TKNUMBER||*p=='"'||*p=='\''){
-      int n;
-      add_token(arg,*p++);
-      n=*p;
-      add_token(arg,*p++);
-      while(--n>=0) add_token(arg,*p++);
-      continue;
-    }
-    if(*p=='(') par++;
-    add_token(arg,*p++);
-  }
-}
-
-void stringize(tokenlist *new,tokenlist *src)
-{
-  int z,f,n;
-  int *p=src->tokens,*end=p+src->next;
-puts("1");
-  add_token(new,'"');
-  z=new->next;
-  add_token(new,0);
-  while(p<end){
-puts("2");
-    f=*p;
-    if(f==TKIDENTIFIER||f==TKNUMBER||f=='"'||f=='\''){
-      if(f=='"'){
-	add_token(new,'\\');
-	add_token(new,'"');
-	new->tokens[z]+=2;
-      }else if(f=='\''){
-	add_token(new,'\'');
-	new->tokens[z]++;
-      }
-      p++;
-      n=*p++;
-      while(--n>=0){
-	if((f=='"'||f=='\'')&&(*p=='\\'||*p=='"')){
-	  add_token(new,'\\');
-	  new->tokens[z]++;
-	}
-	add_token(new,*p++);
-	new->tokens[z]++;
-      }
-      continue;
-    }
-puts("3b");
-    add_token(new,*p++);
-    new->tokens[z]++;
-  }
-}
-
-int expand(tokenlist *dest,tokenlist *old,tokenlist *scratch1,tokenlist *scratch2)
-{
-  int n,i,*p,*end;
-  int did_replace=0,notdone;
-  tokenlist *new=scratch1,*src=old,t1={0},t2={0};
-  do{
-puts("starting expand iteration");
-    notdone=0;
-    p=src->tokens;
-    end=p+src->next;
-    while(p<end){
-      if(*p==TKIDENTIFIER||*p==TKNUMBER||*p=='"'||*p=='\''){
-	if(*p==TKIDENTIFIER&&(n=find_macro(token2string(p)))!=0){
-	  tokenlist *repl=&macro_table[n].repl;
-	  if(!(macro_table[n].flags&NEED_PAREN)){
-	    n=repl->next;
-	    for(i=0;i<n;i++) add_token(new,repl->tokens[i]);
-	    p+=p[1]+2;
-	    did_replace=notdone=1;
-	    continue;
-	  }else if(p[p[1]+2]=='('){
-	    tokenlist **args=mymalloc((macro_table[n].nargs+1)*sizeof(*args));
-	    /*	  tokenlist *scratch=mymalloc(sizeof(*scratch));*/
-	    int *r,*end;
-	    p+=p[1]+3;
-	    for(i=0;i<macro_table[n].nargs;i++){
-	      if(i!=0){
-		if(*p==',') p++; else puts(", expect");/*FIXME*/
-	      }
-	      args[i]=mymalloc(sizeof(**args));
-	      args[i]->size=0;
-	      args[i]->next=0;
-	      args[i]->tokens=0;
-	      p=get_macro_arg(args[i],p,0);
-	      printf("arg %d:\n",i);
-	      print_tokenlist(stdout,args[i]);
-	    }
-	    if(macro_table[n].flags&VARARG_MACRO){
-	      args[i]=mymalloc(sizeof(**args));
-	      args[i]->size=0;
-	      args[i]->next=0;
-	      args[i]->tokens=0;
-	      if(*p==',') p++; else puts(", expect");/*FIXME*/
-	      p=get_macro_arg(args[i],p,1);
-	      printf("vararg:\n");
-	      print_tokenlist(stdout,args[i]);
-	    }
-	    if(*p==')') p++; else puts(") expect");/*FIXME*/
-	    
-	    r=macro_table[n].repl.tokens;
-	    end=r+macro_table[n].repl.next;
-	    while(r<end){
-	      if(*r==TKIDENTIFIER||*r==TKNUMBER||*r=='"'||*r=='\''){
-		n=r[1];
-		puts("insert idnt");
-		r+=2;
-		while(--n>=0) add_token(new,*r++);
-		continue;
-	      }
-	      if(*r=='#'){
-		r++;
-		if(*r!=TKMARG) {puts("huch?");ierror(0);/*FIXME*/}
-		r++;
-		n=*r++;
-		stringize(new,args[n]);
-		continue;
-	      }
-	      if(*r==TKMARG){
-		t1.next=t2.next=0;
-		expand(new,args[r[1]],&t1,&t2);
-		r+=2;
-		continue;
-	      }
-	      puts("insert other");
-	      add_token(new,*r++);
-	    }
-	    
-	    for(i=0;i<macro_table[n].nargs;i++) free(args[i]);
-	    if(macro_table[n].flags&VARARG_MACRO) free(args[i]);
-	    free(args);
-	    did_replace=notdone=1;
-	    continue;
-	  }
-	}
-	add_token(new,*p++);
-	n=*p++;
-	add_token(new,n);
-	for(i=0;i<n;i++) add_token(new,*p++);
-      }else
-	add_token(new,*p++);
-    }
-    if(!notdone){
-puts("expand done, copying");
-print_tokenlist(stdout,new);
-      copy_tokenlist(dest,new);
-puts("copy done");
-    }else{
-puts("need another iteration");
-      src=new;
-      if(new==scratch1)
-	new=scratch2;
-      else
-	new=scratch1;
-      new->next=0;
-    }
-  }while(notdone);
-  return did_replace;
-}
-
-#endif /* OBFUSCATOR */
-
-main()
-{
-  int i,lastline=line,*p;
-  tokenlist tl={0},t2={0},t3={0},t4={0};
-  infile=include_file(0);
-#ifndef OBFUSCATOR  
-  hash_table=mymalloc(PP_HSIZE*sizeof(*hash_table));
-  for(i=0;i<PP_HSIZE;i++) hash_table[i]=0;
-#endif  
-  while(1){
-    tl.next=0;
-    while(!(i=get_next_token(&tl)));
-    add_token(&tl,TKEOL);
-    print_code(stdout,&tl);
-    if(i==EOF){
-	infile=close_file();
-	if(!infile) exit(0);
-    }
-#ifndef OBFUSCATOR
-    p=&tl.tokens[0];
-    while(*p==' ') p++;
-    if(*p=='#'&&(p[1]==TKIDENTIFIER||(p[1]==' '&&p[2]==TKIDENTIFIER))){
-      char *s;
-      p++;
-      if(*p!=TKIDENTIFIER) p++;
-      s=token2string(p);
-      if(!strcmp(s,"include")){
-	puts("include found");
-	*p=TKNUMBER; /* prevent expansion */
-	p+=2+p[1];
-	i=p-&tl.tokens[0];
-	t2.next=0;
-	t3.next=0;
-	t4.next=0;
-	expand(&t2,&tl,&t3,&t4);
-	p=&t2.tokens[i];
-	while(*p==' ') p++;
-printf("*p=%d\n",*p);
-	if(*p=='\"'){
-	  s=token2string(p);
-	  infile=include_file(s);
-	  if(!infile) infile=close_file();
-	  if(!infile) {exit(EXIT_FAILURE);/*FIXME*/}
-	}
-	
-	continue;
-      }else if(!strcmp(s,"define")){
-	puts("define found");
-	p+=2+p[1];
-	while(*p==' ') p++;
-	if(*p!=TKIDENTIFIER){
-	  puts("#define needs ID");
-	}else{
-	  char *mname;
-	  int flags=0,nargs=0;
-	  static char **pnames;
-	  static int pnsize;
-
-	  s=token2string(p);
-	  p+=2+p[1];
-	  mname=mymalloc(strlen(s)+1);
-	  strcpy(mname,s);
-	  printf("id=%s\n",mname);
-	  while(*p==' ') p++;
-	  if(*p=='('){
-	    puts("function-like");
-	    p++;
-	    while(*p==' ') p++;
-	    while(*p==TKIDENTIFIER){
-	      flags=0;
-	      s=token2string(p);
-	      p+=p[1]+2;
-	      printf("parameter %s\n",s);
-	      if(nargs>=pnsize){
-		pnsize+=PP_MSIZE;
-		pnames=myrealloc(pnames,pnsize*sizeof(*pnames));
-	      }
-	      for(i=0;i<nargs;i++)
-		if(!strcmp(pnames[i],s)) puts("double parameter");
-	      pnames[nargs]=mymalloc(strlen(s)+1);
-	      strcpy(pnames[nargs],s);
-	      nargs++;
-	      while(*p==' ') p++;
-	      if(*p==','){ p++;flags=1;}
-	      while(*p==' ') p++;
-	    }
-	    if(flags){
-	      flags=NEED_PAREN;
-	      if(*p==TKDDD){p++;flags|=VARARG_MACRO;}else puts(".../,");/*FIXME*/
-	      while(*p==' ') p++;
-	      if(*p==')') p++; else puts(") expect");/*FIXME*/
-	    }else{
-	      flags=NEED_PAREN;
-	      if(*p==')') p++; else puts(") expect");/*FIXME*/
-	    }
-	  }
-	  /*FIXME: # must be followed by parameter */
-	  t2.next=0;
-	  while(*p==' ') p++;
-	  while(p<tl.tokens+tl.next&&*p!='\n'){
-	    if(*p==TKIDENTIFIER){
-	      s=token2string(p);
-	      for(i=0;i<nargs;i++){
-		if(!strcmp(pnames[i],s)) break;
-	      }
-	      if(i<nargs||((flags&VARARG_MACRO)&&!strcmp("__VA_ARGS__",s))){
-		p+=p[1]+2;
-		add_token(&t2,TKMARG);
-		add_token(&t2,i);
-		continue;
-	      }
-	    }
-	    add_token(&t2,*p++);
-	  }
-	  for(i=0;i<nargs;i++) free(pnames[i]);
-	  i=new_macro(mname,flags,nargs,&t2);
-	  add_macro(i);
-	  printf("replacement-list for %s\n",mname);
-	  print_tokenlist(stdout,&t2);
-	}
-      }
-    }else{
-      t2.next=0;
-      t3.next=0;
-      t4.next=0;
-      expand(&t2,&tl,&t3,&t4);
-      /*      print_tokenlist(stdout,&t2);*/
-      print_code(stdout,&t2);
-    }
-#endif /* OBFUSCATOR */    
-  }
-}
diff -Naur vbcc/pptst.h /usr/glenda/advbcc/Advent-master/vbcc/pptst.h
--- vbcc/pptst.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/pptst.h	Thu Jan  1 00:00:00 1970
@@ -1,34 +0,0 @@
-test
-hello
-con\
-catenated
-not\ 
-concatenated
-??= 
-??( 
-??/ 
-??) 
-??' 
-??< 
-??! 
-??> 
-??- 
-From standard: printf("Eh???/n");
-con??/
-catenated with trigraph
-
-# /*   */ define fail succeed
-fail
-#undef fail
- #define fail succeed
-fail
-
-#define x(a,b) a+b
-
-x(12
-23
-,
-34
-45
-)
-
diff -Naur vbcc/rd.c /usr/glenda/advbcc/Advent-master/vbcc/rd.c
--- vbcc/rd.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/rd.c	Tue Sep 22 04:18:49 2015
@@ -457,7 +457,7 @@
     p=dlist[j];
     if(!(p->z.flags&VAR)) return 0;
     if(p->z.v!=o->v) continue;
-    t=ztyp(p)&NU;
+    t=ztyp(p);
     if(cponly&&!ISSCALAR(t)) continue;
     if(!zmeqto(p->z.val.vmax,o->val.vmax)) continue;
     if(cponly){
@@ -486,14 +486,9 @@
       voff=p->q1.val.vmax;
     }
   }
-
   /* found constant */
   if(val){
     if(!cponly) return 0;
-    if(o==&sic->q1&&(q1typ(sic)&NU)!=t) return 0;
-    if(o==&sic->q2&&(q2typ(sic)&NU)!=t) return 0;
-    if(o==&sic->z&&(ztyp(sic)&NU)!=t) return 0;
-
     if(DEBUG&1024) printf("can replace <%s> by constant\n",o->v->identifier);
     o->val=*val;
     o->flags=KONST;
@@ -510,9 +505,6 @@
     return 2;
   }
   if(vaddr&&(o->flags&DREFOBJ)){
-    if(o==&sic->q1&&(q1typ(sic)&NU)!=(t&NU)) return 0;
-    if(o==&sic->q2&&(q2typ(sic)&NU)!=(t&NU)) return 0;
-    if(o==&sic->z&&(ztyp(sic)&NU)!=(t&NU)) return 0;
     if(DEBUG&1024) printf("can replace *<%s> by address\n",o->v->identifier);
     o->v=vaddr;
     o->val.vmax=voff;
diff -Naur vbcc/regs.c /usr/glenda/advbcc/Advent-master/vbcc/regs.c
--- vbcc/regs.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/regs.c	Tue Sep 22 04:18:49 2015
@@ -1277,16 +1277,6 @@
 	}
       }
     }
-
-    /* check for register arguments */
-    if((p->z.flags&(VAR|DREFOBJ))==VAR&&!*p->z.v->identifier&&p->z.v->reg){
-      savings[abs(p->z.v->reg)]=INT_MIN;
-      if(reg_pair(abs(p->z.v->reg),&rp)){
-	savings[rp.r1]=INT_MIN;
-	savings[rp.r2]=INT_MIN;
-      }
-    }
-
     p=p->prev;
   }
   r=0;
diff -Naur vbcc/statements.c /usr/glenda/advbcc/Advent-master/vbcc/statements.c
--- vbcc/statements.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/statements.c	Tue Sep 22 04:18:49 2015
@@ -234,8 +234,6 @@
 	  cexpr=0;
 	if((tree->o.flags&(SCRATCH|REG))==(SCRATCH|REG)&&cexpr) free_reg(tree->o.reg);
 	if(tree->o.flags&&!cexpr){
-	  gen_test(&tree->o,tree->ntyp->flags,BEQ,lfalse);
-#if 0
 	  new=new_IC();
 	  new->code=TEST;
 	  new->q1=tree->o;
@@ -246,7 +244,6 @@
 	  new->code=BEQ;
 	  new->typf=lfalse;
 	  add_IC(new);
-#endif
 	}
 	if(cexpr==2){
 	  new=new_IC();
@@ -559,13 +556,13 @@
 /*  bearbeitet while_statement                                  */
 {
   np tree;int lloop,lin,lout,cm,cexpr,contm,breakm;
-  struct IC *new,*mic; int line,tvalid;char *file;
+  struct IC *new,*mic; int line;char *file;
   killsp();
   if(ctok->type==LPAR) {next_token();killsp();} else error(151);
   tree=expression();
   cexpr=0;
   if(tree){
-    if(tvalid=type_expression(tree)){
+    if(type_expression(tree)){
 #ifdef HAVE_MISRA
 /* removed */
 #endif
@@ -588,25 +585,20 @@
   if(!cexpr||tree->sidefx) cont_label=lin; else cont_label=lloop;
   if(!cexpr||tree->sidefx){
     if(c_flags_val[0].l&2){ /*  bei Optimierung */
-      if(tvalid){
-	gen_IC(tree,lloop,lout);
-	if(tree->o.flags){
-	  gen_test(&tree->o,tree->ntyp->flags,BEQ,lout);
-#if 0
-	  new=new_IC();
-	  new->code=TEST;
-	  new->typf=tree->ntyp->flags;
-	  new->q1=tree->o;
-	  new->q2.flags=new->z.flags=0;
-	  add_IC(new);
-	  new=new_IC();
-	  new->code=BEQ;
-	  new->typf=lout;
-	  add_IC(new);
-#endif
-	}
-	repair_tree(tree);
+      gen_IC(tree,lloop,lout);
+      if(tree->o.flags){
+	new=new_IC();
+	new->code=TEST;
+	new->typf=tree->ntyp->flags;
+	new->q1=tree->o;
+	new->q2.flags=new->z.flags=0;
+	add_IC(new);
+	new=new_IC();
+	new->code=BEQ;
+	new->typf=lout;
+	add_IC(new);
       }
+      repair_tree(tree);
     }else{
       new=new_IC();
       new->code=BRA;
@@ -656,8 +648,6 @@
       if((tree->o.flags&(SCRATCH|REG))==(SCRATCH|REG)&&cexpr) free_reg(tree->o.reg);
     }
     if(tree->o.flags&&!cexpr){
-      gen_test(&tree->o,tree->ntyp->flags,BNE,lloop);
-#if 0
       new=new_IC();
       new->code=TEST;
       new->typf=tree->ntyp->flags;
@@ -668,7 +658,6 @@
       new->code=BNE;
       new->typf=lloop;
       add_IC(new);
-#endif
     }
     if(cexpr==2){
       new=new_IC();
@@ -688,7 +677,7 @@
 void for_statement(void)
 /*  bearbeitet for_statement                                    */
 {
-  np tree1=0,tree2=0,tree3=0;int lloop,lin,lout,cm,cexpr=0,contm,breakm,with_decl,tvalid;
+  np tree1=0,tree2=0,tree3=0;int lloop,lin,lout,cm,cexpr=0,contm,breakm,with_decl;
   struct IC *new,*mic;int line;char *file;
   killsp();
   if(ctok->type==LPAR) {next_token();killsp();} else error(59);
@@ -739,7 +728,7 @@
     }
   }
   if(tree2){
-    if(tvalid=type_expression(tree2)){
+    if(type_expression(tree2)){
 #ifdef HAVE_MISRA
 /* removed */
 #endif
@@ -762,25 +751,20 @@
   cont_label=++label;break_label=lout;
   if(!cexpr||(tree2&&tree2->sidefx)){
     if(c_flags_val[0].l&2){ /*  bei Optimierung */
-      if(tvalid){
-	gen_IC(tree2,lloop,lout);
-	if(tree2->o.flags){
-	  gen_test(&tree2->o,tree2->ntyp->flags,BEQ,lout);
-#if 0
-	  new=new_IC();
-	  new->code=TEST;
-	  new->typf=tree2->ntyp->flags;
-	  new->q1=tree2->o;
-	  new->q2.flags=new->z.flags=0;
-	  add_IC(new);
-	  new=new_IC();
-	  new->code=BEQ;
-	  new->typf=lout;
-	  add_IC(new);
-#endif
-	}
-	repair_tree(tree2);
+      gen_IC(tree2,lloop,lout);
+      if(tree2->o.flags){
+	new=new_IC();
+	new->code=TEST;
+	new->typf=tree2->ntyp->flags;
+	new->q1=tree2->o;
+	new->q2.flags=new->z.flags=0;
+	add_IC(new);
+	new=new_IC();
+	new->code=BEQ;
+	new->typf=lout;
+	add_IC(new);
       }
+      repair_tree(tree2);
     }else{
       new=new_IC();
       new->code=BRA;
@@ -844,8 +828,6 @@
       if((tree2->o.flags&(SCRATCH|REG))==(SCRATCH|REG)&&cexpr) free_reg(tree2->o.reg);
     }
     if(tree2->o.flags&&!cexpr){
-      gen_test(&tree2->o,tree2->ntyp->flags,BNE,lloop);
-#if 0
       new=new_IC();
       new->code=TEST;
       new->typf=tree2->ntyp->flags;
@@ -856,7 +838,6 @@
       new->code=BNE;
       new->typf=lloop;
       add_IC(new);
-#endif
     }
     if(cexpr==2){
       new=new_IC();
@@ -934,8 +915,6 @@
 	}else{
 	  gen_IC(tree,lloop,lout);
 	  if(tree->o.flags){
-	    gen_test(&tree->o,tree->ntyp->flags,BNE,lloop);
-#if 0
 	    new=new_IC();
 	    new->code=TEST;
 	    new->typf=tree->ntyp->flags;
@@ -946,7 +925,6 @@
 	    new->code=BNE;
 	    new->typf=lloop;
 	    add_IC(new);
-#endif
 	  }
 	}
       }else error(143);
diff -Naur vbcc/supp.c /usr/glenda/advbcc/Advent-master/vbcc/supp.c
--- vbcc/supp.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/supp.c	Tue Sep 22 04:18:49 2015
@@ -5,9 +5,8 @@
 
 #ifndef HAVE_EXT_TYPES
 char *typname[]={"strange","char","short","int","long","long long",
-                 "float","double","long double","void",
-                 "pointer","array","struct","union","enum","function",
-                 "bool","vector"};
+		 "float","double","long double","void",
+                 "pointer","array","struct","union","enum","function"};
 #endif
 
 char *storage_class_name[]={"strange","auto","register","static","extern","typedef"};
@@ -166,9 +165,7 @@
   p->flags=0;
   p->q1.flags=p->q2.flags=p->z.flags=0;
   p->q1.am=p->q2.am=p->z.am=0;
-  p->q1.val.vmax=p->q2.val.vmax=p->z.val.vmax=l2zm(0L);
   p->savedsp=0;
-  p->typf=p->typf2=0;
 #ifdef ALEX_REG
   p->iZWebIndex = -1;
   p->iQ1WebIndex = -1;
@@ -192,7 +189,7 @@
       int i;
       new->arg_list=mymalloc(sizeof(*new->arg_list)*new->arg_cnt);
       for(i=0;i<new->arg_cnt;i++)
-        new->arg_list[i]=p->arg_list[i]->copy;
+	new->arg_list[i]=p->arg_list[i]->copy;
     }
     new->prev=last;
     new->next=0;
@@ -252,7 +249,7 @@
   while(p){
     merk=p->next;
     f=p->flags&NQ;
-    if(merk&&!ISARRAY(f)&&!ISPOINTER(f)&&!ISFUNC(f)&&!ISVECTOR(f)) 
+    if(merk&&!ISARRAY(f)&&!ISPOINTER(f)&&!ISFUNC(f)) 
       ierror(0);
     free(p->attr);
     free(p);
@@ -267,14 +264,13 @@
 {
   int i,f; zmax al,alt;
   f=t->flags&NQ;
-  if(ISVECTOR(f)) return szof(t);
   al=align[f];
   if(ISSCALAR(f)) return al;
   if(ISARRAY(f)){
     do{ 
       t=t->next; 
       f=t->flags&NQ;
-    }while(ISARRAY(f)||ISVECTOR(f));
+    }while(ISARRAY(f));
     alt=falign(t);
     if(zmleq(al,alt)) return alt; else return al;
   }
@@ -342,51 +338,6 @@
   return new->z.v;
 }
 
-/* return the type of a d-dim vector of base type x */
-int mkvec(int x,int d)
-{
-  int t=x&NQ,r;
-  if(d!=2&&d!=3&&d!=4&&d!=8&&d!=16) ierror(0);
-  switch(t){
-  case BOOL:
-    r=VECBOOL;break;
-  case CHAR:
-    r=VECCHAR;break;
-  case SHORT:
-    r=VECSHORT;break;
-  case INT:
-    r=VECINT;break;
-  case LONG:
-    r=VECLONG;break;
-  case FLOAT:
-    r=VECFLOAT;break;
-  default:
-    ierror(0);
-  }
-  return (r+d-1)|(x&~NQ);
-}
-
-/* return the base type of a vector */
-int VECTYPE(int x)
-{
-  int t=x&NQ,r=0;
-  if(t>=VECBOOL&&t<=VECBOOL+MAXVECDIM)
-    r=BOOL;
-  if(t>=VECCHAR&&t<=VECCHAR+MAXVECDIM)
-    r=CHAR;
-  if(t>=VECSHORT&&t<=VECSHORT+MAXVECDIM)
-    r=SHORT;
-  if(t>=VECINT&&t<=VECINT+MAXVECDIM)
-    r=INT;
-  if(t>=VECLONG&&t<=VECLONG+MAXVECDIM)
-    r=LONG;
-  if(t>=VECFLOAT&&t<=VECFLOAT+MAXVECDIM)
-    r=FLOAT;
-  if(!r) ierror(0);
-  return r|(x&~NQ);
-}
-
-
 #ifndef HAVE_TGT_SZOF
 zmax szof(struct Typ *t)
 /*  Liefert die benoetigte Groesse eines Typs in Bytes.     */
@@ -395,7 +346,6 @@
 #ifdef HAVE_ECPP
 /* removed */
 #endif
-
   if(ISSCALAR(i)) return sizetab[i];
   if(ISARRAY(i)){
     if(is_vlength(t))
@@ -404,11 +354,6 @@
     m=align[ARRAY];
     return zmmult(zmdiv(zmadd(size,zmsub(m,l2zm(1L))),m),m); /* align */
   }
-  if(ISVECTOR(i)){
-    zmax dim=VECDIM(i);
-    if(zmeqto(dim,l2zm(3L))) dim=l2zm(4L);
-    return zmmult(dim,sizetab[VECTYPE(i)&NQ]);
-  }
   if(ISUNION(i)){
     for(j=0,size=l2zm(0L);j<t->exact->count;j++){
       m=szof((*t->exact->sl)[j].styp);
@@ -570,12 +515,7 @@
     if(p->typf&VOLATILE) fprintf(f,"volatile ");
     if(p->typf&CONST) fprintf(f,"const ");
     if(p->typf&UNSIGNED) fprintf(f,"unsigned ");
-    if(p->typf){
-      if(ISVECTOR(p->typf))
-	fprintf(f,"%s%d ",typname[VECTYPE(p->typf)&NQ],VECDIM(p->typf));
-      else
-	fprintf(f,"%s ",typname[p->typf&NQ]);
-    }
+    if(p->typf) fprintf(f,"%s ",typname[p->typf&NQ]);
     probj(f,&p->q1,q1typ(p));
     if(p->q2.flags){fprintf(f,",");probj(f,&p->q2,q2typ(p));}
     if(p->z.flags){fprintf(f,"->");probj(f,&p->z,ztyp(p));}
@@ -589,8 +529,6 @@
       fprintf(f," shift-type %s%s",(p->typf2&UNSIGNED)?"unsigned ":"",typname[p->typf2&NQ]);
     if(p->code==ADDI2P||p->code==SUBIFP||p->code==SUBPFP||p->code==ADDRESS)
       fprintf(f," ptype=%s%s",(p->typf2&UNSIGNED)?"unsigned ":"",typname[p->typf2&NQ]);
-    if(p->code==ASSIGN||p->code==PUSH)
-      if(p->typf2) fprintf(f," align=%d\n",p->typf2);
   }
   if(p->code==CALL){
     fprintf(f," =>");
@@ -599,7 +537,7 @@
     else{
       int i;
       for(i=0;i<p->call_cnt;i++)
-        fprintf(f," %s",p->call_list[i].v->identifier);
+	fprintf(f," %s",p->call_list[i].v->identifier);
     }
   }
   fprintf(f,"\n");
@@ -701,117 +639,110 @@
   emit(f,"fp-constant");
 }
 
-static struct memblock {struct memblock *next;void *p;} *first_mb;
+static struct memblock {struct memblock *next,*prev;void *p;} *first_mb,*last_mb;
 
 static void add_mb(void *p)
 {
-  struct memblock *mb_second=first_mb;
   struct memblock *mb=malloc(sizeof(*mb));
   if(!mb){
     error(12);
     raus();
   }
-  first_mb=mb;
-  mb->next=mb_second;
-  mb->p=p;
+  if(last_mb){
+    last_mb->next=mb;
+    mb->prev=last_mb;
+    last_mb=mb;
+    mb->next=0;
+    mb->p=p;
+  }else{
+    last_mb=first_mb=mb;
+    mb->next=mb->prev=0;
+    mb->p=p;
+  }
 }  
 
 static void remove_mb(void *p)
 {
-  struct memblock *mb_prev=0;
   struct memblock *mb=first_mb;
   while(mb){
     if(mb->p==p){
-      if(mb_prev==0) first_mb=mb->next;
-      else mb_prev->next=mb->next;
+      if(mb==first_mb)
+	first_mb=mb->next;
+      else
+	mb->prev->next=mb->next;
+      if(mb==last_mb)
+	last_mb=mb->prev;
+      else
+	mb->next->prev=mb->prev;
       (free)(mb);
       return;
     }
-    mb_prev=mb;
     mb=mb->next;
   }
   ierror(0);
 }
 
 void *mymalloc(size_t size)
-/*  Allocate memory and quit on failure.  */
+/*  Belegt Speicher mit Abfrage.    */
 {
-  void *p;
+  void *p;static int safe;
+  /*  Um ein Fehlschlagen bei size==0 zu vermeiden; nicht sehr schoen,    */
+  /*  aber das einfachste...                                              */
+  if(size==0) size=1;
   if(dmalloc)
     size+=sizeof(size);
-  else if(size==0)
-    /* Not very nice, but simplest way to avoid a failure when size==0. */
-    size=1;
   if(!(p=malloc(size))){
     error(12);
     raus();
   }
-  if(DEBUG&32768){
-    printf("malloc %p (s=%lu)\n",p,(unsigned long)size);
-    fflush(stdout);
-  }
-  if(DEBUG&65536) add_mb(p);
   if(dmalloc){
+    memset(p,0xaa,size);
     *(size_t *)p=size;
-    p=((char *)p)+sizeof(size);
-    memset(p,0xaa,size-sizeof(size));
-  } 
-  return p;
+    if(DEBUG&32768) {printf("malloc %p (s=%lu)\n",p,(unsigned long)size);fflush(stdout);}
+    if(DEBUG&65536) add_mb(p);
+    return ((char *)p)+sizeof(size);
+  }else{
+    if(DEBUG&32768) {printf("malloc %p (s=%lu)\n",p,(unsigned long)size);fflush(stdout);}
+    if(DEBUG&65536) add_mb(p);
+    return p;
+  }
 }
-
 void *myrealloc(void *p,size_t size)
-/*  Reallocate memory and quit on failure.  */
 {
   void *new;
   if(!p) return mymalloc(size);
   if(dmalloc){
     size+=sizeof(size);
-    new=realloc(((char *)p)-sizeof(size),size);
+    new=realloc(((char *)p)-sizeof(size),size+sizeof(size));
     if(!new){
       error(12);
       raus();
     }
-    if(DEBUG&32768){
-      printf("realloc %p to %p (s=%lu)\n",p,new,(unsigned long)size);
-      fflush(stdout);
-    }
-    if(DEBUG&65536){
-      remove_mb(p);
-      add_mb(new);
-    }
     *(size_t *)new=size;
     new=((char *)new)+sizeof(size);
-    return new;
   }else{
     new=realloc(p,size);
     if(!new){
       error(12);
       raus();
     }
-    if(DEBUG&32768){
-      printf("realloc %p to %p (s=%lu)\n",p,new,(unsigned long)size);
-      fflush(stdout);
-    }
-    if(DEBUG&65536){
-      remove_mb(p);
-      add_mb(new);
-    }
-    return new;
   }
+  if(DEBUG&32768) {printf("realloc %p (s=%lu)\n",p,(unsigned long)size);fflush(stdout);}
+  if(DEBUG&65536){
+    if(p) remove_mb(p);
+    add_mb(new);
+  }
+  return new;
 }
-
 void myfree(void *p)
 {
   if(p&&dmalloc){
+    memset(((char*)p)-sizeof(size_t),0xbb,*(size_t*)(((char*)p)-sizeof(size_t)));
     p=((char*)p)-sizeof(size_t);
-    memset(p,0xbb,*(size_t *)(p));
-  }
-  if(DEBUG&32768){
-    printf("free %p\n",p);
-    fflush(stdout);
   }
+  if(DEBUG&32768) {printf("free %p\n",p);fflush(stdout);}
   if((DEBUG&65536)&&p) remove_mb(p);
-  (free)(p);  /* supp.h has #define free(x) myfree(x) */
+  (free)(p);
 }
 
 char *mystrdup(char *p)
@@ -827,19 +758,19 @@
     int x1,x2,y1,y2;
     if(!(x->flags&REG)||!(y->flags&REG)) return 0;
     if(reg_pair(x->reg,&rp)){
-        x1=rp.r1;x2=rp.r2;
+	x1=rp.r1;x2=rp.r2;
     }else{
-        x1=x->reg;x2=-1;
+	x1=x->reg;x2=-1;
     }
     if(reg_pair(y->reg,&rp)){
-        y1=rp.r1;y2=rp.r2;
+	y1=rp.r1;y2=rp.r2;
     }else{
-        y1=y->reg;y2=-2;
+	y1=y->reg;y2=-2;
     }
     if(x1==y1||x1==y2||x2==y1||x2==y2)
-        return 1;
+	return 1;
     else
-        return 0;
+	return 0;
 }
 
 /* Versucht, ein IC so zu drehen, dass q2 und z kein gemeinsames */
@@ -871,14 +802,14 @@
   if(p->flags&VAR) {
     printval(f,&p->val,MAXINT);
     if(p->flags&REG){
-        fprintf(f,"+%s",regnames[p->reg]);
+	fprintf(f,"+%s",regnames[p->reg]);
     }else if(p->v->storage_class==AUTO||p->v->storage_class==REGISTER){
-        fprintf(f,"+%ld(FP)", zm2l(p->v->offset));
+	fprintf(f,"+%ld(FP)", zm2l(p->v->offset));
     }else{
       if(p->v->storage_class==STATIC){
-        fprintf(f,"+L%ld",zm2l(p->v->offset));
+	fprintf(f,"+L%ld",zm2l(p->v->offset));
       }else{
-        fprintf(f,"+_%s",p->v->identifier);
+	fprintf(f,"+_%s",p->v->identifier);
       }
     }
     if(*p->v->identifier)
@@ -960,8 +891,6 @@
   }
   if(ISPOINTER(f)) {fprintf(o,"%s to ",typname[f&NQ]);prd(o,p->next);return;}
   if(ISARRAY(f)) {fprintf(o,"%s [size %ld] of ",typname[f&NQ],zm2l(p->size));prd(o,p->next);return;}
-  if(ISVECTOR(f)) {fprintf(o,"vector [size %ld] of %s",zm2l(p->size),typname[VECTYPE(f)&NQ]);return;}
-
   fprintf(o,"%s",typname[f&NQ]);
 }
 void print_var(FILE *o,struct Var *p)
@@ -978,7 +907,7 @@
 {
   if (!t) return 0;
   if (ISARRAY(t->flags)) {
-        return get_first_base_type(t->next);
+	return get_first_base_type(t->next);
   } else if ((ISSTRUCT(t->flags)) || (ISUNION(t->flags))) {
     return get_first_base_type((*t->exact->sl)[0].styp);
   } else return t->flags;
@@ -1251,10 +1180,10 @@
       if(emit_l>=EMIT_BUF_DEPTH) emit_l=0;
       emit_p=emit_buffer[emit_l];
       if(emit_l==emit_f){
-        /* FIXME: error check */
-        fputs(emit_buffer[emit_f],f);
-        emit_f++;
-        if(emit_f>=EMIT_BUF_DEPTH) emit_f=0;
+	/* FIXME: error check */
+	fputs(emit_buffer[emit_f],f);
+	emit_f++;
+	if(emit_f>=EMIT_BUF_DEPTH) emit_f=0;
       }
     }
   }
@@ -1303,7 +1232,7 @@
     }
     for(j=0;j<num;j++){
       if(!compare_const(&vals[j],&p->q2.val,t)){
-        return 0; /* FIXME? Could simply ignore? */
+	return 0; /* FIXME? Could simply ignore? */
       }
     }
     vals[num]=p->q2.val;
@@ -1317,31 +1246,31 @@
     num++;
     if(t&UNSIGNED){
       if(zumleq(vumax,min.vumax))
-        insert_const(&min,UNSIGNED|MAXINT);
+	insert_const(&min,UNSIGNED|MAXINT);
       if(zumleq(max.vumax,vumax))
-        insert_const(&max,UNSIGNED|MAXINT);
+	insert_const(&max,UNSIGNED|MAXINT);
       cur_density=num/(1+zld2d(zum2zld(zumsub(max.vumax,min.vumax))));
       if(cur_density>=min_density){
-        ct.num=num;
-        ct.next_ic=p;
-        ct.min=min;
-        ct.max=max;
-        ct.diff=zumsub(max.vumax,min.vumax);
-        ct.density=cur_density;
+	ct.num=num;
+	ct.next_ic=p;
+	ct.min=min;
+	ct.max=max;
+	ct.diff=zumsub(max.vumax,min.vumax);
+	ct.density=cur_density;
       }
     }else{
       if(zmleq(vmax,min.vmax))
-        insert_const(&min,MAXINT);
+	insert_const(&min,MAXINT);
       if(zmleq(max.vmax,vmax))
-        insert_const(&max,MAXINT);
+	insert_const(&max,MAXINT);
       cur_density=num/zld2d(zum2zld((1+zumsub(zm2zum(max.vmax),zm2zum(min.vmax)))));
       if(cur_density>=min_density){
-        ct.num=num;
-        ct.next_ic=p;
-        ct.min=min;
-        ct.max=max;
-        ct.diff=zumsub(zm2zum(max.vmax),zm2zum(min.vmax));
-        ct.density=cur_density;
+	ct.num=num;
+	ct.next_ic=p;
+	ct.min=min;
+	ct.max=max;
+	ct.diff=zumsub(zm2zum(max.vmax),zm2zum(min.vmax));
+	ct.density=cur_density;
       }
     }
   }
@@ -1370,8 +1299,8 @@
     for(i=0;i<ct->num;i++){
       eval_const(&ct->vals[i],ct->typf);
       if(zmeqto(vmax,zm)&&zumeqto(vumax,zum)){
-        emit(f,"%s%d\n",labprefix,ct->labels[i]);
-        break;
+	emit(f,"%s%d\n",labprefix,ct->labels[i]);
+	break;
       }
     }
     if(i>=ct->num)
@@ -1396,10 +1325,8 @@
   zmax offset=l2zm(0L);
   struct reg_handle rh=empty_reg_handle;
   for(i=0;i<v->vtyp->exact->count;i++){
-#if 0
     if((*v->vtyp->exact->sl)[i].reg!=0)
       continue;
-#endif
     if(((*v->vtyp->exact->sl)[i].styp->flags&NQ)==VOID)
       ierror(0);
     if(reg_parm(&rh,(*v->vtyp->exact->sl)[i].styp,0,v->vtyp)!=0)
@@ -1459,7 +1386,7 @@
   if(p->call_cnt){
     for(i=0;i<p->call_cnt;i++){
       if(p->call_list[i].v->fi&&(p->call_list[i].v->fi->flags&ALL_REGS)){
-        bvunite(regs_modified,p->call_list[i].v->fi->regs_modified,RSIZE);
+	bvunite(regs_modified,p->call_list[i].v->fi->regs_modified,RSIZE);
 #if HAVE_OSEK
 /* removed */
 /* removed */
@@ -1475,15 +1402,15 @@
 /* removed */
 #endif
       }else{
-        int r;
-        for(r=1;r<=MAXR;r++) if(regscratch[r]) BSET(regs_modified,r);
-        err_ic=p;
-        if(!p->call_list[i].v->fi) p->call_list[i].v->fi=new_fi();
-        if(!(p->call_list[i].v->fi->flags&WARNED_REGS)){
-          error(318,p->call_list[i].v->identifier);
-          p->call_list[i].v->fi->flags|=WARNED_REGS;
-        }
-        return 0;
+	int r;
+	for(r=1;r<=MAXR;r++) if(regscratch[r]) BSET(regs_modified,r);
+	err_ic=p;
+	if(!p->call_list[i].v->fi) p->call_list[i].v->fi=new_fi();
+	if(!(p->call_list[i].v->fi->flags&WARNED_REGS)){
+	  error(318,p->call_list[i].v->identifier);
+	  p->call_list[i].v->fi->flags|=WARNED_REGS;
+	}
+	return 0;
       }
     }
     return 1;
@@ -1491,8 +1418,6 @@
   err_ic=p;if(showwarnings) error(320);
   return 0;
 }
-
-
 
 #ifndef HAVE_TARGET_BFLAYOUT
 int bflayout(int bfoffset,int bfsize,int t)
diff -Naur vbcc/supp.h /usr/glenda/advbcc/Advent-master/vbcc/supp.h
--- vbcc/supp.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/supp.h	Tue Sep 22 04:18:49 2015
@@ -23,19 +23,10 @@
 #define UNION 13
 #define ENUM 14
 #define FUNKT 15
-#define BOOL 16
-#define MAXINT 17 /* should not be accessible to application */
+#define MAXINT 16 /* should not be accesible to application */
 #define MAX_TYPE MAXINT
-#define MAXVECDIM 16
-#define VECBOOL (MAXINT+1)
-#define VECCHAR (VECBOOL+MAXVECDIM)
-#define VECSHORT (VECCHAR+MAXVECDIM)
-#define VECINT (VECSHORT+MAXVECDIM)
-#define VECLONG (VECINT+MAXVECDIM)
-#define VECFLOAT (VECLONG+MAXVECDIM)
-#define VECLAST (VECFLOAT+MAXVECDIM)
-#define NQ 255   /* f&NQ gives type without any qualifiers */
-#define NU 511   /* f&NU gives type without any qualifiers but UNSIGNED */
+#define NQ 127   /* f&NQ gives type without any qualifiers */
+#define NU 255   /* f&NU gives type without any qualifiers but UNSIGNED */
 #define q1typ(p) ((p->code==ADDI2P||p->code==SUBIFP||p->code==CONVERT||p->code==SUBPFP)?p->typf2:p->typf)
 #define q2typ(p) ((p->code==SUBPFP||p->code==LSHIFT||p->code==RSHIFT)?p->typf2:p->typf)
 #define ztyp(p) ((p->code==ADDI2P||p->code==SUBIFP||p->code==ADDRESS)?p->typf2:p->typf)
@@ -54,14 +45,14 @@
 #define BCLR(array,bit) (array)[(bit)/BVBITS]&=~(1<<((bit)%BVBITS))
 #define BTST(array,bit) ((array)[(bit)/BVBITS]&(1<<((bit)%BVBITS)))
 /* type-qualifiers */
-#define UNSIGNED (NQ+1)
-#define CONST (UNSIGNED<<1)
-#define VOLATILE (CONST<<1)
-#define RESTRICT (VOLATILE<<1)
-#define UNCOMPLETE (RESTRICT<<1)
-#define STRINGCONST (UNCOMPLETE<<1)
-#define BOOLEAN (STRINGCONST<<1)
-#define SIGNED_CHARACTER (BOOLEAN<<1)
+#define UNSIGNED 128
+#define CONST 256
+#define VOLATILE 512
+#define RESTRICT 1024
+#define UNCOMPLETE 2048
+#define STRINGCONST 4096
+#define BOOLEAN 8192
+#define SIGNED_CHARACTER	16384
 #ifdef HAVE_ECPP
 /* removed */
 /* removed */
@@ -109,12 +100,6 @@
 #ifndef ISARRAY
 #define ISARRAY(x) ((x&NQ)==ARRAY)
 #endif
-#ifndef ISVECTOR
-#define ISVECTOR(x) ((x&NQ)>=VECBOOL&&(x&NQ)<=VECLAST)
-#endif
-#ifndef VECDIM
-#define VECDIM(x) ((((x&NQ)-VECBOOL)&15)+1)
-#endif
 #ifndef ISSCALAR
 #define ISSCALAR(x) ((x&NQ)>=CHAR&&(x&NQ)<=POINTER)
 #endif
@@ -292,7 +277,7 @@
 #define REFERENCED 65536    /* variable referenced */
 #define INLINEFUNC (REFERENCED*2)
 #define INLINEEXT (INLINEFUNC*2)
-#define BUILTIN (INLINEFUNC*2)
+
 
 /* C-only */
 struct struct_list{
@@ -374,8 +359,6 @@
 /* flags for ICs */
 #define LOOP_COND_TRUE 1  /* loop condition is true at first iteration */
 #define EFF_IC 2          /* do not transform IC with doubtful optimizations */
-#define ORDERED_PUSH_COPY 4 /* mark a copy of an ordered push */
-
 /*  Available codes for struct IC. See interface.doc. */
 #define KOMMA 1
 #define ASSIGN 2
@@ -485,7 +468,6 @@
 #define NOP 97
 #define BITFIELD 98
 #define LITERAL 99
-#define REINTERPRET 100
 extern char *typname[];
 extern zmax sizetab[];
 extern char *storage_class_name[];
@@ -653,8 +635,6 @@
 #ifdef HAVE_EXT_TYPES
 extern void conv_typ(struct Typ *);
 #endif
-extern int VECTYPE(int);
-extern int mkvec(int,int);
 extern zmax szof(struct Typ *);
 extern int is_vlength(struct Typ *);
 extern struct Var *vlength_szof(struct Typ *);
@@ -677,7 +657,6 @@
 extern int is_volatile_ic(struct IC *);
 extern struct case_table *calc_case_table(struct IC *,double);
 int calc_regs(struct IC *,int);
-struct Var *declare_builtin(char *name,int ztyp,int q1typ,int q1reg,int q2typ,int q2reg,int nosidefx,char *asm);
 extern void emit_jump_table(FILE *,struct case_table *,char *,char *,int);
 extern void optimize(long, struct Var *);
 int bvcmp(bvtype *dest,bvtype *src,size_t len);
@@ -724,7 +703,7 @@
 extern int handle_pragma(const char *);
 #endif
 #ifdef HAVE_LIBCALLS
-extern char *use_libcall(int code,int t1,int t2);
+extern char *use_libcall(np);
 #endif
 extern int cost_savings(struct IC *,int,struct obj *);
 /* additional declarations for targets which pass arguments in */
diff -Naur vbcc/t1.h /usr/glenda/advbcc/Advent-master/vbcc/t1.h
--- vbcc/t1.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/t1.h	Thu Jan  1 00:00:00 1970
@@ -1,2 +0,0 @@
-#include "t2.h"
-
diff -Naur vbcc/t2.h /usr/glenda/advbcc/Advent-master/vbcc/t2.h
--- vbcc/t2.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/t2.h	Thu Jan  1 00:00:00 1970
@@ -1,2 +0,0 @@
-t2 is here
-
diff -Naur vbcc/tasm.c /usr/glenda/advbcc/Advent-master/vbcc/tasm.c
--- vbcc/tasm.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/tasm.c	Thu Jan  1 00:00:00 1970
@@ -1,128 +0,0 @@
-/*  Test-language for vbcc. */
-
-#include "supp.h"
-
-struct Var *fv;
-
-struct Typ tint,mfunc;
-struct struct_declaration msd; /* initialized to zero */
-
-void raus(void)
-{
-    while(fv){
-        struct Var *m=fv->next;
-        free(fv);
-        fv=m;
-    }
-    while(first_ic){
-        struct IC *m=first_ic->next;
-        free(first_ic);
-        first_ic=m;
-    }
-    exit(0);
-}
-void add_IC(struct IC *new)
-{
-    new->next=0;
-    new->prev=last_ic;
-    new->change_cnt=new->use_cnt=0;
-    new->change_list=new->use_list=0;
-    new->line=0;
-    new->file=0;
-    if(!last_ic){
-        first_ic=new;
-    }else{
-        last_ic->next=new;
-    }
-    last_ic=new;
-}
-struct Var *add_var(char *name,struct Typ *t,int sc)
-{
-    struct Var *v=mymalloc(sizeof(*v));
-    v->vtyp=t;
-    v->storage_class=sc;
-    v->reg=0;
-    v->identifier=name;
-    v->offset=max_offset;
-    if(sc==AUTO) max_offset=zmadd(max_offset,sizetab[t->flags&NQ]);
-    v->priority=1;
-    v->flags=0;
-    v->next=fv;
-    v->clist=0;
-    v->fi=0;
-    v->inline_copy=0;
-    fv=v;
-    return v;
-}
-struct Var *add_tmp_var(struct Typ *t)
-{
-    return add_var(empty,t,AUTO);
-}
-struct Var *get_var(char *name)
-{
-    struct Var *v;char *buf;
-    for(v=fv;v;v=v->next){
-        if(!strcmp(name,v->identifier)) return v;
-    }
-    buf=mymalloc(strlen(name)+1);
-    strcpy(buf,name);
-    return add_var(buf,&tint,AUTO);
-}
-
-void read_ics()
-{
-    char s[400],q1[100],q2[100],z[100],op;
-    struct IC *new;
-    gets(s);
-    while(sscanf(s,"%99s = %99s %c %99s",z,q1,&op,q2)==4){
-        new=new_IC();
-        switch(op){
-            case '+': new->code=ADD;break;
-            case '*': new->code=MULT;break;
-            case '-': new->code=SUB;break;
-            case '/': new->code=DIV;break;
-            default: return;
-        }
-        new->typf=INT;
-        new->q1.flags=new->q2.flags=new->z.flags=VAR;
-        new->q1.am=new->q2.am=new->z.am=0;
-        new->q1.val.vmax=l2zm(0L);
-        new->q2.val.vmax=l2zm(0L);
-        new->z.val.vmax=l2zm(0L);
-        new->q1.v=get_var(q1);
-        new->q2.v=get_var(q2);
-        new->z.v=get_var(z);
-        add_IC(new);
-        gets(s);
-    }
-}
-void error(int n,...)
-{
-    printf("error %d\n",n);
-    raus();
-}
-void savescratch()
-{}
-
-main()
-{
-    struct Var *main;
-    max_offset=l2zm(0L);
-    if(!init_cg()) raus();
-    tint.flags=INT;
-    tint.next=0;
-    mfunc.flags=FUNKT;
-    mfunc.next=&tint;
-    mfunc.exact=&msd;
-    main=add_var("main",&mfunc,EXTERN);
-    read_ics();
-    printf("optflags: ");
-    scanf("%ld",&optflags);
-    pric(stdout,first_ic);
-    vl1=vl3=0;
-    vl2=fv;
-    optimize(optflags,main);
-    pric(stdout,first_ic);
-    gen_code(stdout,first_ic,main,max_offset);
-    raus();
-}
diff -Naur vbcc/tt.h /usr/glenda/advbcc/Advent-master/vbcc/tt.h
--- vbcc/tt.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/tt.h	Thu Jan  1 00:00:00 1970
@@ -1,3 +0,0 @@
-test1
-test2
-
diff -Naur vbcc/type_expr.c /usr/glenda/advbcc/Advent-master/vbcc/type_expr.c
--- vbcc/type_expr.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/type_expr.c	Tue Sep 22 04:18:49 2015
@@ -367,24 +367,23 @@
 struct Typ *arith_typ(struct Typ *a,struct Typ *b)
 /*  Erzeugt Typ fuer arithmetische Umwandlung von zwei Operanden    */
 {
-  int ta,tb,va,vol;struct Typ *new;
+    int ta,tb;struct Typ *new;
     new=new_typ();
     ta=a->flags&NU;tb=b->flags&NU;
-    vol=(a->flags&VOLATILE)|(b->flags&VOLATILE);
-    if(ta==LDOUBLE||tb==LDOUBLE){new->flags=LDOUBLE|vol;return new;}
-    if(ta==DOUBLE||tb==DOUBLE){new->flags=DOUBLE|vol;return new;}
-    if(ta==FLOAT||tb==FLOAT){new->flags=FLOAT|vol;return new;}
+    if(ta==LDOUBLE||tb==LDOUBLE){new->flags=LDOUBLE;return new;}
+    if(ta==DOUBLE||tb==DOUBLE){new->flags=DOUBLE;return new;}
+    if(ta==FLOAT||tb==FLOAT){new->flags=FLOAT;return new;}
     ta=int_erw(ta);tb=int_erw(tb);
-    if(ta==(UNSIGNED|LLONG)||tb==(UNSIGNED|LLONG)){new->flags=UNSIGNED|LLONG|vol;return new;}
-    if(ta==LLONG||tb==LLONG){new->flags=LLONG|vol;return new;}
-    if(ta==(UNSIGNED|LONG)||tb==(UNSIGNED|LONG)){new->flags=UNSIGNED|LONG|vol;return new;}
+    if(ta==(UNSIGNED|LLONG)||tb==(UNSIGNED|LLONG)){new->flags=UNSIGNED|LLONG;return new;}
+    if(ta==LLONG||tb==LLONG){new->flags=LLONG;return new;}
+    if(ta==(UNSIGNED|LONG)||tb==(UNSIGNED|LONG)){new->flags=UNSIGNED|LONG;return new;}
     if((ta==LONG&&tb==(UNSIGNED|INT))||(ta==(UNSIGNED|INT)&&tb==LONG)){
-        if(zumleq(t_max(UNSIGNED|INT),t_max(LONG))) new->flags=LONG|vol; else new->flags=UNSIGNED|LONG|vol;
+        if(zumleq(t_max(UNSIGNED|INT),t_max(LONG))) new->flags=LONG; else new->flags=UNSIGNED|LONG;
         return new;
     }
-    if(ta==LONG||tb==LONG){new->flags=LONG|vol;return new;}
-    if(ta==(UNSIGNED|INT)||tb==(UNSIGNED|INT)){new->flags=UNSIGNED|INT|vol;return new;}
-    new->flags=INT|vol;
+    if(ta==LONG||tb==LONG){new->flags=LONG;return new;}
+    if(ta==(UNSIGNED|INT)||tb==(UNSIGNED|INT)){new->flags=UNSIGNED|INT;return new;}
+    new->flags=INT;
     return new;
 }
 int int_erw(int t)
@@ -413,7 +412,7 @@
 {
   np new;
   if(!p) return 0;
-  new=new_node();
+  new=mymalloc(NODES);
   *new=*p;
   new->ntyp=clone_typ(p->ntyp);
   new->left=aos4_clone_tree(p->left);
@@ -525,7 +524,7 @@
   }
 #if HAVE_AOS4
   if(f==CALL&&p->left->flags==DSTRUCT){
-    thisp=new_node();
+    thisp=mymalloc(NODES);
     thisp->flags=ADDRESS;
     aos4err=0;
     thisp->left=aos4_clone_tree(p->left->left);
@@ -602,7 +601,7 @@
 /*  Hier muss noch einiges genauer werden (wie gehoert das?)    */
   if(p->left&&(ISARRAY(p->left->ntyp->flags)||ISFUNC(p->left->ntyp->flags))){
     if(f!=ADDRESS&&f!=ADDRESSA&&f!=ADDRESSS&&f!=FIRSTELEMENT&&f!=DSTRUCT&&(f<PREINC||f>POSTDEC)&&(f<ASSIGN||f>ASSIGNOP)){
-      np new=new_node();
+      np new=mymalloc(NODES);
       if((p->left->ntyp->flags&NQ)==ARRAY) new->flags=ADDRESSA;
       else new->flags=ADDRESS;
       new->ntyp=0;
@@ -613,7 +612,7 @@
     }
   }
   if(p->right&&f!=FIRSTELEMENT&&f!=DSTRUCT&&f!=ADDRESSS&&(ISARRAY(p->right->ntyp->flags)||ISFUNC(p->right->ntyp->flags))){
-    np new=new_node();
+    np new=mymalloc(NODES);
     if(ISARRAY(p->right->ntyp->flags)) new->flags=ADDRESSA;
     else new->flags=ADDRESS;
     new->ntyp=0;
@@ -713,7 +712,7 @@
       return 0;
     }
     ff=v->vtyp->flags&NQ;
-    if(ISARITH(ff)||ISPOINTER(ff)||ISSTRUCT(ff)||ISUNION(ff)||ISVECTOR(ff)) p->lvalue=1;
+    if(ISARITH(ff)||ISPOINTER(ff)||ISSTRUCT(ff)||ISUNION(ff)) p->lvalue=1;
     p->ntyp=clone_typ(v->vtyp);
     /*  arithmetischen const Typ als Konstante behandeln, das muss noch
 	deutlich anders werden, bevor man es wirklich so machen kann
@@ -737,11 +736,6 @@
 
   if(f==CEXPR||f==PCEXPR||f==STRING) return 1;
 
-  if(f==REINTERPRET){
-    /* todo: add checks */
-    return 1;
-  }
-
   if(f==BITFIELD) return 1;
 
   if(f==LITERAL){
@@ -768,21 +762,6 @@
   }
   if(f==LOR||f==LAND){
     int a1=-1,a2=-1,m;
-    if(ISVECTOR(p->left->ntyp->flags)){
-      if(ISVECTOR(p->right->ntyp->flags)){
-	if((p->left->ntyp->flags&NU)!=(p->right->ntyp->flags&NU)){error(89);return 0;}
-      }else{
-	if(!ISINT(p->right->ntyp->flags)){error(89);return 0;}
-      }
-      p->ntyp=new_typ();
-      p->ntyp->flags=p->left->ntyp->flags&NQ;
-      return ok;
-    }
-    if(ISVECTOR(p->right->ntyp->flags)){
-      if(!ISINT(p->left->ntyp->flags)){error(89);return 0;}
-      p->ntyp->flags=p->right->ntyp->flags&NQ;
-      return ok;
-    }
     if(f==LAND) m=1; else m=0;
 #ifdef HAVE_MISRA
 /* removed */
@@ -811,22 +790,6 @@
     return ok;
   }
   if(f==OR||f==AND||f==XOR){
-    if(ISVECTOR(p->left->ntyp->flags)){
-      if(!ISINT(VECTYPE(p->left->ntyp->flags))){error(90);return 0;}
-      if(ISVECTOR(p->right->ntyp->flags)){
-	if((p->left->ntyp->flags&NU)!=(p->right->ntyp->flags&NU)){error(98);return 0;}
-      }else{
-	if(!ISINT(p->right->ntyp->flags)){error(90);return 0;}
-      }
-      p->ntyp=clone_typ(p->left->ntyp);
-      return ok;
-    }
-    if(ISVECTOR(p->right->ntyp->flags)){
-      if(!ISINT(VECTYPE(p->right->ntyp->flags))){error(90);return 0;}
-      if(!ISINT(p->left->ntyp->flags)){error(90);return 0;}
-      p->ntyp=clone_typ(p->right->ntyp);
-      return ok;
-    }
     if(!ISINT(p->left->ntyp->flags)){error(90);return 0;}
     if(!ISINT(p->right->ntyp->flags)){error(90);return 0;}
 #ifdef HAVE_MISRA
@@ -849,25 +812,6 @@
     /*  werden                                                          */
     zmax s1,s2;zumax u1,u2;zldouble d1,d2;int c=0;
     struct Typ *t;
-    if(ISVECTOR(p->left->ntyp->flags)){
-      if(ISVECTOR(p->right->ntyp->flags)){
-	if((p->left->ntyp->flags&NU)!=(p->right->ntyp->flags&NU)){error(89);return 0;}
-      }
-      p->ntyp=new_typ();
-      if(ISFLOAT(VECTYPE(p->left->ntyp->flags)))
-	p->ntyp->flags=mkvec(INT,VECDIM(p->left->ntyp->flags));
-      else
-	p->ntyp->flags=p->left->ntyp->flags&NQ;
-      return ok;
-    }
-    if(ISVECTOR(p->right->ntyp->flags)){
-      p->ntyp=new_typ();
-      if(ISFLOAT(VECTYPE(p->right->ntyp->flags)))
-	p->ntyp->flags=mkvec(INT,VECDIM(p->left->ntyp->flags));
-      else
-	p->ntyp->flags=p->right->ntyp->flags&NQ;
-      return ok;
-    }
 #ifdef HAVE_MISRA
 /* removed */
 /* removed */
@@ -992,35 +936,7 @@
     return ok;
   }
   if(f==ADD||f==SUB||f==MULT||f==DIV||f==MOD||f==LSHIFT||f==RSHIFT||f==PMULT){
-    if(ISVECTOR(p->left->ntyp->flags)){
-      if((f==MOD||f==LSHIFT||f==RSHIFT)&&ISFLOAT(VECTYPE(p->left->ntyp->flags))){
-	error(98);
-	return 0;
-      }
-      if(ISARITH(p->right->ntyp->flags)){
-	p->ntyp=clone_typ(p->left->ntyp);
-	return ok;
-      }
-      if((p->left->ntyp->flags&NU)==(p->right->ntyp->flags&NU)){
-	p->ntyp=clone_typ(p->left->ntyp);
-	return ok;
-      }
-      error(98);
-      return 0;
-    }
-    if(ISVECTOR(p->right->ntyp->flags)){
-      if((f==MOD||f==LSHIFT||f==RSHIFT)&&ISFLOAT(VECTYPE(p->right->ntyp->flags))){
-	error(98);
-	return 0;
-      }
-      if(ISARITH(p->left->ntyp->flags)){
-	p->ntyp=clone_typ(p->right->ntyp);
-	return ok;
-      }
-      error(98);
-      return 0;
-    }
-    if(!ISARITH(p->left->ntyp->flags)||!ISARITH(p->right->ntyp->flags)){
+    if(!ISARITH(p->left->ntyp->flags&NQ)||!ISARITH(p->right->ntyp->flags&NQ)){
       np new;zmax sz; int type=0;
 #ifdef MAXADDI2P
       static struct Typ pmt={MAXADDI2P};
@@ -1048,11 +964,11 @@
 	  if(!ISINT(p->right->ntyp->flags))
 	    {error(97,ename[f]);return 0;}
 	  if(p->right->flags!=PMULT&&p->right->flags!=PCEXPR){
-	    new=new_node();
+	    new=mymalloc(NODES);
 	    new->flags=PMULT;
 	    new->ntyp=0;
 	    new->left=p->right;
-	    new->right=new_node();
+	    new->right=mymalloc(NODES);
 	    if(is_vlength(p->left->ntyp->next)){
 	      new->right->flags=IDENTIFIER;
 	      new->right->identifier=empty;
@@ -1087,11 +1003,11 @@
 	  {error(98);return 0;}
 	if(p->flags==SUB){error(99);return 0;}
 	if(p->left->flags!=PMULT&&p->left->flags!=PCEXPR){
-	  new=new_node();
+	  new=mymalloc(NODES);
 	  new->flags=PMULT;
 	  new->ntyp=0;
 	  new->left=p->left;
-	  new->right=new_node();
+	  new->right=mymalloc(NODES);
 	  if(is_vlength(p->right->ntyp->next)){
 	    new->right->flags=IDENTIFIER;
 	    new->right->identifier=empty;
@@ -1284,17 +1200,6 @@
     return ok;
   }
   if(f==MINUS||f==KOMPLEMENT||f==NEGATION){
-    if(ISVECTOR(p->left->ntyp->flags)){
-      if(f==NEGATION){
-	if(ISFLOAT(VECTYPE(p->left->ntyp->flags))){error(98);return 0;}
-	p->ntyp=new_typ();
-	p->ntyp->flags=p->left->ntyp->flags&NQ;
-	return ok;
-      }
-      if(f==KOMPLEMENT&&ISFLOAT(VECTYPE(p->left->ntyp->flags))){error(109);return 0;}
-      p->ntyp=clone_typ(p->left->ntyp);
-      return ok;
-    }
     if(!ISARITH(p->left->ntyp->flags)){
       if(f!=NEGATION){
 	error(107);return 0;
@@ -1544,10 +1449,10 @@
     if(ISUNION(p->left->ntyp->flags)) offset=l2zm(0L);
     p->flags=CONTENT;
     if(p->ntyp) {freetyp(p->ntyp);p->ntyp=0;}
-    new=new_node();
+    new=mymalloc(NODES);
     new->flags=ADD;
     new->ntyp=0;
-    new->right=new_node();
+    new->right=mymalloc(NODES);
     new->right->left=new->right->right=0;
     new->right->flags=PCEXPR;
     new->right->ntyp=new_typ();
@@ -1559,7 +1464,7 @@
       new->right->ntyp->next=0;
       new->right->val.vlong=zm2zl(offset);
     }
-    new->left=new_node();
+    new->left=mymalloc(NODES);
     new->left->flags=ADDRESSS;
     new->left->left=p->left;
     new->left->right=p->right;
@@ -1579,7 +1484,7 @@
     if(bfs!=-1){
       /* create a special node for bitfields */
       ok|=type_expression2(p,0);
-      new=new_node();
+      new=mymalloc(NODES);
       *new=*p;
       p->flags=BITFIELD;
       p->left=new;
@@ -1872,6 +1777,7 @@
     return ok;
   }
   if(f==COND){
+    if(const_expr){error(46);return 0;}
     if(!ISARITH(p->left->ntyp->flags)&&!ISPOINTER(p->left->ntyp->flags)){
       error(29);
       return 0;
@@ -1897,7 +1803,6 @@
       free(merk);
       return 1;
     }
-    if(const_expr){error(46);return 0;}
     p->ntyp=clone_typ(p->right->ntyp);
     return 1;
   }
@@ -1948,7 +1853,7 @@
 {
     struct struct_declaration *sd;
     if(ISARRAY(p->ntyp->flags)||ISFUNC(p->ntyp->flags)){
-      np new=new_node();
+        np new=mymalloc(NODES);
         if(ISARRAY(p->ntyp->flags)){
             new->flags=ADDRESSA;
             new->ntyp=clone_typ(p->ntyp);
@@ -1976,11 +1881,6 @@
     int c=0,f,komm,null1,null2,eins1,eins2;np merk;
     zldouble d1,d2;zumax u1,u2;zmax s1,s2;
     f=p->flags;
-    
-    /* do not optimze pointer-pointer */
-    if(f==SUB&&ISPOINTER(p->left->ntyp->flags)&&ISPOINTER(p->right->ntyp->flags))
-      return 1;
-
     /*  kommutativ? */
     if(f==ADD||f==MULT||f==PMULT||(f>=OR&&f<=AND)) komm=1; else komm=0;
     /*  Berechnet Wert, wenn beides Konstanten sind     */
@@ -2192,9 +2092,6 @@
       return 0;
     }else 
   return 1;
-  }
-  if(ISVECTOR(zt->flags)&&(zt->flags&NU)==(qt->flags&NU)){
-      return 1;
   }
   if(ISPOINTER(zt->flags)&&ISPOINTER(qt->flags)){
     if((zt->next->flags&NQ)==VOID&&!ISFUNC(qt->next->flags)) return 1;
diff -Naur vbcc/ucpp/cpp.c /usr/glenda/advbcc/Advent-master/vbcc/ucpp/cpp.c
--- vbcc/ucpp/cpp.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/ucpp/cpp.c	Tue Sep 22 04:18:49 2015
@@ -277,12 +277,6 @@
 
 	return newp;
 }
-
-#else  /* no conversion */
-static char *convert_path(char *path)
-{
-	return sdup(path);
-}
 #endif
 
 /*
@@ -1159,11 +1153,13 @@
 	      misra_neu(88,19,2,-1);
 	}
 #endif
+#if defined(MSDOS) || defined(ATARI) || defined(AMIGA)
 	{
 		char *conv_fname = convert_path(fname);
 		freemem(fname);
 		fname = conv_fname;
 	}
+#endif
 	f = nex ? find_file_next(fname) : find_file(fname, string_fname);
 	if (!f) {
 		pop_file_context(ls);
@@ -1971,8 +1967,13 @@
 	if (incpath) {
 		int i;
 
-		for (i = 0; incpath[i]; i ++)
+		for (i = 0; incpath[i]; i ++) {
+#if defined(MSDOS) || defined(ATARI) || defined(AMIGA)
 			aol(include_path, include_path_nb, convert_path(incpath[i]), INCPATH_MEMG);
+#else
+			aol(include_path, include_path_nb, sdup(incpath[i]), INCPATH_MEMG);
+#endif
+		}
 	}
 }
 
@@ -1981,7 +1982,11 @@
  */
 void add_incpath(char *path)
 {
+#if defined(MSDOS) || defined(ATARI) || defined(AMIGA)
 	aol(include_path, include_path_nb, convert_path(path), INCPATH_MEMG);
+#else
+	aol(include_path, include_path_nb, sdup(path), INCPATH_MEMG);
+#endif
 }
 
 #ifdef STAND_ALONE
diff -Naur vbcc/ucpp/eval.c /usr/glenda/advbcc/Advent-master/vbcc/ucpp/eval.c
--- vbcc/ucpp/eval.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/ucpp/eval.c	Tue Sep 22 04:26:06 2015
@@ -1043,6 +1043,7 @@
 invalid_token_err:
 	error(eval_line, "invalid token in constant integral expression");
 	throw(eval_exception);
+	return;
 }
 
 #define UNARY(x)	((x) != NUMBER && (x) != NAME && (x) != CHAR \
diff -Naur vbcc/ucpp/macro.c /usr/glenda/advbcc/Advent-master/vbcc/ucpp/macro.c
--- vbcc/ucpp/macro.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/ucpp/macro.c	Tue Sep 22 04:18:49 2015
@@ -27,12 +27,12 @@
  *
  */
 
-/*vb*/
+/*vb*/
 #ifdef HAVE_MISRA
 void misra(int,...);
 void misra_neu(int, int, int, int, ...);
-int misra_is_reserved(const char*);
-#endif
+int misra_is_reserved(const char*);
+#endif
 
 #include <stdio.h>
 #include <string.h>
@@ -45,9 +45,9 @@
 #include "tune.h"
 
 /*vb*/
-extern int nesting;
-#ifdef HAVE_MISRA
-extern int misracheck;
+extern int nesting;
+#ifdef HAVE_MISRA
+extern int misracheck;
 #endif
 
 /*
@@ -311,10 +311,10 @@
 	size_t nt;
 	long l = ls->line;
 	
-	/*vb*/
+	/*vb*/
 #ifdef HAVE_MISRA
 	if(nesting!=0) misra_neu(91,19,5,0);
-#endif
+#endif
 
 	/* find the next non-white token on the line, this should be
 	   the macro name */
@@ -341,11 +341,11 @@
 	 *
 	 * Since it is easy to avoid this error (with a #undef directive),
 	 * we choose to enforce the rule and emit an error.
-	 */
-
-#ifdef HAVE_MISRA
-		if (misra_is_reserved(mname)) misra_neu(114,20,1,-1);
-#endif
+	 */
+
+#ifdef HAVE_MISRA
+		if (misra_is_reserved(mname)) misra_neu(114,20,1,-1);
+#endif
 
 	if ((n = getHT(macros, &mname)) != 0) {
 		/* redefinition of a macro: we must check that we define
@@ -641,7 +641,7 @@
 
 
 #ifdef LOW_MEM
-	/*vb*/
+	/*vb*/
 #ifdef HAVE_MISRA
 	if(misracheck)
 	{
@@ -657,7 +657,7 @@
 	      if(tt==LPAR) lp=1; else lp=0;
 	    }
 	  }
-	}
+	}
 #endif
 #else
 #error not supported
@@ -753,10 +753,10 @@
 			 */
 			if (i < (narg + vaarg)) {
 				error(begin_line, "not enough arguments "
-					"to macro");
+					"to macro");
 #ifdef HAVE_MISRA
 				misra_neu(94,19,8,0);
-#endif
+#endif
 				return 4;
 			}
 			if (i > narg) {
@@ -987,7 +987,7 @@
  * C99 specifies that these macros should remain constant throughout
  * the whole preprocessing.
  */
-char compile_time[12], compile_date[24], compile_adate[16];
+char compile_time[12], compile_date[24], compile_adate[12];
 
 /*
  * substitute_macro() performs the macro substitution. It is called when
@@ -1025,11 +1025,11 @@
 		t.name = m->name;
 		print_token(ls, &t, 0);
 		return 0;
-	}
+	}
 #ifdef HAVE_MISRA
-	if (!strcmp(m->name,"offsetof")) misra_neu(120,20,6,-1);
+	if (!strcmp(m->name,"offsetof")) misra_neu(120,20,6,-1);
 	if (!strcmp(m->name,"setjmp")) misra_neu(122,20,7,-1);
-#endif
+#endif
 	/*
 	 * put a separation from preceeding tokens
 	 */
@@ -1767,10 +1767,10 @@
  */
 int handle_undef(struct lexer_state *ls)
 {
-  /*vb*/
+  /*vb*/
 #ifdef HAVE_MISRA
   if(nesting!=0) misra_neu(91,19,5,0);
-  misra_neu(92,19,6,0);
+  misra_neu(92,19,6,0);
 #endif
 
 	while (!next_token(ls)) {
diff -Naur vbcc/vars.c /usr/glenda/advbcc/Advent-master/vbcc/vars.c
--- vbcc/vars.c	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/vars.c	Tue Sep 22 04:18:49 2015
@@ -1,7 +1,7 @@
 /*  $VER: vbcc (vars.c) V0.8    */
 #include "vbc.h"
 #ifdef AMIGA
-static const char *__ver="$VER: vbcc 0.9d (09.03.2014)\r\n";
+static const char *__ver="$VER: vbcc 0.9b (19.05.2011)\r\n";
 long __stack=65536;
 #endif
 char *s,*ident;
@@ -19,7 +19,6 @@
 struct rpair rp;
 FILE *out,*ic1,*ic2,*ppout,*cmdfile;
 int c99;
-int opencl;
 int disallow_statics;
 int header_cnt;
 int wpo,wpo_key;
@@ -45,7 +44,7 @@
     0,VALFLAG,0,0,0,STRINGFLAG,0,
     VALFLAG,VALFLAG,0,VALFLAG,0,
     FUNCFLAG,FUNCFLAG,FUNCFLAG,0,
-    0,0,0
+    0,0
 };
 char *c_flags_name[MAXCF]={
     "O","o","ic1","ic2",
@@ -58,7 +57,7 @@
     "stack-check","inline-depth","g","c99","wpo","cmd","noitra",
     "misra","coloring","dmalloc","disable","soft-float",
     "misrawarn","misradontwarn","reserve-reg","ecpp",
-    "short-push","unsigned-char","opencl"
+    "short-push","unsigned-char"
 };
 union ppi c_flags_val[MAXCF];
 char *inname;
@@ -85,4 +84,4 @@
 #endif
 
 char *cur_func="shouldn't happen!";
-char *copyright="vbcc V0.9d (c) in 1995-2014 by Volker Barthelmann";
+char *copyright="vbcc V0.9b (c) in 1995-2011 by Volker Barthelmann";
diff -Naur vbcc/vbc.h /usr/glenda/advbcc/Advent-master/vbcc/vbc.h
--- vbcc/vbc.h	Tue Sep 22 04:27:51 2015
+++ /usr/glenda/advbcc/Advent-master/vbcc/vbc.h	Tue Sep 22 04:18:49 2015
@@ -61,11 +61,7 @@
    inclusive_or_expression(void),logical_and_expression(void),
    logical_or_expression(void),conditional_expression(void),
    assignment_expression(void),expression(void),primary_expression(void);
-extern struct argument_list *argument_list_expression(void);
-extern struct const_list *cl_from_string(char *start, char *end);
-
-extern np new_node(void);
-
+struct argument_list *argument_list_expression(void);
 /* puh  */
 extern int is_keyword(char *);
 extern void pre(FILE *,np),pra(FILE *,struct argument_list *);
@@ -114,7 +110,6 @@
 extern int usz;
 
 extern int c99;
-extern int opencl;
 extern int disallow_statics;
 extern int header_cnt;
 extern int softfloat;
@@ -123,7 +118,6 @@
 extern FILE *input_wpo;
 
 extern void gen_IC(np,int,int),convert(np,int),gen_label(int);
-extern void gen_test(struct obj *,int,int,int);
 extern void savescratch(int,struct IC *,int,struct obj *);
 struct regargs_list{
   struct regargs_list *next;
